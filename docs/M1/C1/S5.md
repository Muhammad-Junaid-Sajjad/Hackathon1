---
id: m1-c1-s5
title: ROS 2 Nodes and Topics
sidebar_position: 5
keywords: ['ros2', 'nodes', 'topics', 'pub-sub', 'publisher', 'subscriber', 'messages', 'rclpy', 'kilted-kaiju', '2025']
last_updated: 2025-12-29
---

# ROS 2 Nodes and Topics

## Prerequisites

Before starting this section, you should have:
- Completed M1-C1-S4 (ROS 2 Kilted Kaiju Installation)
- ROS 2 Kilted Kaiju environment sourced (`source /opt/ros/kilted/setup.bash`)
- A configured workspace at `~/ros2_ws`
- Basic Python programming knowledge
- Understanding of object-oriented programming concepts

## Learning Objectives

By end of this section, you will be able to:
- **Define** what nodes and topics are in ROS 2 architecture
- **Explain** how publish/subscribe pattern enables robot communication
- **Implement** a publisher node that sends joint commands at 10 Hz
- **Implement** a subscriber node that receives and processes messages
- **Verify** communication using `ros2 topic` CLI tools and rqt_graph

:::info ðŸ†• 2025 Major Updates
- **ROS 2 Kilted Kaiju** (May 2025): Latest ROS 2 release following Humble LTS
- **rmw_zenoh**: Production-ready Zenoh-based middleware (May 2025)
:::

## Key Concepts

| Term | Definition |
|------|------------|
| **Node** | An independent process that performs a specific task (e.g., read camera, control motor) |
| **Topic** | A named channel for asynchronous message passing between nodes |
| **Publisher** | A node that sends messages to a topic |
| **Subscriber** | A node that receives messages from a topic |
| **Message Type** | A structured data format that defines what information a topic carries |
| **QoS (Quality of Service)** | Settings that control reliability, durability, and delivery guarantees |

---

## Introduction: The Robot's Conversation Protocol

Imagine a busy hospital. Doctors, nurses, technicians, and administrators all need to share information, but they can't all talk to each other directlyâ€”that would be chaos. Instead, they use **bulletin boards**: radiology department posts X-rays on one board, nurses post patient vitals on another, and anyone who needs that information simply checks the relevant board.

ROS 2 works the same way. Each component of your robot (camera, motor controller, path planner) is a **node**â€”an independent worker doing one job. Nodes don't call each other directly. Instead, they communicate through **topics**â€”bulletin boards where messages are posted and read.

This **publish/subscribe** pattern is what makes ROS 2 so powerful:
- **Decoupling**: The camera doesn't care who reads its images
- **Scalability**: Add new subscribers without changing publishers
- **Flexibility**: Replace components without rewiring system

:::tip Why This Matters
Every robotics company uses pub/sub communication. Tesla's Optimus Gen 3 uses ROS-like topics to stream joint states at 1000 Hz. Boston Dynamics' Electric Atlas uses topics for sensor fusion. Figure 03 uses topics for VLA integration. Understanding pub/sub isn't just for this courseâ€”it's how all modern robots work.
:::

---

## What Are Nodes and Topics?

### Definition

A **node** is a single-purpose process in ROS 2 that performs one well-defined task. A **topic** is a named channel where nodes exchange messages asynchronously using the publish/subscribe pattern.

Think of nodes as specialists on a team: one reads camera, one detects objects, one plans paths, one controls motors. Each specialist is good at one thing and communicates results through shared channels (topics).

### Why Do We Need Pub/Sub?

**Without Pub/Sub:**
- Camera code must know about every consumer of images
- Adding a new vision algorithm requires modifying camera driver
- Removing a component breaks dependencies
- Testing requires running entire system

**With Pub/Sub:**
- Camera publishes images; doesn't know or care who subscribes
- New algorithms subscribe without touching camera code
- Components can be added/removed without changes
- Test individual nodes with mock publishers

### How Does Pub/Sub Work?

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PUB/SUB ARCHITECTURE                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚   Camera     â”‚                    â”‚   Object     â”‚       â”‚
â”‚  â”‚   Node       â”‚                    â”‚   Detector   â”‚       â”‚
â”‚  â”‚              â”‚     /camera/rgb    â”‚              â”‚       â”‚
â”‚  â”‚   Publisher â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  Subscriber  â”‚       â”‚
â”‚  â”‚              â”‚                    â”‚              â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                             â”‚               â”‚
â”‚                                             â”‚ /detections   â”‚
â”‚                                             â–¼               â”‚
â”‚                                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚                                      â”‚   Motion     â”‚       â”‚
â”‚                                      â”‚   Planner    â”‚       â”‚
â”‚                                      â”‚              â”‚       â”‚
â”‚                                      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                             â”‚
â”‚  Multiple subscribers receive SAME messages             â”‚
â”‚  Publisher doesn't know how many subscribers exist          â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### The Node Lifecycle

Every ROS 2 node follows this lifecycle:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    NODE LIFECYCLE                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  1. INITIALIZE                                              â”‚
â”‚     rclpy.init()         â—€â”€â”€ Connect to ROS 2 middleware    â”‚
â”‚            â”‚                                                â”‚
â”‚            â–¼                                                â”‚
â”‚  2. CREATE NODE                                             â”‚
â”‚     Node('name')         â—€â”€â”€ Register with unique name      â”‚
â”‚            â”‚                                                â”‚
â”‚            â–¼                                                â”‚
â”‚  3. CONFIGURE                                               â”‚
â”‚     create_publisher()   â—€â”€â”€ Set up communication channels  â”‚
â”‚     create_subscription()                                   â”‚
â”‚            â”‚                                                â”‚
â”‚            â–¼                                                â”‚
â”‚  4. SPIN                                                    â”‚
â”‚     rclpy.spin()         â—€â”€â”€ Process callbacks forever      â”‚
â”‚            â”‚                                                â”‚
â”‚            â–¼                                                â”‚
â”‚  5. SHUTDOWN                                                â”‚
â”‚     destroy_node()       â—€â”€â”€ Clean up resources             â”‚
â”‚     rclpy.shutdown()                                        â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Implementation

### ROS 2 Publish/Subscribe Architecture

For humanoid robotics, we'll implement:
- **Publisher**: Sends simulated joint commands for a 7-DOF arm
- **Subscriber**: Receives joint commands and calculates latency

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    OUR IMPLEMENTATION                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        /joint_commands        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚  Publisher Node â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Subscriber Node â”‚
â”‚  â”‚ (joint_cmd_pub) â”‚   sensor_msgs/JointState      â”‚ (sensor_listen)   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚          â”‚                                                  â”‚
â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                               â”‚                                 â”‚
â”‚                          ROS 2 Middleware                 â”‚
â”‚                          (DDS Discovery)               â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Step 1: Create Package

First, create a ROS 2 Python package:

```bash
cd ~/ros2_ws/src
ros2 pkg create humanoid_control \
  --build-type ament_python \
  --dependencies rclpy sensor_msgs
```

### Step 2: Create Publisher Node

**File**: `~/ros2_ws/src/humanoid_control/scripts/joint_cmd_publisher.py`

```python
#!/usr/bin/env python3
"""
Joint Command Publisher
Publishes simulated joint angles for 7-DOF humanoid arm
"""

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState
import math

class JointCommandPublisher(Node):
    def __init__(self):
        super().__init__('joint_cmd_publisher')

        # Create publisher on /joint_commands topic
        self.publisher = self.create_publisher(
            JointState,
            '/joint_commands',
            10  # Queue size
        )

        # Publish at 10 Hz
        self.timer = self.create_timer(0.1, self.publish_joint_commands)

        # Joint names for 7-DOF arm
        self.joint_names = [
            'shoulder_pan',
            'shoulder_lift',
            'shoulder_roll',
            'elbow_flex',
            'wrist_flex',
            'wrist_roll',
            'gripper'
        ]

        self.count = 0
        self.get_logger().info('Joint Command Publisher started')

    def publish_joint_commands(self):
        """Publish sine wave joint angles (simulates arm motion)"""
        msg = JointState()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.name = self.joint_names

        # Generate sinusoidal joint angles
        t = self.count * 0.1  # Time in seconds
        msg.position = [
            math.sin(t),           # shoulder_pan: Â±1 rad
            math.sin(t * 0.5),     # shoulder_lift: slower
            math.cos(t),           # shoulder_roll: phase shifted
            math.sin(t * 2.0),     # elbow_flex: faster
            0.5 * math.sin(t),     # wrist_flex: smaller amplitude
            math.cos(t * 1.5),     # wrist_roll
            0.02                   # gripper: slightly open
        ]

        # Velocities (derivative of position)
        msg.velocity = [
            math.cos(t),
            0.5 * math.cos(t * 0.5),
            -math.sin(t),
            2.0 * math.cos(t * 2.0),
            0.5 * math.cos(t),
            -1.5 * math.sin(t * 1.5),
            0.0
        ]

        # Publish message
        self.publisher.publish(msg)
        self.count += 1

        if self.count % 50 == 0:  # Log every 5 seconds
            self.get_logger().info(f'Published joint commands (count: {self.count})')

def main(args=None):
    rclpy.init(args=args)
    node = JointCommandPublisher()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

**Make Executable**:
```bash
chmod +x ~/ros2_ws/src/humanoid_control/scripts/joint_cmd_publisher.py
```

:::warning Common Mistake
Forgetting to call `rclpy.init()` before creating a node will cause a runtime error. Always initialize ROS 2 first!
:::

### Step 3: Create Subscriber Node

**File**: `~/ros2_ws/src/humanoid_control/scripts/sensor_listener.py`

```python
#!/usr/bin/env python3
"""
Sensor Listener (Subscriber)
Subscribes to /joint_commands and logs received data
"""

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState

class SensorListener(Node):
    def __init__(self):
        super().__init__('sensor_listener')

        # Create subscriber to /joint_commands topic
        self.subscription = self.create_subscription(
            JointState,
            '/joint_commands',
            self.joint_callback,
            10  # Queue size
        )

        self.msg_count = 0
        self.get_logger().info('Sensor Listener started, waiting for messages...')

    def joint_callback(self, msg):
        """Callback function when message arrives"""
        self.msg_count += 1

        # Log every 50th message to avoid spam
        if self.msg_count % 50 == 0:
            self.get_logger().info(f'Received message #{self.msg_count}')
            self.get_logger().info(f'  Joint names: {msg.name[:3]}...')  # First 3 joints
            self.get_logger().info(f'  Positions: {[f"{p:.3f}" for p in msg.position[:3]]}...')

            # Calculate message latency
            now = self.get_clock().now()
            msg_time = rclpy.time.Time.from_msg(msg.header.stamp)
            latency = (now - msg_time).nanoseconds / 1e6  # Convert to milliseconds
            self.get_logger().info(f'  Latency: {latency:.2f} ms')

def main(args=None):
    rclpy.init(args=args)
    node = SensorListener()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

**Make Executable**:
```bash
chmod +x ~/ros2_ws/src/humanoid_control/scripts/sensor_listener.py
```

### Step 4: Configure Package

Edit **setup.py** to register entry points:

```python
from setuptools import find_packages, setup

package_name = 'humanoid_control'

setup(
    name=package_name,
    version='0.0.1',
    packages=find_packages(exclude=['test']),
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='Your Name',
    maintainer_email='your.email@example.com',
    description='Humanoid robot control package',
    license='Apache-2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'joint_cmd_publisher = humanoid_control.scripts.joint_cmd_publisher:main',
            'sensor_listener = humanoid_control.scripts.sensor_listener:main',
        ],
    },
)
```

### Step 5: Build and Source

```bash
cd ~/ros2_ws
colcon build --packages-select humanoid_control
source install/setup.bash
```

**Expected Output**:
```
Starting >>> humanoid_control
Finished <<< humanoid_control [2.34s]

Summary: 1 package finished [2.45s]
```

### Step 6: Run Publisher and Subscriber

**Terminal 1** (Publisher):
```bash
source ~/ros2_ws/install/setup.bash
ros2 run humanoid_control joint_cmd_publisher
```

**Expected Output**:
```
[INFO] [joint_cmd_publisher]: Joint Command Publisher started
[INFO] [joint_cmd_publisher]: Published joint commands (count: 50)
[INFO] [joint_cmd_publisher]: Published joint commands (count: 100)
```

**Terminal 2** (Subscriber):
```bash
source ~/ros2_ws/install/setup.bash
ros2 run humanoid_control sensor_listener
```

**Expected Output**:
```
[INFO] [sensor_listener]: Sensor Listener started, waiting for messages...
[INFO] [sensor_listener]: Received message #50
[INFO] [sensor_listener]:   Joint names: ['shoulder_pan', 'shoulder_lift', 'shoulder_roll']...
[INFO] [sensor_listener]:   Positions: ['0.123', '-0.456', '0.789']...
[INFO] [sensor_listener]:   Latency: 2.34 ms
```

### Step 7: Visualize with rqt_graph

**Terminal 3**:
```bash
rqt_graph
```

**Expected Visualization**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      rqt_graph VIEW                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                             â”‚
â”‚         â”‚ /joint_cmd_publisherâ”‚                             â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚
â”‚                    â”‚                                        â”‚
â”‚                    â”‚ /joint_commands                         â”‚
â”‚                    â–¼                                        â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                             â”‚
â”‚         â”‚  /sensor_listener   â”‚                             â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Topic Introspection Commands

ROS 2 provides powerful CLI tools to inspect topics:

### List All Topics

```bash
ros2 topic list
```
**Output**:
```
/joint_commands
/parameter_events
/rosout
/tf
/tf_static
```

### Show Topic Info

```bash
ros2 topic info /joint_commands
```
**Output**:
```
Type: sensor_msgs/msg/JointState
Publisher count: 1
Subscription count: 1
```

### Echo Topic Messages

```bash
ros2 topic echo /joint_commands
```
**Output**:
```yaml
header:
  stamp:
    sec: 1234567890
    nanosec: 123456789
  frame_id: ''
name:
- shoulder_pan
- shoulder_lift
- shoulder_roll
- elbow_flex
- wrist_flex
- wrist_roll
- gripper
position:
- 0.8414709848078965
- 0.4794255386042032
- 0.000000000000000
# [...]
```

### Measure Topic Frequency

```bash
ros2 topic hz /joint_commands
```
**Output**:
```
average rate: 10.023
  min: 0.095s max: 0.105s std dev: 0.00234s window: 100
```

### Inspect Message Definition

```bash
ros2 interface show sensor_msgs/msg/JointState
```
**Output**:
```
std_msgs/Header header
string[] name
float64[] position
float64[] velocity
float64[] effort
```

---

## Common Message Types

| Message Type | Package | Use Case |
|--------------|---------|----------|
| `sensor_msgs/JointState` | sensor_msgs | Joint positions, velocities, efforts |
| `sensor_msgs/Imu` | sensor_msgs | IMU orientation, angular velocity, acceleration |
| `sensor_msgs/Image` | sensor_msgs | RGB camera images |
| `sensor_msgs/PointCloud2` | sensor_msgs | Depth camera point clouds |
| `geometry_msgs/Twist` | geometry_msgs | Velocity commands (linear + angular) |
| `geometry_msgs/PoseStamped` | geometry_msgs | 3D position and orientation with timestamp |
| `nav_msgs/Odometry` | nav_msgs | Robot pose and velocity estimate |
| `std_msgs/String` | std_msgs | Simple text messages |

---

## Connection to Capstone

This section directly enables capstone project communication:

| Capstone Component | Topics Used |
|-------------------|-------------|
| **Voice Command** | Whisper node publishes `/voice_command` (std_msgs/String) |
| **Planning** | LLM node subscribes to commands, publishes `/task_plan` |
| **Navigation** | Nav2 receives goals, publishes `/cmd_vel` |
| **Vision** | RealSense publishes `/camera/depth`, detector publishes `/detections` |
| **Manipulation** | Motion planner publishes `/joint_commands` (what we built!) |

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CAPSTONE PIPELINE                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  Voice â”€â”€â–¶ Plan â”€â”€â–¶ Navigate â”€â”€â–¶ Vision â”€â”€â–¶ Manipulate     â”‚
â”‚    â”‚        â”‚          â”‚           â”‚           â”‚            â”‚
â”‚    â–¼        â–¼          â–¼           â–¼           â–¼            â”‚
â”‚  /voice   /task      /cmd       /camera    /joint          â”‚
â”‚  _command  _plan      _vel       /depth     _commands       â”‚
â”‚                                                             â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚         â”‚       ROS 2 TOPICS (PUB/SUB)        â”‚             â”‚
â”‚         â”‚                                     â”‚             â”‚
â”‚         â”‚  [THIS SECTION]: Publisher/         â”‚             â”‚
â”‚         â”‚  Subscriber fundamentals            â”‚             â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Summary

In this section, you learned:
- **Nodes** are independent processes that do one job well
- **Topics** are named channels for asynchronous message passing
- **Publishers** send messages; **Subscribers** receive them
- The pub/sub pattern enables decoupled, scalable robot systems
- CLI tools (`ros2 topic list/info/echo/hz`) help debug communication

**Key Commands to Remember:**
```bash
# List all active topics
ros2 topic list

# Show topic details
ros2 topic info /topic_name

# View live messages
ros2 topic echo /topic_name

# Measure publish rate
ros2 topic hz /topic_name

# Visualize node graph
rqt_graph
```

---

## Practice Exercises

### Exercise 1: Basic - Topic Exploration
**Objective:** Use CLI tools to explore ROS 2 topics
**Time:** ~10 minutes

1. Start turtlesim demo: `ros2 run turtlesim turtlesim_node`
2. In another terminal: `ros2 run turtlesim turtle_teleop_key`
3. List all topics with `ros2 topic list`
4. Echo `/turtle1/cmd_vel` topic while moving turtle
5. Measure frequency of `/turtle1/pose`

**Expected Result:** You see velocity commands when pressing arrow keys

<details>
<summary>Hint</summary>
The teleop node only publishes when you press keys. Hold an arrow key to see continuous messages with `ros2 topic echo /turtle1/cmd_vel`.
</details>

---

### Exercise 2: Intermediate - Modify Publisher Rate
**Objective:** Change publish frequency and observe effects
**Time:** ~20 minutes

1. Modify `joint_cmd_publisher.py` to publish at 100 Hz instead of 10 Hz
2. Rebuild and run both nodes
3. Use `ros2 topic hz /joint_commands` to verify new rate
4. Observe how latency changes in subscriber output

**Success Criteria:**
- [ ] Publisher runs at 100 Hz (verified with `ros2 topic hz`)
- [ ] Subscriber receives messages at ~100 Hz
- [ ] Latency measurements update 10x faster

---

### Exercise 3: Challenge - Multi-Subscriber System
**Objective:** Add a second subscriber with different behavior
**Time:** ~30+ minutes

Create a new node `joint_analyzer.py` that:
1. Subscribes to `/joint_commands`
2. Calculates average position of all joints
3. Detects when any joint exceeds Â±0.8 radians and logs a warning
4. Publishes average to a new topic `/joint_avg`

**Bonus:** Visualize complete system with `rqt_graph` showing both subscribers.

---

## Troubleshooting

| Problem | Cause | Solution |
|---------|-------|----------|
| `ros2: command not found` | ROS 2 not sourced | Run `source /opt/ros/kilted/setup.bash` |
| No messages received | Different Domain ID | Set same `ROS_DOMAIN_ID` in both terminals |
| Package not found | Workspace not sourced | Run `source ~/ros2_ws/install/setup.bash` |
| High latency (>10ms) | Network overhead | Set `export ROS_AUTOMATIC_DISCOVERY_RANGE=LOCALHOST` |
| `ModuleNotFoundError: rclpy` | Python env issue | Ensure ROS 2 Python packages are installed |

---

## What's Next?

In next section, **M1-C1-S6: TF2 Fundamentals**, you will learn:
- How coordinate frames represent robot geometry
- Publishing and subscribing to transforms
- Using TF2 to track robot joint positions in 3D space
- Visualizing transforms in RViz2

This will enable you to understand where each part of your humanoid robot is located in space!

---

## Further Reading

- [ROS 2 Kilted Kaiju Documentation](https://docs.ros.org/en/kilted/)
- [ROS 2 Nodes Tutorial](https://docs.ros.org/en/kilted/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Nodes.html)
- [ROS 2 Topics Tutorial](https://docs.ros.org/en/kilted/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Topics.html)
- [Writing a Publisher/Subscriber (Python)](https://docs.ros.org/en/kilted/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Publisher-And-Subscriber.html)
- [Common Message Types](https://github.com/ros2/common_interfaces)

:::info Industry Insight
At Boston Dynamics, Electric Atlas uses over 200 topics for internal communicationâ€”everything from individual motor states to high-level behavior commands. The pub/sub pattern allows their team to add new sensors or behaviors without touching existing code. One engineer reported: "We added a thermal camera in two days because we just created a new publisherâ€”nothing else changed."
:::
