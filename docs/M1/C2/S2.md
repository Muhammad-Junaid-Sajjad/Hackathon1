---
id: m1-c2-s2
title: ROS 2 Actions and Long-Running Tasks
sidebar_position: 2
keywords: ['actions', 'async', 'feedback', 'preemption', 'cancellation', 'trajectory']
---

# ROS 2 Actions and Long-Running Tasks

## Prerequisites

Before starting this section, you should have:
- Completed M1-C2-S1 (ROS 2 Services)
- Understanding of asynchronous programming concepts
- Python async/await syntax familiarity
- ROS 2 workspace with custom interface generation configured
- Understanding of the difference between blocking and non-blocking calls

## Learning Objectives

By the end of this section, you will be able to:
- **Distinguish** when to use actions vs services vs topics
- **Define** custom action interfaces with goal, result, and feedback
- **Implement** an action server with progress feedback and cancellation support
- **Implement** an action client that monitors progress and can cancel goals
- **Test** actions using CLI tools (`ros2 action send_goal`)

## Key Concepts

| Term | Definition |
|------|------------|
| **Action** | A communication pattern for long-running tasks with feedback and cancellation |
| **Goal** | The target or task that the action server should achieve |
| **Result** | The final outcome returned when the action completes or is canceled |
| **Feedback** | Progress updates published during action execution |
| **Preemption** | Canceling an in-progress goal to start a new one |
| **Goal Handle** | An object that tracks a specific goal's state and provides control methods |

---

## Introduction: Tasks That Take Time

Imagine you're ordering food at a restaurant. With a service (like we learned in S1), you'd ask "Is this item available?" and get an immediate yes/no. But what about the actual cooking? You place an order and wait—the waiter gives you updates ("appetizers are ready", "main course is being plated"), and you can cancel if you need to leave early.

This is exactly what robot tasks need. Navigation takes seconds to minutes. Trajectory execution takes time. Object searching requires scanning multiple locations. These aren't instant queries—they're **long-running tasks** that need:
- **Progress feedback**: "50% complete, 30 seconds remaining"
- **Cancellation**: Stop mid-execution if conditions change
- **Final results**: Success/failure with metrics

**ROS 2 Actions** provide all three, combining the best of topics (streaming updates) and services (goal-oriented results).

:::tip Why This Matters
Every major robotics framework uses actions for long-running tasks. Nav2's navigation is an action. MoveIt2's trajectory execution is an action. When Boston Dynamics' Spot walks somewhere, it's executing an action with real-time feedback. Understanding actions is essential for building robots that do real work.
:::

---

## What Are ROS 2 Actions?

### Definition

A **ROS 2 action** is a communication mechanism for long-running tasks that provides three capabilities: sending a **goal**, receiving **feedback** during execution, and getting a **result** when complete. Unlike services, actions are non-blocking and support cancellation.

Think of actions as "supervised tasks"—you give instructions, get progress reports, and can call off the operation if needed.

### Why Do We Need Actions?

**Without Actions (Services Only):**
- Client blocks for entire task duration (10 seconds = frozen for 10 seconds)
- No way to know progress during execution
- Cannot cancel mid-task
- UI becomes unresponsive during long operations

**With Actions:**
- Client continues running while task executes
- Real-time progress feedback (10 Hz updates)
- Cancel anytime with clean shutdown
- Responsive UI with progress bars and cancel buttons

### Actions vs Services vs Topics

| Dimension | Topic | Service | Action |
|-----------|-------|---------|--------|
| **Duration** | Continuous | &lt;100ms | &gt;100ms (seconds/minutes) |
| **Feedback** | N/A (stream) | None | Progress updates |
| **Cancellation** | N/A | No | Yes (preemptable) |
| **Result** | No final result | Single response | Final outcome |
| **Blocking** | No | Yes | No |
| **Example** | `/camera/image` | `/compute_ik` | `/navigate_to_pose` |

```
┌─────────────────────────────────────────────────────────────┐
│                ACTION vs SERVICE vs TOPIC                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  TOPIC: Continuous stream                                   │
│  ┌────────┐  ─ msg ─ msg ─ msg ─▶  ┌────────┐              │
│  │ Camera │                        │Detector│              │
│  └────────┘                        └────────┘              │
│                                                             │
│  SERVICE: Quick query                                       │
│  ┌────────┐  ─── request ───▶  ┌────────┐                  │
│  │Planner │  ◀── response ───  │   IK   │  (blocks ~10ms)  │
│  └────────┘                    └────────┘                  │
│                                                             │
│  ACTION: Long task with feedback                            │
│  ┌────────┐  ═══ goal ════════▶  ┌────────┐               │
│  │  Nav   │  ◀── feedback ────   │ Nav2   │  (5+ seconds)  │
│  │ Client │  ◀── feedback ────   │Server  │               │
│  │        │  ◀═══ result ═════   │        │               │
│  └────────┘                      └────────┘               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Action Architecture

### The Three Components

```
┌─────────────────────────────────────────────────────────────┐
│                    ACTION COMPONENTS                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                    .action FILE                      │   │
│  ├─────────────────────────────────────────────────────┤   │
│  │  # GOAL (what to achieve)                           │   │
│  │  geometry_msgs/PoseArray waypoints                  │   │
│  │  float64 speed_scale                                │   │
│  │  ---                                                │   │
│  │  # RESULT (final outcome)                           │   │
│  │  bool success                                       │   │
│  │  float64 execution_time                             │   │
│  │  ---                                                │   │
│  │  # FEEDBACK (progress updates)                      │   │
│  │  float64 percent_complete                           │   │
│  │  float64 estimated_time_remaining                   │   │
│  └─────────────────────────────────────────────────────┘   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Client-Server Interaction

```
┌─────────────────────────────────────────────────────────────┐
│                ACTION CLIENT-SERVER FLOW                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Action Client                      Action Server           │
│  ┌─────────────┐                    ┌─────────────┐        │
│  │             │ ══ 1. Goal ══════▶ │             │        │
│  │             │                    │ 2. Validate │        │
│  │             │ ◀─ 3. Accepted ─── │             │        │
│  │             │                    │             │        │
│  │             │ ◀─ 4. Feedback ─── │ 5. Execute  │        │
│  │             │ ◀─ 4. Feedback ─── │    ...      │        │
│  │             │ ◀─ 4. Feedback ─── │    ...      │        │
│  │             │                    │             │        │
│  │ [Cancel?] ──┼─── 6. Cancel ────▶ │ 7. Stop     │        │
│  │             │                    │             │        │
│  │             │ ◀═ 8. Result ════  │ 9. Done     │        │
│  └─────────────┘                    └─────────────┘        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Implementation

### Step 1: Define Custom Action

**File**: `~/ros2_ws/src/humanoid_control/action/ExecuteTrajectory.action`

```
# ExecuteTrajectory.action - Arm Trajectory Execution

# Goal: Sequence of waypoints to execute
geometry_msgs/PoseArray waypoints
float64 speed_scale  # 0.1 to 1.0 (slow to fast)

---

# Result: Final outcome
bool success
string message
float64 final_position_error  # meters
float64 execution_time        # seconds

---

# Feedback: Progress updates (published at 10 Hz)
uint32 current_waypoint_index
float64 percent_complete
float64 estimated_time_remaining  # seconds
geometry_msgs/Pose current_pose
```

**Update CMakeLists.txt**:
```cmake
find_package(rosidl_default_generators REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(action_msgs REQUIRED)

rosidl_generate_interfaces(${PROJECT_NAME}
  "action/ExecuteTrajectory.action"
  DEPENDENCIES geometry_msgs action_msgs
)
```

### Step 2: Implement Action Server

**File**: `~/ros2_ws/src/humanoid_control/scripts/trajectory_action_server.py`

```python
#!/usr/bin/env python3
"""
Trajectory Execution Action Server
Executes arm trajectories with progress feedback and cancellation
"""

import rclpy
from rclpy.action import ActionServer, CancelResponse, GoalResponse
from rclpy.node import Node
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.executors import MultiThreadedExecutor
from humanoid_control.action import ExecuteTrajectory
import asyncio
import time

class TrajectoryActionServer(Node):
    def __init__(self):
        super().__init__('trajectory_action_server')

        # Use reentrant callback group for cancellation support
        self._action_server = ActionServer(
            self,
            ExecuteTrajectory,
            'execute_trajectory',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback,
            callback_group=ReentrantCallbackGroup()
        )

        self.get_logger().info('Trajectory Action Server started')

    def goal_callback(self, goal_request):
        """Accept or reject incoming goals"""
        num_waypoints = len(goal_request.waypoints.poses)
        speed_scale = goal_request.speed_scale

        if num_waypoints == 0:
            self.get_logger().warn('Rejected: empty waypoint list')
            return GoalResponse.REJECT

        if not (0.1 <= speed_scale <= 1.0):
            self.get_logger().warn(f'Rejected: invalid speed {speed_scale}')
            return GoalResponse.REJECT

        self.get_logger().info(f'Accepted: {num_waypoints} waypoints')
        return GoalResponse.ACCEPT

    def cancel_callback(self, goal_handle):
        """Accept cancellation requests"""
        self.get_logger().info('Cancellation requested')
        return CancelResponse.ACCEPT

    async def execute_callback(self, goal_handle):
        """Execute trajectory with feedback and cancellation"""
        self.get_logger().info('Executing trajectory...')

        waypoints = goal_handle.request.waypoints.poses
        speed_scale = goal_handle.request.speed_scale
        num_waypoints = len(waypoints)

        feedback_msg = ExecuteTrajectory.Feedback()
        start_time = time.time()
        time_per_waypoint = 0.5 / speed_scale

        for i, waypoint in enumerate(waypoints):
            # Check for cancellation
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                result = ExecuteTrajectory.Result()
                result.success = False
                result.message = f'Canceled at waypoint {i}'
                result.execution_time = time.time() - start_time
                return result

            # Simulate waypoint execution
            self.get_logger().info(f'Waypoint {i+1}/{num_waypoints}')
            await asyncio.sleep(time_per_waypoint)

            # Publish feedback
            feedback_msg.current_waypoint_index = i + 1
            feedback_msg.percent_complete = ((i + 1) / num_waypoints) * 100
            feedback_msg.estimated_time_remaining = (num_waypoints - i - 1) * time_per_waypoint
            feedback_msg.current_pose = waypoint
            goal_handle.publish_feedback(feedback_msg)

        # Success
        goal_handle.succeed()
        result = ExecuteTrajectory.Result()
        result.success = True
        result.message = f'Executed {num_waypoints} waypoints'
        result.final_position_error = 0.002
        result.execution_time = time.time() - start_time
        return result


def main(args=None):
    rclpy.init(args=args)
    node = TrajectoryActionServer()

    # MultiThreadedExecutor required for cancellation
    executor = MultiThreadedExecutor()
    executor.add_node(node)

    try:
        executor.spin()
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

:::warning Common Mistake
Using `rclpy.spin(node)` instead of `MultiThreadedExecutor` will prevent cancellation from working. The single-threaded executor cannot process cancel requests while execute_callback is running.
:::

### Step 3: Implement Action Client

**File**: `~/ros2_ws/src/humanoid_control/scripts/trajectory_action_client.py`

```python
#!/usr/bin/env python3
"""
Trajectory Execution Action Client
Sends goals, monitors feedback, handles cancellation
"""

import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from humanoid_control.action import ExecuteTrajectory
from geometry_msgs.msg import Pose, PoseArray
import math
import sys

class TrajectoryActionClient(Node):
    def __init__(self):
        super().__init__('trajectory_action_client')
        self._action_client = ActionClient(
            self, ExecuteTrajectory, 'execute_trajectory'
        )
        self._goal_handle = None

    def send_goal(self, num_waypoints=5, speed_scale=1.0):
        """Send trajectory goal"""
        self._action_client.wait_for_server()

        # Generate circular trajectory
        goal_msg = ExecuteTrajectory.Goal()
        waypoints = []
        for i in range(num_waypoints):
            angle = (i / num_waypoints) * 2 * math.pi
            pose = Pose()
            pose.position.x = 0.5 + 0.1 * math.cos(angle)
            pose.position.y = 0.2 + 0.1 * math.sin(angle)
            pose.position.z = 1.2
            pose.orientation.w = 1.0
            waypoints.append(pose)

        goal_msg.waypoints = PoseArray(poses=waypoints)
        goal_msg.speed_scale = speed_scale

        self.get_logger().info(f'Sending {num_waypoints} waypoints')

        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg, feedback_callback=self.feedback_callback
        )
        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        """Handle goal acceptance"""
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().error('Goal rejected')
            return

        self._goal_handle = goal_handle
        self.get_logger().info('Goal accepted')

        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.result_callback)

    def feedback_callback(self, feedback_msg):
        """Handle progress feedback"""
        fb = feedback_msg.feedback
        self.get_logger().info(
            f'Progress: {fb.percent_complete:.0f}%, '
            f'{fb.estimated_time_remaining:.1f}s remaining'
        )

    def result_callback(self, future):
        """Handle final result"""
        result = future.result().result
        if result.success:
            self.get_logger().info(f'SUCCESS: {result.message}')
            self.get_logger().info(f'Time: {result.execution_time:.2f}s')
        else:
            self.get_logger().warn(f'FAILED: {result.message}')
        rclpy.shutdown()

    def cancel_goal(self):
        """Cancel current goal"""
        if self._goal_handle:
            self._goal_handle.cancel_goal_async()


def main(args=None):
    rclpy.init(args=args)

    num_waypoints = int(sys.argv[1]) if len(sys.argv) > 1 else 5
    speed_scale = float(sys.argv[2]) if len(sys.argv) > 2 else 1.0

    client = TrajectoryActionClient()
    client.send_goal(num_waypoints, speed_scale)
    rclpy.spin(client)

if __name__ == '__main__':
    main()
```

### Step 4: Build and Test

```bash
cd ~/ros2_ws
colcon build --packages-select humanoid_control
source install/setup.bash
```

**Terminal 1** (Server):
```bash
ros2 run humanoid_control trajectory_action_server
```

**Terminal 2** (Client):
```bash
ros2 run humanoid_control trajectory_action_client 5 1.0
```

**Expected Output**:
```
[INFO]: Sending 5 waypoints
[INFO]: Goal accepted
[INFO]: Progress: 20%, 2.0s remaining
[INFO]: Progress: 40%, 1.5s remaining
[INFO]: Progress: 60%, 1.0s remaining
[INFO]: Progress: 80%, 0.5s remaining
[INFO]: Progress: 100%, 0.0s remaining
[INFO]: SUCCESS: Executed 5 waypoints
[INFO]: Time: 2.51s
```

---

## Action CLI Commands

| Command | Purpose |
|---------|---------|
| `ros2 action list` | List all available actions |
| `ros2 action type <action>` | Show the action type |
| `ros2 action info <action>` | Show action server/client info |
| `ros2 action send_goal <action> <type> <goal>` | Send a goal |
| `ros2 action send_goal --feedback <action> <type> <goal>` | Send goal with feedback display |

---

## Action Lifecycle States

```
┌─────────────────────────────────────────────────────────────┐
│                    ACTION LIFECYCLE                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌──────┐                                                  │
│   │ IDLE │ ◀─────────────────────────────────────┐         │
│   └──┬───┘                                        │         │
│      │ send_goal()                               │         │
│      ▼                                            │         │
│   ┌──────────┐                                   │         │
│   │ ACCEPTED │                                   │         │
│   └────┬─────┘                                   │         │
│        │ start execution                         │         │
│        ▼                                         │         │
│   ┌───────────┐                                  │         │
│   │ EXECUTING │──────┬───────────┬──────────────┤         │
│   └───────────┘      │           │              │         │
│        │             │           │              │         │
│   succeed()     canceled()   abort()            │         │
│        │             │           │              │         │
│        ▼             ▼           ▼              │         │
│   ┌─────────┐  ┌──────────┐  ┌─────────┐       │         │
│   │SUCCEEDED│  │ CANCELED │  │ ABORTED │───────┘         │
│   └─────────┘  └──────────┘  └─────────┘                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Connection to Capstone

Actions power all long-running capstone operations:

| Capstone Component | Action Usage |
|-------------------|--------------|
| **Voice Command** | Streaming transcription with partial results |
| **Planning** | LLM task decomposition with progress |
| **Navigation** | Nav2 `/navigate_to_pose` with distance feedback |
| **Vision** | Object search with regions-scanned feedback |
| **Manipulation** | Trajectory execution (what we built!) |

```
┌─────────────────────────────────────────────────────────────┐
│                    CAPSTONE PIPELINE                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Voice ──▶ Plan ──▶ Navigate ──▶ Vision ──▶ Manipulate     │
│              │          │           │           │           │
│           action     action      action      action         │
│          /decompose /navigate  /search    /execute         │
│          _task      _to_pose   _object    _trajectory      │
│                                                             │
│         ┌─────────────────────────────────────┐             │
│         │            ACTIONS                  │             │
│         │                                     │             │
│         │  [THIS SECTION]: Long-running       │             │
│         │  tasks with feedback & cancel       │             │
│         └─────────────────────────────────────┘             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Summary

In this section, you learned:
- **Actions** handle long-running tasks (>100ms)
- **Goals** define what to achieve
- **Feedback** provides real-time progress updates
- **Results** report final success/failure with metrics
- **Cancellation** allows stopping mid-execution

**Key Commands to Remember:**
```bash
# List actions
ros2 action list

# Show action type
ros2 action type /execute_trajectory

# Send goal with feedback
ros2 action send_goal --feedback /action_name action_type "{goal}"

# Show action interface
ros2 interface show humanoid_control/action/ExecuteTrajectory
```

---

## Practice Exercises

### Exercise 1: Basic - Action Introspection
**Objective:** Explore actions using CLI tools
**Time:** ~10 minutes

1. Start the turtlesim node: `ros2 run turtlesim turtlesim_node`
2. List all actions: `ros2 action list`
3. Find the rotate action type: `ros2 action type /turtle1/rotate_absolute`
4. Send a goal to rotate the turtle 90 degrees with feedback display

**Expected Result:** Turtle rotates with feedback showing remaining angle

<details>
<summary>Hint</summary>
Use: `ros2 action send_goal --feedback /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: 1.57}"`
</details>

---

### Exercise 2: Intermediate - Implement Cancellation Test
**Objective:** Verify cancellation works correctly
**Time:** ~20 minutes

1. Modify the client to send a 20-waypoint, slow trajectory (speed 0.2)
2. After 3 seconds, call `cancel_goal()` using a timer
3. Verify the server reports cancellation and partial progress

**Success Criteria:**
- [ ] Server logs "Canceled at waypoint X"
- [ ] Client receives partial result
- [ ] No errors or crashes

---

### Exercise 3: Challenge - Add Pause/Resume
**Objective:** Extend the action with pause functionality
**Time:** ~30+ minutes

Modify the action to support pause/resume:
1. Add a `/pause_trajectory` service that pauses execution
2. Add a `/resume_trajectory` service that continues
3. Feedback should indicate "PAUSED" state
4. Test by pausing mid-execution and resuming

**Bonus:** Add a maximum pause duration after which execution auto-resumes.

---

## Troubleshooting

| Problem | Cause | Solution |
|---------|-------|----------|
| Action not found | Server not running | Start server, check with `ros2 action list` |
| Cancel doesn't work | Wrong executor | Use `MultiThreadedExecutor` |
| No feedback received | Callback not registered | Pass `feedback_callback` to `send_goal_async` |
| Goal rejected | Validation failed | Check server logs for rejection reason |
| Import error | Interface not built | Run `colcon build` and source workspace |

---

## What's Next?

In the next section, **M1-C2-S3: ROS 2 Parameters**, you will learn:
- Dynamic configuration without code changes
- Parameter servers and clients
- Parameter callbacks for runtime updates
- YAML parameter files for configuration

This will enable you to tune robot behavior without recompiling!

---

## Further Reading

- [ROS 2 Actions Tutorial](https://docs.ros.org/en/kilted/Tutorials/Intermediate/Writing-an-Action-Server-Client/Py.html)
- [Action Design Pattern](https://design.ros2.org/articles/actions.html)
- [Nav2 Actions](https://docs.nav2.org/configuration/packages/bt_action_server.html)
- [MoveIt2 Actions](https://moveit.picknik.ai/main/doc/concepts/move_group.html)

:::info Industry Insight
Nav2, the standard ROS 2 navigation stack used in thousands of robots worldwide, is built entirely on actions. The `/navigate_to_pose` action provides real-time distance-to-goal feedback at 10 Hz, supports preemption for dynamic replanning, and handles cancellation gracefully. Amazon's warehouse robots, Clearpath's autonomous vehicles, and countless research robots all rely on Nav2's action-based architecture for reliable navigation.
:::
