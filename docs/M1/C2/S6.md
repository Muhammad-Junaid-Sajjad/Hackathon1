---
id: m1-c2-s6
title: Quality of Service (QoS) Policies and Message Delivery
sidebar_position: 6
keywords: ['qos', 'reliability', 'durability', 'liveliness', 'best-effort', 'reliable']
---

# Quality of Service (QoS) Policies and Message Delivery

## Prerequisites

| Requirement | Description |
|-------------|-------------|
| **M1-C1-S5** | Understanding of ROS 2 topics, publishers, and subscribers |
| **M1-C2-S1** | Familiarity with Python ROS 2 nodes |
| **Networking** | Basic understanding of UDP vs TCP tradeoffs |

## Learning Objectives

By the end of this section, you will be able to:

1. **Select appropriate QoS policies** for different sensor/actuator types
2. **Configure reliability** (best-effort vs. reliable) for latency vs. guarantee tradeoffs
3. **Use durability** (volatile vs. transient-local) for late-joiner scenarios
4. **Diagnose QoS mismatches** that cause silent communication failures
5. **Implement QoS event callbacks** to detect deadline violations

## Key Concepts

| Policy | Options | When to Use |
|--------|---------|-------------|
| **Reliability** | `RELIABLE` / `BEST_EFFORT` | Commands vs. sensor streams |
| **Durability** | `VOLATILE` / `TRANSIENT_LOCAL` | Real-time vs. late-joiner state |
| **History** | `KEEP_LAST(N)` / `KEEP_ALL` | Queue depth management |
| **Deadline** | Duration | Detect slow publishers |
| **Lifespan** | Duration | Discard stale messages |

```
┌─────────────────────────────────────────────────────────────────┐
│                    QoS Compatibility Matrix                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   Publisher QoS        Subscriber QoS        Compatible?        │
│   ──────────────       ──────────────        ──────────         │
│                                                                  │
│   RELIABLE      ───►   RELIABLE              ✅ Yes             │
│   RELIABLE      ───►   BEST_EFFORT           ✅ Yes             │
│   BEST_EFFORT   ───►   RELIABLE              ❌ No (mismatch)   │
│   BEST_EFFORT   ───►   BEST_EFFORT           ✅ Yes             │
│                                                                  │
│   TRANSIENT     ───►   TRANSIENT_LOCAL       ✅ Yes             │
│   TRANSIENT     ───►   VOLATILE              ✅ Yes (no history)│
│   VOLATILE      ───►   TRANSIENT_LOCAL       ❌ No (mismatch)   │
│   VOLATILE      ───►   VOLATILE              ✅ Yes             │
│                                                                  │
│   Rule: Subscriber can request ≤ what Publisher offers          │
│         (can downgrade, cannot upgrade)                          │
│                                                                  │
│   Diagnosis Command:                                             │
│   ros2 topic info /topic_name --verbose                         │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## Overview

ROS 2 **Quality of Service (QoS)** policies configure message delivery guarantees for topics—controlling reliability (best-effort vs. reliable), durability (transient-local vs. volatile), history (keep-last vs. keep-all), and liveliness. QoS policies are critical for wireless networks, sensor fusion with late-joiners, and safety-critical systems where message loss is unacceptable.

**What You'll Build**: A multi-sensor fusion node demonstrating QoS policy selection for IMU (reliable), camera (best-effort), and recovery state (transient-local) topics, with QoS compatibility testing.

## Hardware Requirements

**Workstation** (from M1-C1-S1)
- ROS 2 Kilted Kaiju installed (M1-C1-S4)
- Python 3.10+

## Connection to Capstone

The capstone requires QoS tuning for:

1. **IMU Data**: `RELIABLE` + `VOLATILE` (no message loss, high frequency)
2. **Camera Streams**: `BEST_EFFORT` + `VOLATILE` (tolerate drops, minimize latency)
3. **Joint Commands**: `RELIABLE` + `KEEP_LAST(1)` (latest command only, no loss)
4. **System State**: `RELIABLE` + `TRANSIENT_LOCAL` (late-joining nodes get last state)
5. **Nav2 Path**: `RELIABLE` + `TRANSIENT_LOCAL` (recovery nodes need last planned path)

**Why QoS Matters**: Default QoS (reliable + volatile) causes 200ms+ latency spikes on WiFi for 640x480@30fps camera streams. Switching to `BEST_EFFORT` reduces latency to 50ms or less with occasional frame drops (acceptable for perception).

## Implementation

### QoS Policies Overview

| Policy | Options | Use Case |
|--------|---------|----------|
| **Reliability** | `BEST_EFFORT`, `RELIABLE` | Sensor streams vs. commands |
| **Durability** | `VOLATILE`, `TRANSIENT_LOCAL` | Real-time vs. late-joiner state |
| **History** | `KEEP_LAST(N)`, `KEEP_ALL` | Queue depth |
| **Liveliness** | `AUTOMATIC`, `MANUAL_BY_TOPIC` | Heartbeat detection |
| **Deadline** | Duration | Max time between messages |
| **Lifespan** | Duration | Max message age |

### QoS Presets

ROS 2 provides standard QoS profiles:

| Profile | Reliability | Durability | History | Use Case |
|---------|-------------|------------|---------|----------|
| **Sensor Data** | Best-Effort | Volatile | Keep-Last(5) | Camera, lidar, high-rate sensors |
| **Services** | Reliable | Volatile | Keep-Last(10) | Request/response |
| **Parameters** | Reliable | Volatile | Keep-Last(1000) | Config updates |
| **System Default** | Reliable | Volatile | Keep-Last(10) | General pub/sub |
| **Transient Local** | Reliable | Transient-Local | Keep-Last(1) | State for late-joiners |

### Step 1: QoS Policy Selection

**File**: `~/ros2_ws/src/humanoid_control/scripts/sensor_fusion.py`

```python
#!/usr/bin/env python3
"""
Sensor Fusion with QoS Policies
Demonstrates different QoS configurations for sensor streams
"""

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSDurabilityPolicy, QoSHistoryPolicy
from sensor_msgs.msg import Image, Imu
from geometry_msgs.msg import Twist

class SensorFusion(Node):
    def __init__(self):
        super().__init__('sensor_fusion')

        # QoS Profile 1: IMU (Reliable, no message loss)
        imu_qos = QoSProfile(
            reliability=QoSReliabilityPolicy.RELIABLE,
            durability=QoSDurabilityPolicy.VOLATILE,
            history=QoSHistoryPolicy.KEEP_LAST,
            depth=10
        )

        # QoS Profile 2: Camera (Best-Effort, low latency)
        camera_qos = QoSProfile(
            reliability=QoSReliabilityPolicy.BEST_EFFORT,
            durability=QoSDurabilityPolicy.VOLATILE,
            history=QoSHistoryPolicy.KEEP_LAST,
            depth=5  # Small queue for low latency
        )

        # QoS Profile 3: Commands (Reliable, latest only)
        cmd_qos = QoSProfile(
            reliability=QoSReliabilityPolicy.RELIABLE,
            durability=QoSDurabilityPolicy.VOLATILE,
            history=QoSHistoryPolicy.KEEP_LAST,
            depth=1  # Only latest command matters
        )

        # Subscribers with QoS
        self.imu_sub = self.create_subscription(
            Imu,
            '/imu/data',
            self.imu_callback,
            imu_qos  # Reliable
        )

        self.camera_sub = self.create_subscription(
            Image,
            '/camera/image_raw',
            self.camera_callback,
            camera_qos  # Best-Effort
        )

        # Publisher with QoS
        self.cmd_pub = self.create_publisher(
            Twist,
            '/cmd_vel',
            cmd_qos  # Reliable, latest only
        )

        self.imu_count = 0
        self.camera_count = 0

        self.get_logger().info('Sensor Fusion started with QoS policies')

    def imu_callback(self, msg):
        """Handle IMU messages (should never drop)"""
        self.imu_count += 1
        if self.imu_count % 100 == 0:
            self.get_logger().info(f'IMU messages received: {self.imu_count} (RELIABLE)')

    def camera_callback(self, msg):
        """Handle camera messages (may drop frames)"""
        self.camera_count += 1
        if self.camera_count % 30 == 0:
            self.get_logger().info(f'Camera frames received: {self.camera_count} (BEST_EFFORT)')


def main(args=None):
    rclpy.init(args=args)
    node = SensorFusion()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Step 2: Transient Local for Late Joiners

**Use Case**: Navigation recovery node needs last planned path even if it starts after path planning.

**File**: `~/ros2_ws/src/humanoid_control/scripts/state_publisher.py`

```python
#!/usr/bin/env python3
"""
State Publisher with Transient Local QoS
Late-joining subscribers receive last published message
"""

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSDurabilityPolicy, QoSHistoryPolicy
from std_msgs.msg import String
import time

class StatePublisher(Node):
    def __init__(self):
        super().__init__('state_publisher')

        # Transient Local QoS (late-joiners get last message)
        transient_qos = QoSProfile(
            reliability=QoSReliabilityPolicy.RELIABLE,
            durability=QoSDurabilityPolicy.TRANSIENT_LOCAL,  # Key difference
            history=QoSHistoryPolicy.KEEP_LAST,
            depth=1
        )

        self.publisher = self.create_publisher(
            String,
            '/robot_state',
            transient_qos
        )

        # Publish state every 5 seconds
        self.timer = self.create_timer(5.0, self.publish_state)
        self.state_count = 0

        self.get_logger().info('State Publisher started (Transient Local QoS)')

    def publish_state(self):
        """Publish robot state"""
        self.state_count += 1
        msg = String()
        msg.data = f'State #{self.state_count}: READY (timestamp: {time.time():.2f})'

        self.publisher.publish(msg)
        self.get_logger().info(f'Published: {msg.data}')


def main(args=None):
    rclpy.init(args=args)
    node = StatePublisher()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

**Late-Joiner Subscriber**:
```python
#!/usr/bin/env python3
"""
Late-Joiner Subscriber
Receives last message even if started after publisher
"""

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSDurabilityPolicy, QoSHistoryPolicy
from std_msgs.msg import String

class LateJoinerSubscriber(Node):
    def __init__(self):
        super().__init__('late_joiner_subscriber')

        # Must match publisher QoS
        transient_qos = QoSProfile(
            reliability=QoSReliabilityPolicy.RELIABLE,
            durability=QoSDurabilityPolicy.TRANSIENT_LOCAL,
            history=QoSHistoryPolicy.KEEP_LAST,
            depth=1
        )

        self.subscription = self.create_subscription(
            String,
            '/robot_state',
            self.state_callback,
            transient_qos
        )

        self.get_logger().info('Late-Joiner Subscriber started (will receive last state)')

    def state_callback(self, msg):
        self.get_logger().info(f'Received state: {msg.data}')


def main(args=None):
    rclpy.init(args=args)
    node = LateJoinerSubscriber()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

**Test Late-Joiner**:
```bash
# Terminal 1: Start state publisher
ros2 run humanoid_control state_publisher.py

# Wait 10 seconds (2 state messages published)

# Terminal 2: Start late-joiner (receives last message immediately)
ros2 run humanoid_control late_joiner_subscriber.py
# Output: Received state: State #2: READY (timestamp: ...)
```

### Step 3: QoS Compatibility Testing

**Incompatible QoS Policies**:

| Publisher | Subscriber | Compatible? | Reason |
|-----------|------------|-------------|--------|
| Reliable | Reliable | ✅ Yes | Exact match |
| Reliable | Best-Effort | ✅ Yes | Subscriber accepts lower reliability |
| Best-Effort | Reliable | ❌ No | Subscriber requires higher reliability than offered |
| Transient-Local | Volatile | ❌ No | Subscriber won't receive historical messages |
| Volatile | Transient-Local | ✅ Yes | Subscriber accepts no history |

**Check QoS Compatibility**:
```bash
# Terminal 1: Publisher with RELIABLE
ros2 topic pub /test std_msgs/msg/String "{data: 'hello'}" \
  --qos-reliability reliable

# Terminal 2: Subscriber with BEST_EFFORT (works)
ros2 topic echo /test --qos-reliability best-effort

# Terminal 3: Subscriber with RELIABLE (fails if publisher is BEST_EFFORT)
ros2 topic echo /test --qos-reliability reliable
```

**Diagnose QoS Mismatch**:
```bash
ros2 topic info /test --verbose
```

**Output**:
```
Topic: /test
Publisher count: 1
  Node name: _ros2cli_12345
  QoS profile:
    Reliability: RELIABLE
    Durability: VOLATILE
    History: KEEP_LAST
    Depth: 10

Subscription count: 2
  Node name: _ros2cli_67890
  QoS profile:
    Reliability: BEST_EFFORT  # Compatible
    Durability: VOLATILE
    History: KEEP_LAST
    Depth: 10

  Node name: _ros2cli_11111
  QoS profile:
    Reliability: RELIABLE  # Incompatible (if pub is BEST_EFFORT)
    Durability: TRANSIENT_LOCAL
    History: KEEP_LAST
    Depth: 1
```

### Step 4: QoS Presets in Code

**Using Standard Profiles**:
```python
from rclpy.qos import qos_profile_sensor_data, qos_profile_system_default, \
                      qos_profile_parameters, qos_profile_services_default

# Sensor data (Best-Effort, low latency)
self.camera_sub = self.create_subscription(
    Image,
    '/camera/image',
    self.callback,
    qos_profile_sensor_data
)

# System default (Reliable)
self.cmd_pub = self.create_publisher(
    Twist,
    '/cmd_vel',
    qos_profile_system_default
)

# Custom profile based on preset
from rclpy.qos import QoSProfile
custom_qos = QoSProfile(**qos_profile_sensor_data.get_c_qos_profile())
custom_qos.depth = 3  # Override depth
```

### Step 5: Deadline and Lifespan Policies

**Deadline** (detect slow publishers):
```python
from rclpy.qos import QoSProfile, Duration

# Require messages every 100ms
qos = QoSProfile(depth=10)
qos.deadline = Duration(seconds=0, nanoseconds=100_000_000)

self.subscription = self.create_subscription(
    Imu,
    '/imu/data',
    self.callback,
    qos
)

# If messages arrive slower than 100ms, QoS event is triggered
```

**Lifespan** (discard old messages):
```python
# Discard messages older than 500ms
qos = QoSProfile(depth=10)
qos.lifespan = Duration(seconds=0, nanoseconds=500_000_000)

self.subscription = self.create_subscription(
    Image,
    '/camera/image',
    self.callback,
    qos
)
```

### Step 6: QoS Event Callbacks

**Detect QoS Violations**:
```python
from rclpy.qos import QoSProfile
from rclpy.event_handler import SubscriptionEventCallbacks
from rclpy.qos_event import QoSDeadlineRequestedInfo

class QoSMonitor(Node):
    def __init__(self):
        super().__init__('qos_monitor')

        qos = QoSProfile(depth=10)
        qos.deadline = Duration(seconds=0, nanoseconds=100_000_000)

        # Define event callbacks
        event_callbacks = SubscriptionEventCallbacks(
            deadline=self.deadline_callback
        )

        self.subscription = self.create_subscription(
            Imu,
            '/imu/data',
            self.imu_callback,
            qos,
            event_callbacks=event_callbacks
        )

    def imu_callback(self, msg):
        pass  # Process IMU data

    def deadline_callback(self, event: QoSDeadlineRequestedInfo):
        """Called when deadline is missed"""
        self.get_logger().warn(f'Deadline missed! Total violations: {event.total_count}')
```

## QoS Policy Selection Guide

### Reliability

| Use Case | Policy | Reason |
|----------|--------|--------|
| Motor commands | `RELIABLE` | No loss tolerated |
| Camera stream | `BEST_EFFORT` | Frame drops acceptable, minimize latency |
| IMU data | `RELIABLE` | Critical for state estimation |
| Lidar scan | `BEST_EFFORT` | High rate, latest data most important |

### Durability

| Use Case | Policy | Reason |
|----------|--------|--------|
| Real-time sensor | `VOLATILE` | Only current data relevant |
| Robot state | `TRANSIENT_LOCAL` | Late-joiners need last known state |
| Map data | `TRANSIENT_LOCAL` | Recovery nodes need map |
| Video stream | `VOLATILE` | Old frames irrelevant |

### History

| Use Case | Policy | Depth |
|----------|--------|-------|
| High-rate sensors | `KEEP_LAST` | 1-5 (minimize latency) |
| Commands | `KEEP_LAST` | 1 (latest only) |
| Diagnostics | `KEEP_LAST` | 100 (buffer for analysis) |
| File transfer | `KEEP_ALL` | N/A (all messages) |

## Performance Impact

**Latency Comparison** (640x480 RGB @ 30 FPS over WiFi):

| QoS Configuration | Avg Latency | P99 Latency | Frame Drops |
|-------------------|-------------|-------------|-------------|
| Reliable + Volatile | 180ms | 450ms | 0% |
| Best-Effort + Volatile | 45ms | 95ms | 2-5% |

**Bandwidth Comparison** (100 Hz IMU stream):

| QoS Configuration | Bandwidth | CPU Usage |
|-------------------|-----------|-----------|
| Reliable + Keep-Last(10) | 120 KB/s | 3% |
| Reliable + Keep-All | 1.2 MB/s | 15% (queue growth) |
| Best-Effort + Keep-Last(1) | 80 KB/s | 2% |

## Next Steps

With QoS policies mastered, proceed to:
- **M1-C2-S7**: Rosbag Analysis (record and replay with QoS preservation)
- **M1-C3-S1**: URDF Basics (robot description for kinematics)
- **M3-C2-S2**: cuVSLAM Integration (QoS tuning for SLAM topics)

**Troubleshooting**:
- **No messages received**: Check QoS compatibility with `ros2 topic info --verbose`
- **High latency**: Switch camera streams to `BEST_EFFORT`
- **Messages not persisted**: Ensure `TRANSIENT_LOCAL` on both pub and sub
- **Deadline missed**: Increase deadline duration or fix slow publisher

**Real-World QoS Examples**:
- Nav2: `RELIABLE` + `TRANSIENT_LOCAL` for costmap, `BEST_EFFORT` for sensor_data
- RealSense: `BEST_EFFORT` for image streams, `RELIABLE` for camera_info
- cuVSLAM: `RELIABLE` for odometry, `BEST_EFFORT` for visual features

---

**Assessment Preparation**: This section is **IMPORTANT** for **Assessment 1: ROS 2 Fundamentals Quiz (Week 3)**. You must understand QoS policy selection and troubleshooting incompatible configurations.
