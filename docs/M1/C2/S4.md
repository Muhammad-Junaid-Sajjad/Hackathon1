---
id: m1-c2-s4
title: Custom Message Interfaces and Type Definitions
sidebar_position: 4
keywords: ['messages', 'interfaces', 'custom-types', 'msg', 'srv', 'action']
---

# Custom Message Interfaces and Type Definitions

## Prerequisites

| Requirement | Description |
|-------------|-------------|
| **M1-C1-S4** | ROS 2 Humble installed with colcon build tools |
| **M1-C1-S5** | Understanding of ROS 2 topics and publishers/subscribers |
| **M1-C2-S1** | Familiarity with services (for custom .srv files) |
| **M1-C2-S2** | Understanding of actions (for custom .action files) |
| **CMake** | Basic knowledge of CMakeLists.txt |

## Learning Objectives

By the end of this section, you will be able to:

1. **Define custom message types** (.msg) for domain-specific data
2. **Create service definitions** (.srv) with request/response structures
3. **Build action definitions** (.action) with goal/result/feedback
4. **Configure package build** with rosidl_generate_interfaces
5. **Use custom messages** in Python and C++ nodes
6. **Apply message design patterns** for real-world robotics

## Key Concepts

| Concept | File Extension | Purpose |
|---------|----------------|---------|
| **Message** | `.msg` | Unidirectional data (topics) |
| **Service** | `.srv` | Request/response pairs |
| **Action** | `.action` | Goal/result/feedback (long-running) |
| **rosidl** | (build tool) | Generates Python/C++ bindings |
| **Header** | `std_msgs/Header` | Timestamp + frame_id for all spatial messages |

```
┌─────────────────────────────────────────────────────────────────┐
│              Custom Interface Package Structure                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   humanoid_interfaces/                                          │
│   ├── msg/                         ← Message definitions        │
│   │   ├── GraspPose.msg                                         │
│   │   ├── GripperState.msg                                      │
│   │   ├── DetectedObject.msg                                    │
│   │   └── TaskStatus.msg                                        │
│   ├── srv/                         ← Service definitions        │
│   │   └── ValidateGrasp.srv                                     │
│   ├── action/                      ← Action definitions         │
│   │   └── ExecuteGrasp.action                                   │
│   ├── CMakeLists.txt               ← Build configuration        │
│   └── package.xml                  ← Dependencies               │
│                                                                  │
│   After colcon build:                                           │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │  install/humanoid_interfaces/                            │  │
│   │  └── lib/python3.10/site-packages/humanoid_interfaces/  │  │
│   │      └── msg/                  ← Python bindings         │  │
│   │          ├── _grasp_pose.py                              │  │
│   │          └── ...                                         │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## Overview

ROS 2 **custom messages** allow you to define domain-specific data structures beyond standard types (`sensor_msgs`, `geometry_msgs`). Custom messages are essential for humanoid robotics where you need application-specific types: joint controller commands, grasp stability metrics, task execution status. This section creates custom `.msg`, `.srv`, and `.action` definitions with code generation and usage patterns.

**What You'll Build**: A humanoid-specific message package with custom types for manipulation (grasp pose, gripper state), navigation (obstacle array), and system monitoring (health status).

## Hardware Requirements

**Workstation** (from M1-C1-S1)
- ROS 2 Humble installed (M1-C1-S4)
- Python 3.10+ / C++17

## Connection to Capstone

The capstone uses custom messages for:

1. **Manipulation**: `GraspPose.msg` (6D pose + approach vector + gripper width), `GripperState.msg` (force, position, is_grasping)
2. **Navigation**: `ObstacleArray.msg` (detected obstacles with positions, velocities, confidence), `NavStatus.msg` (path progress, ETA, recovery state)
3. **Perception**: `DetectedObject.msg` (bounding box, class, confidence, 3D centroid), `SceneUnderstanding.msg` (room classification, object relationships)
4. **Voice**: `VoiceCommand.msg` (transcript, intent, confidence, entities), `TaskStatus.msg` (execution state, progress, errors)

Custom messages provide **type safety**, **documentation**, and **language-agnostic** interfaces (Python, C++, Rust clients interoperate).

## Implementation

### Message Definition Syntax

**Basic `.msg` File**:
```
# Header with timestamp and frame
std_msgs/Header header

# Primitive types
int32 object_id
float64 confidence
string class_name
bool is_valid

# Arrays
float64[] bounding_box  # Variable-length
float64[4] corners      # Fixed-length

# Nested messages
geometry_msgs/Pose pose

# Constants
uint8 STATUS_IDLE=0
uint8 STATUS_ACTIVE=1
uint8 STATUS_ERROR=2
```

### Step 1: Create Custom Message Package

```bash
cd ~/ros2_ws/src
ros2 pkg create humanoid_interfaces --build-type ament_cmake --dependencies std_msgs geometry_msgs sensor_msgs

cd humanoid_interfaces
mkdir msg srv action
```

### Step 2: Define Custom Messages

**File**: `~/ros2_ws/src/humanoid_interfaces/msg/GraspPose.msg`

```
# GraspPose.msg - 6D grasp pose with gripper configuration

std_msgs/Header header

# Target pose for gripper TCP (tool center point)
geometry_msgs/Pose pose

# Approach vector (direction to approach object)
geometry_msgs/Vector3 approach_vector

# Gripper configuration
float64 gripper_width  # meters (0.0 = closed, 0.08 = fully open)
float64 gripper_force  # Newtons (max closing force)

# Grasp quality metrics
float64 stability_score  # 0.0-1.0 (grasp stability estimate)
uint8 grasp_type         # Grasp taxonomy

# Grasp type constants
uint8 GRASP_TYPE_POWER=0      # Power grasp (whole hand)
uint8 GRASP_TYPE_PRECISION=1  # Precision grasp (fingertip)
uint8 GRASP_TYPE_PINCH=2      # Pinch grasp (2-finger)
```

**File**: `~/ros2_ws/src/humanoid_interfaces/msg/GripperState.msg`

```
# GripperState.msg - Current gripper sensor feedback

std_msgs/Header header

# Position feedback
float64 position  # meters (current opening width)
float64 velocity  # m/s

# Force feedback
float64 force     # Newtons (current applied force)
float64 torque    # N⋅m (motor torque)

# State flags
bool is_moving
bool is_grasping  # Object detected between fingers
bool is_stalled   # Motor stall detected

# Object detection
float64 object_width  # meters (detected object width, 0.0 if none)
```

**File**: `~/ros2_ws/src/humanoid_interfaces/msg/DetectedObject.msg`

```
# DetectedObject.msg - Single detected object with 3D pose

std_msgs/Header header

# Classification
string class_name     # "red_block", "coffee_mug", etc.
float64 confidence    # 0.0-1.0 (detection confidence)
int32 track_id        # Unique ID for tracking across frames

# 2D bounding box (image coordinates)
uint32 bbox_x
uint32 bbox_y
uint32 bbox_width
uint32 bbox_height

# 3D pose (in camera frame)
geometry_msgs/Pose pose

# 3D bounding box dimensions (meters)
float64 size_x
float64 size_y
float64 size_z

# Segmentation mask (optional)
sensor_msgs/Image mask
```

**File**: `~/ros2_ws/src/humanoid_interfaces/msg/DetectedObjectArray.msg`

```
# DetectedObjectArray.msg - Collection of detected objects

std_msgs/Header header

# Array of detected objects
DetectedObject[] objects

# Scene metadata
uint32 total_objects
float64 processing_time  # seconds
```

**File**: `~/ros2_ws/src/humanoid_interfaces/msg/TaskStatus.msg`

```
# TaskStatus.msg - Voice-commanded task execution status

std_msgs/Header header

# Task identification
string task_id
string task_description  # "Pick up the red block"

# Execution state
uint8 state
uint8 STATE_PENDING=0
uint8 STATE_PLANNING=1
uint8 STATE_EXECUTING=2
uint8 STATE_SUCCEEDED=3
uint8 STATE_FAILED=4
uint8 STATE_CANCELED=5

# Progress metrics
float64 percent_complete  # 0.0-100.0
string current_phase      # "approaching", "grasping", "placing"
float64 estimated_time_remaining  # seconds

# Error handling
string error_message
uint8 error_code

# Error code constants
uint8 ERROR_NONE=0
uint8 ERROR_UNREACHABLE=1
uint8 ERROR_GRASP_FAILED=2
uint8 ERROR_COLLISION=3
uint8 ERROR_TIMEOUT=4
```

### Step 3: Update CMakeLists.txt

**File**: `~/ros2_ws/src/humanoid_interfaces/CMakeLists.txt`

```cmake
cmake_minimum_required(VERSION 3.8)
project(humanoid_interfaces)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# Find dependencies
find_package(ament_cmake REQUIRED)
find_package(rosidl_default_generators REQUIRED)
find_package(std_msgs REQUIRED)
find_package(geometry_msgs REQUIRED)
find_package(sensor_msgs REQUIRED)

# Generate interfaces
rosidl_generate_interfaces(${PROJECT_NAME}
  "msg/GraspPose.msg"
  "msg/GripperState.msg"
  "msg/DetectedObject.msg"
  "msg/DetectedObjectArray.msg"
  "msg/TaskStatus.msg"
  DEPENDENCIES std_msgs geometry_msgs sensor_msgs
)

ament_package()
```

### Step 4: Update package.xml

**File**: `~/ros2_ws/src/humanoid_interfaces/package.xml`

```xml
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>humanoid_interfaces</name>
  <version>0.1.0</version>
  <description>Custom message interfaces for humanoid robotics</description>
  <maintainer email="your_email@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>
  <buildtool_depend>rosidl_default_generators</buildtool_depend>

  <depend>std_msgs</depend>
  <depend>geometry_msgs</depend>
  <depend>sensor_msgs</depend>

  <exec_depend>rosidl_default_runtime</exec_depend>

  <member_of_group>rosidl_interface_packages</member_of_group>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
```

### Step 5: Build and Verify

```bash
cd ~/ros2_ws
colcon build --packages-select humanoid_interfaces
source install/setup.bash
```

**Verify Message Generation**:
```bash
ros2 interface list | grep humanoid_interfaces
```

**Output**:
```
humanoid_interfaces/msg/DetectedObject
humanoid_interfaces/msg/DetectedObjectArray
humanoid_interfaces/msg/GraspPose
humanoid_interfaces/msg/GripperState
humanoid_interfaces/msg/TaskStatus
```

**Show Message Definition**:
```bash
ros2 interface show humanoid_interfaces/msg/GraspPose
```

**Output**:
```
std_msgs/Header header
  builtin_interfaces/Time stamp
    int32 sec
    uint32 nanosec
  string frame_id
geometry_msgs/Pose pose
  geometry_msgs/Point position
    float64 x
    float64 y
    float64 z
  geometry_msgs/Quaternion orientation
    float64 x
    float64 y
    float64 z
    float64 w
geometry_msgs/Vector3 approach_vector
  float64 x
  float64 y
  float64 z
float64 gripper_width
float64 gripper_force
float64 stability_score
uint8 grasp_type
uint8 GRASP_TYPE_POWER=0
uint8 GRASP_TYPE_PRECISION=1
uint8 GRASP_TYPE_PINCH=2
```

### Step 6: Use Custom Messages in Python

**File**: `~/ros2_ws/src/humanoid_control/scripts/grasp_planner.py`

```python
#!/usr/bin/env python3
"""
Grasp Planner - Publishes grasp poses using custom messages
"""

import rclpy
from rclpy.node import Node
from humanoid_interfaces.msg import GraspPose, DetectedObject
from geometry_msgs.msg import Pose, Vector3
from std_msgs.msg import Header

class GraspPlanner(Node):
    def __init__(self):
        super().__init__('grasp_planner')

        # Subscribe to detected objects
        self.subscription = self.create_subscription(
            DetectedObject,
            '/detected_objects',
            self.object_callback,
            10
        )

        # Publish grasp poses
        self.publisher = self.create_publisher(
            GraspPose,
            '/grasp_poses',
            10
        )

        self.get_logger().info('Grasp Planner started')

    def object_callback(self, detected_object):
        """Compute grasp pose for detected object"""
        self.get_logger().info(f'Planning grasp for {detected_object.class_name}')

        # Create grasp pose message
        grasp_msg = GraspPose()

        # Header (copy from detected object)
        grasp_msg.header = detected_object.header

        # Target pose (offset above object for top-down grasp)
        grasp_msg.pose = detected_object.pose
        grasp_msg.pose.position.z += 0.1  # 10cm above object

        # Approach vector (top-down)
        grasp_msg.approach_vector = Vector3(x=0.0, y=0.0, z=-1.0)

        # Gripper configuration (based on object size)
        object_width = max(detected_object.size_x, detected_object.size_y)
        grasp_msg.gripper_width = object_width + 0.01  # 1cm margin
        grasp_msg.gripper_force = 20.0  # 20N max force

        # Grasp quality (simplified heuristic)
        grasp_msg.stability_score = detected_object.confidence
        grasp_msg.grasp_type = GraspPose.GRASP_TYPE_POWER

        # Publish grasp pose
        self.publisher.publish(grasp_msg)
        self.get_logger().info(f'Published grasp: width={grasp_msg.gripper_width:.3f}m, '
                              f'force={grasp_msg.gripper_force:.1f}N, '
                              f'stability={grasp_msg.stability_score:.2f}')


def main(args=None):
    rclpy.init(args=args)
    node = GraspPlanner()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

**Test Publisher**:
```bash
# Terminal 1: Run grasp planner
ros2 run humanoid_control grasp_planner.py

# Terminal 2: Publish test detected object
ros2 topic pub --once /detected_objects humanoid_interfaces/msg/DetectedObject \
  "{header: {frame_id: 'camera_link'}, class_name: 'red_block', confidence: 0.95, \
    pose: {position: {x: 0.5, y: 0.2, z: 0.8}}, size_x: 0.05, size_y: 0.05, size_z: 0.05}"

# Terminal 3: Echo grasp poses
ros2 topic echo /grasp_poses
```

### Step 7: Custom Services and Actions

**Service Definition**: `~/ros2_ws/src/humanoid_interfaces/srv/ValidateGrasp.srv`

```
# ValidateGrasp.srv - Check if grasp is feasible

# Request
GraspPose grasp_pose

---

# Response
bool is_valid
float64 stability_score
string failure_reason  # Empty if valid

# Failure reason constants
string REASON_UNREACHABLE="Target pose out of workspace"
string REASON_COLLISION="Collision detected in approach path"
string REASON_UNSTABLE="Grasp stability below threshold (0.3)"
string REASON_GRIPPER_LIMIT="Object too large/small for gripper"
```

**Action Definition**: `~/ros2_ws/src/humanoid_interfaces/action/ExecuteGrasp.action`

```
# ExecuteGrasp.action - Execute grasp with feedback

# Goal
GraspPose target_grasp

---

# Result
bool success
GripperState final_state
string message

---

# Feedback
string current_phase  # "approaching", "grasping", "lifting", "verifying"
float64 percent_complete
geometry_msgs/Pose current_pose
GripperState gripper_state
```

**Update CMakeLists.txt**:
```cmake
rosidl_generate_interfaces(${PROJECT_NAME}
  "msg/GraspPose.msg"
  "msg/GripperState.msg"
  "msg/DetectedObject.msg"
  "msg/DetectedObjectArray.msg"
  "msg/TaskStatus.msg"
  "srv/ValidateGrasp.srv"
  "action/ExecuteGrasp.action"
  DEPENDENCIES std_msgs geometry_msgs sensor_msgs action_msgs
)
```

## Message Design Best Practices

### 1. Always Include Headers

For messages with spatial/temporal context:

```
# Good: Header enables TF transforms and timestamps
std_msgs/Header header
geometry_msgs/Pose pose

# Bad: No frame or timestamp
float64 x
float64 y
float64 z
```

### 2. Use Constants for Enums

```
# Good: Self-documenting state machine
uint8 state
uint8 STATE_IDLE=0
uint8 STATE_ACTIVE=1
uint8 STATE_ERROR=2

# Bad: Magic numbers
uint8 state  # 0=idle, 1=active, 2=error (not in code!)
```

### 3. Provide Units in Comments

```
# Good: Clear units
float64 gripper_width  # meters
float64 force          # Newtons
float64 timeout        # seconds

# Bad: Ambiguous
float64 gripper_width
float64 force
float64 timeout
```

### 4. Group Related Fields

```
# Good: Logical grouping
geometry_msgs/Pose pose
geometry_msgs/Vector3 approach_vector

# Bad: Interleaved unrelated fields
float64 pose_x
string object_class
float64 pose_y
bool is_valid
float64 pose_z
```

### 5. Use Nested Messages

```
# Good: Reuse standard types
geometry_msgs/Pose pose

# Bad: Duplicate standard fields
float64 position_x
float64 position_y
float64 position_z
float64 orientation_x
float64 orientation_y
float64 orientation_z
float64 orientation_w
```

## Common Message Patterns

### Pattern 1: Stamped Types

Add headers to existing types:

```
# PoseStamped pattern (already in geometry_msgs)
std_msgs/Header header
geometry_msgs/Pose pose
```

### Pattern 2: Array Messages

Collect multiple instances:

```
# ObjectArray pattern
std_msgs/Header header
DetectedObject[] objects
uint32 count
```

### Pattern 3: Result with Diagnostics

Include success flag + details:

```
bool success
string message
float64 execution_time
```

## Next Steps

With custom messages mastered, proceed to:
- **M1-C2-S5**: Launch Files (orchestrate multi-node systems)
- **M1-C2-S6**: QoS Policies (configure message delivery guarantees)
- **M1-C2-S7**: Rosbag Analysis (record and analyze custom message data)

**Troubleshooting**:
- **Build fails**: Check dependencies in `package.xml` and `CMakeLists.txt`
- **Import error**: Rebuild and source: `colcon build --packages-select humanoid_interfaces && source install/setup.bash`
- **Type mismatch**: Verify message field names/types match definition
- **Constants not found**: Use `MessageType.CONSTANT_NAME` (e.g., `GraspPose.GRASP_TYPE_POWER`)

**Real-World Custom Message Examples**:
- MoveIt2: `moveit_msgs/RobotTrajectory`, `moveit_msgs/PlanningScene`
- Nav2: `nav2_msgs/BehaviorTree`, `nav2_msgs/Costmap`
- vision_msgs: `vision_msgs/Detection2DArray`, `vision_msgs/BoundingBox3D`

---

**Assessment Preparation**: This section is **ESSENTIAL** for **Assessment 1: ROS 2 Fundamentals Quiz (Week 3)**. You must demonstrate creating custom message types and using them in Python/C++ nodes.
