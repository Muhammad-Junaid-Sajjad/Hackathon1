---
id: m1-c2-s1
title: ROS 2 Services and Request-Response Patterns
sidebar_position: 1
keywords: ['services', 'request-response', 'synchronous', 'rpc', 'client-server', 'ik']
---

# ROS 2 Services and Request-Response Patterns

## Prerequisites

Before starting this section, you should have:
- Completed M1-C1 (ROS 2 Fundamentals)
- Understanding of ROS 2 nodes and topics (M1-C1-S5)
- Python class and callback patterns
- ROS 2 workspace configured at `~/ros2_ws`
- Familiarity with basic linear algebra (for IK example)

## Learning Objectives

By the end of this section, you will be able to:
- **Distinguish** between topics (pub/sub) and services (request/response)
- **Define** custom service interfaces using `.srv` files
- **Implement** a service server that processes requests and returns responses
- **Implement** a service client that sends requests and handles responses
- **Test** services using CLI tools (`ros2 service call`)

## Key Concepts

| Term | Definition |
|------|------------|
| **Service** | A synchronous communication pattern where a client sends a request and waits for a response |
| **Server** | A node that provides a service, processing requests and returning responses |
| **Client** | A node that calls a service, sending requests and receiving responses |
| **Request** | The input data sent to a service (defined in `.srv` file above `---`) |
| **Response** | The output data returned by a service (defined in `.srv` file below `---`) |
| **Blocking Call** | A function call that pauses execution until it receives a response |

---

## Introduction: When You Need an Answer

Imagine calling customer support. You dial the number, ask a question, and wait for an answer. You can't just hang up after asking—you need the response to proceed. This is **request/response** communication.

Topics (pub/sub) are like a radio broadcast—you publish messages and hope someone is listening. But what if you need a specific answer before continuing? "Can the robot reach this position?" "Is this path collision-free?" "What joint angles achieve this pose?"

**ROS 2 Services** provide exactly this: a way to ask questions and get answers. Unlike topics where publishers don't wait for subscribers, services **block until the server responds**. This makes them perfect for decision-making queries in robotics.

:::tip Why This Matters
In humanoid robotics, many operations require confirmation before proceeding. Tesla's Optimus can't just reach for an object—it first queries its IK solver to verify the pose is reachable. Boston Dynamics' Spot validates paths before executing. Services enable this "ask-then-act" pattern that's essential for safe robot operation.
:::

---

## What Are ROS 2 Services?

### Definition

A **ROS 2 service** is a synchronous request/response communication mechanism. A **client** sends a request to a **server**, the server processes the request, and returns a response. The client blocks (waits) until the response arrives.

Think of it like a function call, but across the network. The client provides arguments (request), the server computes a result, and returns it (response).

### Why Do We Need Services?

**Without Services (Topics Only):**
- Must track request/response matching manually
- No guarantee that your query was processed
- Can't get immediate feedback on feasibility
- Difficult to implement decision-making logic

**With Services:**
- Clear request/response pairing
- Guaranteed response (or timeout error)
- Immediate feedback before acting
- Clean API for query operations

### Services vs Topics

| Dimension | Topic (Pub/Sub) | Service (Request/Response) |
|-----------|-----------------|---------------------------|
| **Communication** | Asynchronous (fire-and-forget) | Synchronous (blocking) |
| **Cardinality** | 1-to-many (broadcast) | 1-to-1 (client-server) |
| **Use Case** | Sensor streams, state updates | Queries, configuration, validation |
| **Response Guarantee** | None | Guaranteed (or timeout) |
| **Example** | Publishing joint states at 100 Hz | Computing IK for target pose |

```
┌─────────────────────────────────────────────────────────────┐
│                TOPICS vs SERVICES                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  TOPIC (PUB/SUB)                                            │
│  ┌────────┐   /joint_states    ┌────────┐                  │
│  │ Camera │ ─────────────────▶ │Detector│ (may miss msgs)  │
│  │ Node   │   (continuous)     │  Node  │                  │
│  └────────┘                    └────────┘                  │
│                                                             │
│  SERVICE (REQUEST/RESPONSE)                                 │
│  ┌────────┐  ComputeIK Request  ┌────────┐                 │
│  │Planner │ ──────────────────▶ │   IK   │                 │
│  │ Node   │ ◀────────────────── │ Server │ (guaranteed)    │
│  └────────┘  ComputeIK Response └────────┘                 │
│              (blocking wait)                                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Service Architecture

### Request/Response Flow

```
┌─────────────────────────────────────────────────────────────┐
│                    SERVICE ARCHITECTURE                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────┐                  ┌─────────────────┐  │
│  │  Service Client │                  │  Service Server │  │
│  │ (manipulation   │                  │ (ik_solver)     │  │
│  │  planner)       │                  │                 │  │
│  │                 │                  │                 │  │
│  │  1. Build       │ ─── Request ───▶ │ 2. Receive      │  │
│  │     request     │  (target pose)   │    request      │  │
│  │                 │                  │                 │  │
│  │  4. Process     │ ◀── Response ─── │ 3. Compute      │  │
│  │     response    │ (joint angles)   │    result       │  │
│  │                 │                  │                 │  │
│  └─────────────────┘                  └─────────────────┘  │
│                                                             │
│  Client BLOCKS during steps 2-3 until response arrives     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Service Definition File (`.srv`)

Services are defined in `.srv` files with request and response separated by `---`:

```
# Request fields (above the ---)
geometry_msgs/Pose target_pose
---
# Response fields (below the ---)
bool success
float64[] joint_angles
string message
```

---

## Implementation

### Step 1: Create Custom Service Definition

**File**: `~/ros2_ws/src/humanoid_control/srv/ComputeIK.srv`

```
# ComputeIK.srv - Inverse Kinematics Service

# Request: Target end-effector pose
geometry_msgs/Pose target_pose

---

# Response: Joint angles or error
bool success
float64[] joint_angles
string message
```

**Update package.xml** to enable interface generation:
```xml
<buildtool_depend>rosidl_default_generators</buildtool_depend>
<exec_depend>rosidl_default_runtime</exec_depend>
<member_of_group>rosidl_interface_packages</member_of_group>
```

**Update CMakeLists.txt** (for ament_cmake packages):
```cmake
find_package(rosidl_default_generators REQUIRED)
find_package(geometry_msgs REQUIRED)

rosidl_generate_interfaces(${PROJECT_NAME}
  "srv/ComputeIK.srv"
  DEPENDENCIES geometry_msgs
)
```

### Step 2: Implement Service Server

**File**: `~/ros2_ws/src/humanoid_control/scripts/ik_service_server.py`

```python
#!/usr/bin/env python3
"""
Inverse Kinematics Service Server
Computes joint angles for 7-DOF humanoid arm
"""

import rclpy
from rclpy.node import Node
from humanoid_control.srv import ComputeIK
from geometry_msgs.msg import Pose
import numpy as np
import math

class IKServiceServer(Node):
    def __init__(self):
        super().__init__('ik_service_server')

        # Create service server
        self.srv = self.create_service(
            ComputeIK,          # Service type
            'compute_ik',       # Service name
            self.compute_ik_callback  # Callback function
        )

        # 7-DOF arm parameters (link lengths in meters)
        self.link_lengths = [0.3, 0.25, 0.25, 0.2, 0.15, 0.1, 0.08]

        # Joint limits (radians)
        self.joint_limits = {
            'shoulder_pan': (-3.14, 3.14),
            'shoulder_lift': (-1.57, 1.57),
            'shoulder_roll': (-1.57, 1.57),
            'elbow_flex': (0, 2.61),
            'wrist_flex': (-1.57, 1.57),
            'wrist_roll': (-3.14, 3.14),
            'gripper': (0.0, 0.08)
        }

        self.get_logger().info('IK Service Server started on /compute_ik')

    def compute_ik_callback(self, request, response):
        """Service callback: Compute IK for target pose"""
        target_pose = request.target_pose

        self.get_logger().info(
            f'IK request for position: ({target_pose.position.x:.3f}, '
            f'{target_pose.position.y:.3f}, {target_pose.position.z:.3f})'
        )

        try:
            joint_angles = self._solve_ik_analytical(target_pose)

            if self._check_joint_limits(joint_angles):
                response.success = True
                response.joint_angles = joint_angles
                response.message = "IK solution found"
            else:
                response.success = False
                response.joint_angles = []
                response.message = "IK solution violates joint limits"

        except Exception as e:
            response.success = False
            response.joint_angles = []
            response.message = f"IK failed: {str(e)}"

        return response

    def _solve_ik_analytical(self, target_pose):
        """Simplified analytical IK solver for 7-DOF arm"""
        x = target_pose.position.x
        y = target_pose.position.y
        z = target_pose.position.z

        # Compute distance to target
        r = math.sqrt(x**2 + y**2 + z**2)

        # Check reachability
        max_reach = sum(self.link_lengths)
        if r > max_reach:
            raise ValueError(f"Target out of reach: {r:.3f}m > {max_reach:.3f}m")

        # Simplified geometric solution
        theta1 = math.atan2(y, x)  # Shoulder pan

        r_horizontal = math.sqrt(x**2 + y**2)
        L1 = self.link_lengths[0]
        L2 = sum(self.link_lengths[1:3])

        # 2-link planar IK (law of cosines)
        cos_theta3 = (r_horizontal**2 + z**2 - L1**2 - L2**2) / (2 * L1 * L2)
        cos_theta3 = np.clip(cos_theta3, -1.0, 1.0)
        theta3 = math.acos(cos_theta3)

        alpha = math.atan2(z, r_horizontal)
        beta = math.atan2(L2 * math.sin(theta3), L1 + L2 * math.cos(theta3))
        theta2 = alpha - beta

        return [theta1, theta2, 0.0, theta3, 0.0, 0.0, 0.02]

    def _check_joint_limits(self, joint_angles):
        """Verify all joints are within limits"""
        joint_names = list(self.joint_limits.keys())
        for joint_name, angle in zip(joint_names, joint_angles):
            min_val, max_val = self.joint_limits[joint_name]
            if not (min_val <= angle <= max_val):
                return False
        return True


def main(args=None):
    rclpy.init(args=args)
    node = IKServiceServer()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

:::warning Common Mistake
The service callback must always return the response object. Forgetting to return causes the client to hang indefinitely waiting for a response that never comes.
:::

### Step 3: Implement Service Client

**File**: `~/ros2_ws/src/humanoid_control/scripts/ik_service_client.py`

```python
#!/usr/bin/env python3
"""
Inverse Kinematics Service Client
Requests IK solutions for target poses
"""

import rclpy
from rclpy.node import Node
from humanoid_control.srv import ComputeIK
import sys
import math

class IKServiceClient(Node):
    def __init__(self):
        super().__init__('ik_service_client')

        # Create client
        self.cli = self.create_client(ComputeIK, 'compute_ik')

        # Wait for service to be available
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Waiting for /compute_ik service...')

        self.get_logger().info('Connected to /compute_ik service')

    def send_request(self, x, y, z):
        """Send IK request for target position (blocking)"""
        request = ComputeIK.Request()
        request.target_pose.position.x = x
        request.target_pose.position.y = y
        request.target_pose.position.z = z
        request.target_pose.orientation.w = 1.0

        # Blocking call
        future = self.cli.call_async(request)
        rclpy.spin_until_future_complete(self, future)
        return future.result()


def main(args=None):
    rclpy.init(args=args)

    if len(sys.argv) < 4:
        print("Usage: ros2 run humanoid_control ik_service_client <x> <y> <z>")
        sys.exit(1)

    x, y, z = float(sys.argv[1]), float(sys.argv[2]), float(sys.argv[3])

    client = IKServiceClient()
    response = client.send_request(x, y, z)

    if response.success:
        print(f"\nIK Success!")
        joint_names = ['shoulder_pan', 'shoulder_lift', 'shoulder_roll',
                      'elbow_flex', 'wrist_flex', 'wrist_roll', 'gripper']
        for name, angle in zip(joint_names, response.joint_angles):
            print(f"  {name:15s}: {angle:7.3f} rad ({math.degrees(angle):7.2f} deg)")
    else:
        print(f"\nIK Failed: {response.message}")

    client.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Step 4: Build and Test

```bash
cd ~/ros2_ws
colcon build --packages-select humanoid_control
source install/setup.bash
```

**Terminal 1** (Server):
```bash
ros2 run humanoid_control ik_service_server
```

**Terminal 2** (Client):
```bash
ros2 run humanoid_control ik_service_client 0.5 0.2 1.2
```

**Expected Output**:
```
IK Success!
  shoulder_pan   :   0.381 rad (  21.80 deg)
  shoulder_lift  :   0.523 rad (  29.96 deg)
  shoulder_roll  :   0.000 rad (   0.00 deg)
  elbow_flex     :   1.047 rad (  60.00 deg)
  wrist_flex     :   0.000 rad (   0.00 deg)
  wrist_roll     :   0.000 rad (   0.00 deg)
  gripper        :   0.020 rad (   1.15 deg)
```

### Step 5: Test via CLI

```bash
ros2 service call /compute_ik humanoid_control/srv/ComputeIK \
  "{target_pose: {position: {x: 0.5, y: 0.2, z: 1.2}}}"
```

---

## Service CLI Commands

| Command | Purpose |
|---------|---------|
| `ros2 service list` | List all available services |
| `ros2 service type <service>` | Show the service type |
| `ros2 service call <service> <type> <args>` | Call a service |
| `ros2 interface show <type>` | Show service request/response fields |

---

## Connection to Capstone

Services are critical for capstone decision-making:

| Capstone Component | Service Usage |
|-------------------|---------------|
| **Voice Command** | N/A (uses topics for streaming) |
| **Planning** | Call LLM service for task decomposition |
| **Navigation** | Query path validation service |
| **Vision** | Request object recognition service |
| **Manipulation** | Call IK service (what we built!) |

```
┌─────────────────────────────────────────────────────────────┐
│                    CAPSTONE PIPELINE                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Voice ──▶ Plan ──▶ Navigate ──▶ Vision ──▶ Manipulate     │
│              │          │           │           │           │
│            call       call        call        call          │
│          /plan_task /validate   /detect    /compute_ik     │
│                      _path      _objects                    │
│                                                             │
│         ┌─────────────────────────────────────┐             │
│         │           SERVICES                  │             │
│         │                                     │             │
│         │  [THIS SECTION]: Request/response   │             │
│         │  for queries and validation         │             │
│         └─────────────────────────────────────┘             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Summary

In this section, you learned:
- **Services** provide synchronous request/response communication
- **Servers** process requests and return responses
- **Clients** send requests and wait (block) for responses
- `.srv` files define the request and response structure
- Services are ideal for queries, validation, and decision-making

**Key Commands to Remember:**
```bash
# List services
ros2 service list

# Show service type
ros2 service type /compute_ik

# Call service from CLI
ros2 service call /service_name service_type "{request_fields}"

# Show service interface
ros2 interface show humanoid_control/srv/ComputeIK
```

---

## Practice Exercises

### Exercise 1: Basic - Service Introspection
**Objective:** Explore services using CLI tools
**Time:** ~10 minutes

1. Start turtlesim: `ros2 run turtlesim turtlesim_node`
2. List all services: `ros2 service list`
3. Find the spawn service type: `ros2 service type /spawn`
4. Show the spawn interface: `ros2 interface show turtlesim/srv/Spawn`
5. Spawn a new turtle using `ros2 service call`

**Expected Result:** A second turtle appears in the window

<details>
<summary>Hint</summary>
The spawn service takes x, y, theta, and name. Try: `ros2 service call /spawn turtlesim/srv/Spawn "{x: 2.0, y: 2.0, theta: 0.0, name: 'turtle2'}"`
</details>

---

### Exercise 2: Intermediate - Add Timeout Handling
**Objective:** Make the client robust to server failures
**Time:** ~20 minutes

1. Modify `ik_service_client.py` to use a 2-second timeout
2. If the server doesn't respond in time, print an error and exit gracefully
3. Test by running the client WITHOUT starting the server

**Success Criteria:**
- [ ] Client exits after 2 seconds if server unavailable
- [ ] Clear error message displayed
- [ ] No Python exception traceback

---

### Exercise 3: Challenge - Batch IK Service
**Objective:** Extend the service to handle multiple poses
**Time:** ~30+ minutes

Create a new service `ComputeIKBatch.srv` that:
1. Accepts an array of target poses
2. Returns an array of results (one per pose)
3. Reports how many succeeded vs failed

**Bonus:** Measure and log the average computation time per pose.

---

## Troubleshooting

| Problem | Cause | Solution |
|---------|-------|----------|
| Service not found | Server not running | Start server first, verify with `ros2 service list` |
| Client hangs forever | Server callback doesn't return | Ensure callback returns response object |
| Import error for service | Package not built | Run `colcon build` and source workspace |
| "Unknown service type" | Interface not generated | Check CMakeLists.txt has rosidl_generate_interfaces |
| Timeout on call | Server processing too slow | Increase timeout or optimize server code |

---

## What's Next?

In the next section, **M1-C2-S2: ROS 2 Actions**, you will learn:
- Long-running tasks with progress feedback
- Cancellation of in-progress operations
- When to use actions vs services
- Implementing action servers and clients

This will enable you to handle operations that take seconds or minutes, like trajectory execution!

---

## Further Reading

- [ROS 2 Services Tutorial](https://docs.ros.org/en/humble/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Services.html)
- [Writing a Service Server/Client (Python)](https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Service-And-Client.html)
- [Custom Service Definitions](https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Custom-ROS2-Interfaces.html)

:::info Industry Insight
MoveIt 2, the standard manipulation framework used by most industrial robots, implements its inverse kinematics as a ROS 2 service. When you tell a robot arm to reach a position, MoveIt queries IK solvers like KDL, TRAC-IK, or BioIK via service calls. Companies like Universal Robots, FANUC, and ABB all integrate with MoveIt's service-based architecture for motion planning.
:::
