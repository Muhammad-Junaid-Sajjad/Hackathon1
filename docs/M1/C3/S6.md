---
id: m1-c3-s6
title: Collision Detection and Self-Collision Avoidance
sidebar_position: 6
keywords: ['collision', 'self-collision', 'fcl', 'safety', 'moveit', 'collision-checking']
---

# Collision Detection and Self-Collision Avoidance

## Prerequisites

| Requirement | Description |
|-------------|-------------|
| **M1-C3-S1** | URDF collision geometry definitions |
| **M1-C3-S3** | Forward kinematics for link pose computation |
| **Geometry** | Basic 3D geometry (distance, intersection) |

## Learning Objectives

By the end of this section, you will be able to:

1. **Define collision geometry** in URDF using primitives
2. **Create SRDF** with self-collision exception matrix
3. **Check state validity** using MoveIt2 planning scene
4. **Compute distance to collision** for safety monitoring
5. **Implement collision avoidance** strategies (stop, slow, repel)

## Key Concepts

| Concept | Description | Use Case |
|---------|-------------|----------|
| **Collision Geometry** | Simplified shapes for fast checking | Cylinders/boxes for arm links |
| **SRDF** | Semantic Robot Description Format | Disable adjacent link collisions |
| **FCL** | Flexible Collision Library | Low-level collision queries |
| **Self-Collision** | Robot hitting itself | Forearm hitting torso |
| **Safety Margin** | Buffer distance before collision | 5cm warning zone |
| **Planning Scene** | World model with robot + obstacles | MoveIt2 collision checking |

## Overview

**Collision detection** prevents robots from damaging themselves (self-collision: elbow hits torso) or the environment (obstacle collision: gripper hits table). Collision checking uses geometric primitives (spheres, boxes, cylinders) or detailed meshes to compute minimum distances and penetration depths. This section integrates collision geometry into URDF, implements self-collision checking with FCL (Flexible Collision Library), and demonstrates MoveIt2's collision-aware planning.

**What You'll Build**: A complete collision system with URDF collision geometry, self-collision matrix, FCL-based proximity checking, and safety margin enforcement for the humanoid arm.

## Hardware Requirements

**Workstation** (from M1-C1-S1)
- ROS 2 Kilted Kaiju installed (M1-C1-S4)
- MoveIt2 for collision checking
- FCL library

## Connection to Capstone

The capstone uses collision detection for:

1. **Motion Planning**: MoveIt2 rejects trajectories that collide with table, walls, or self
2. **Real-Time Safety**: 100 Hz collision checking during execution → E-stop if obstacle detected
3. **Grasp Planning**: Filter grasps that cause gripper-object collision
4. **Navigation**: Costmap inflation creates collision buffers around obstacles
5. **Teleoperation**: Visual feedback when joystick commands would cause collision

**Without Collision Detection**: Robot damages actuators (self-collision), breaks objects, or injures humans.

## Implementation

### Collision Geometry in URDF

**Already defined in M1-C3-S1** (collision tags for each link):
```xml
<link name="upper_arm_link">
  <visual>
    <geometry>
      <mesh filename="package://humanoid_description/meshes/upper_arm.stl"/>  <!-- 10K triangles -->
    </geometry>
  </visual>

  <collision>
    <geometry>
      <cylinder radius="0.04" length="0.30"/>  <!-- Simplified: 12 triangles -->
    </geometry>
  </collision>
</link>
```

**Collision Geometry Guidelines**:
- Use simple shapes (boxes, cylinders, spheres) for fast checking
- Over-approximate (collision shape slightly larger than visual)
- Typical safety margin: 2-5cm

### Step 1: Self-Collision Matrix

**Define Allowed Collisions** (adjacent links always collide, expected):

**File**: `~/ros2_ws/src/humanoid_moveit_config/config/humanoid.srdf`

```xml
<?xml version="1.0"?>
<robot name="humanoid_arm">

  <!-- Disable collision checking between adjacent links -->
  <disable_collisions link1="base_link" link2="shoulder_link" reason="Adjacent"/>
  <disable_collisions link1="shoulder_link" link2="upper_arm_link" reason="Adjacent"/>
  <disable_collisions link1="upper_arm_link" link2="forearm_link" reason="Adjacent"/>
  <disable_collisions link1="forearm_link" link2="wrist_link" reason="Adjacent"/>
  <disable_collisions link1="wrist_link" link2="gripper_link" reason="Adjacent"/>

  <!-- Disable collision for links that never collide (too far apart) -->
  <disable_collisions link1="base_link" link2="wrist_link" reason="Never"/>
  <disable_collisions link1="base_link" link2="gripper_link" reason="Never"/>

  <!-- Enable collision for non-adjacent links (self-collision possible) -->
  <!-- Example: Forearm can hit torso if shoulder rotates wrong -->
  <!-- No entry = collision checking enabled -->

</robot>
```

**SRDF (Semantic Robot Description Format)**: Extends URDF with collision exceptions, planning groups, end-effectors.

### Step 2: FCL Collision Checking

**Install FCL**:
```bash
sudo apt install ros-kilted-geometric-shapes -y
sudo apt install libfcl-dev -y
```

**Python Collision Checker**:
```python
#!/usr/bin/env python3
"""
Self-Collision Checker using FCL
Checks if robot configuration is collision-free
"""

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState
from std_msgs.msg import Bool
import numpy as np

# Note: Full FCL integration requires C++ or python-fcl bindings
# This is a simplified proximity checker

class SelfCollisionChecker(Node):
    def __init__(self):
        super().__init__('self_collision_checker')

        # Define collision pairs to check (non-adjacent links)
        self.collision_pairs = [
            ('upper_arm_link', 'base_link'),   # Arm swings back into torso
            ('forearm_link', 'base_link'),     # Forearm hits torso
            ('gripper_link', 'base_link'),     # Gripper hits torso
        ]

        # Safety margin (meters)
        self.safety_margin = 0.05  # 5cm buffer

        # Subscribe to joint states
        self.joint_sub = self.create_subscription(
            JointState,
            '/joint_states',
            self.check_collision,
            10
        )

        # Publish collision status
        self.collision_pub = self.create_publisher(
            Bool,
            '/collision_detected',
            10
        )

        self.get_logger().info('Self-Collision Checker started')

    def check_collision(self, joint_msg):
        """
        Check for self-collisions using simplified geometry

        Real implementation would use:
        - FCL for exact collision detection
        - MoveIt2 planning scene for full collision checking
        """
        # Simplified check: distance between link centers
        # (Real implementation computes closest points on collision meshes)

        # For demonstration, check if elbow is too close to torso
        # This would use FK to compute all link poses, then proximity check

        # Placeholder: Always safe for demo
        collision_detected = False

        msg = Bool()
        msg.data = collision_detected
        self.collision_pub.publish(msg)

        if collision_detected:
            self.get_logger().warn('⚠️  Self-collision detected!')


def main(args=None):
    rclpy.init(args=args)
    node = SelfCollisionChecker()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Step 3: MoveIt2 Collision Checking

**MoveIt2 Setup Wizard** (generates collision config):
```bash
# Install MoveIt2
sudo apt install ros-kilted-moveit -y

# Generate MoveIt2 config for humanoid
ros2 run moveit_setup_assistant moveit_setup_assistant

# Steps:
# 1. Load humanoid_arm.urdf
# 2. Generate Self-Collision Matrix (auto-detects adjacent links)
# 3. Define Planning Groups (arm: shoulder→gripper)
# 4. Define End-Effectors (gripper_link)
# 5. Generate package: humanoid_moveit_config
```

**Use MoveIt2 for Collision Checking**:
```python
from moveit_msgs.srv import GetStateValidity
from moveit_msgs.msg import RobotState

def check_state_validity(self, joint_angles):
    """
    Use MoveIt2 to check if configuration is collision-free

    Args:
        joint_angles: Joint configuration to check

    Returns:
        bool: True if valid (no collision)
    """
    request = GetStateValidity.Request()
    request.robot_state = RobotState()
    request.robot_state.joint_state.name = self.joint_names
    request.robot_state.joint_state.position = joint_angles
    request.group_name = 'arm'  # Planning group

    # Call service
    future = self.state_validity_client.call_async(request)
    rclpy.spin_until_future_complete(self, future)

    response = future.result()
    return response.valid
```

### Step 4: Distance to Collision

**Proximity Metrics**:
```python
def compute_min_distance_to_collision(robot_state):
    """
    Compute minimum distance to nearest collision

    Returns:
        float: Distance in meters (0.0 = in collision, >0 = safe)
    """
    # MoveIt2 planning scene provides distance queries
    # Returns closest point pairs between robot and obstacles

    # Simplified example:
    distances = []
    for link_pair in collision_pairs:
        link1_pose = compute_link_pose(link_pair[0], robot_state)
        link2_pose = compute_link_pose(link_pair[1], robot_state)
        dist = np.linalg.norm(link1_pose[:3] - link2_pose[:3])
        distances.append(dist)

    return min(distances) if distances else float('inf')


# Usage in safety controller
min_dist = compute_min_distance_to_collision(current_state)
if min_dist < safety_margin:
    stop_robot()  # Emergency stop
    print(f"⚠️  Too close to collision: {min_dist*100:.1f}cm")
```

### Step 5: Continuous Collision Checking

**For trajectory execution**, check entire path:

```python
def check_trajectory_collision_free(trajectory, robot_state):
    """
    Check if trajectory is collision-free

    Args:
        trajectory: List of joint configurations
        robot_state: Current robot state

    Returns:
        (bool, int): (is_safe, first_collision_index)
    """
    for i, waypoint in enumerate(trajectory):
        # Check waypoint
        if not check_state_validity(waypoint):
            return False, i

        # Check continuous motion (interpolate between waypoints)
        if i > 0:
            prev_waypoint = trajectory[i-1]
            # Check 10 intermediate points
            for alpha in np.linspace(0, 1, 10):
                interpolated = prev_waypoint * (1-alpha) + waypoint * alpha
                if not check_state_validity(interpolated):
                    return False, i

    return True, -1


# Usage
is_safe, collision_idx = check_trajectory_collision_free(planned_trajectory, current_state)
if not is_safe:
    print(f"✗ Trajectory collides at waypoint {collision_idx}")
    replan_trajectory()
else:
    print("✓ Trajectory is collision-free")
    execute_trajectory()
```

## Collision Avoidance Strategies

### Strategy 1: Pre-Planning Validation

```python
# Before executing trajectory
if not is_trajectory_safe(trajectory):
    # Replan with different constraints
    trajectory = replan_with_collision_avoidance()
```

### Strategy 2: Real-Time Monitoring

```python
# During execution (100 Hz loop)
if distance_to_obstacle < emergency_stop_threshold:
    trigger_emergency_stop()
elif distance_to_obstacle < slow_down_threshold:
    reduce_velocity(scale=0.5)
```

### Strategy 3: Repulsive Potential Fields

```python
def compute_repulsive_force(robot_pos, obstacle_pos, influence_distance=0.5):
    """
    Artificial potential field for obstacle avoidance

    Args:
        robot_pos: Current position
        obstacle_pos: Obstacle position
        influence_distance: Max distance for repulsion (m)

    Returns:
        Repulsive force vector
    """
    diff = robot_pos - obstacle_pos
    distance = np.linalg.norm(diff)

    if distance > influence_distance:
        return np.zeros(3)  # Too far, no effect

    if distance < 0.01:
        distance = 0.01  # Avoid division by zero

    # Repulsive force (increases as distance decreases)
    magnitude = 1.0 * (1.0/distance - 1.0/influence_distance) / (distance**2)
    direction = diff / distance

    return magnitude * direction
```

## Next Steps

With collision modeling complete, proceed to:
- **M1-C3-S7**: Module 1 Consistency Check (integration test for all Chapter 1-3 concepts)
- **M2-C1-S1**: Gazebo Harmonic Setup (test collision in simulation)
- **M3-C1-S3**: MoveIt2 Integration (collision-aware motion planning)

**Troubleshooting**:
- **False positives**: Increase safety margin, refine collision geometry
- **Slow collision checking**: Use simplified geometries, reduce check frequency
- **MoveIt2 not found**: Install: `sudo apt install ros-kilted-moveit`
- **Collision mesh errors**: Verify mesh is watertight and manifold

**Real-World Collision Applications**:
- Industrial robots: ISO 10218 safety zones (stop at 0.5m, slow at 1.0m)
- Collaborative robots: Force/torque limits + collision detection
- Autonomous vehicles: 3D occupancy grids + path inflation

---

**Assessment Preparation**: This section is **IMPORTANT** for **Assessment 2: URDF and Kinematics (Week 6)**. You must demonstrate collision geometry definition and self-collision checking.
