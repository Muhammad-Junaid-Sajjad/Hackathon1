---
id: m4-c1-s5
title: Dialogue Management
sidebar_position: 5
keywords: ['dialogue', 'management', 'context', 'conversation']
---

# Dialogue Management

## Prerequisites

Before starting this section, you should:
- Understand intent recognition and entity extraction from M4-C1-S3 (Intent and Entity Recognition)
- Be familiar with speech-to-text and text-to-speech systems from M4-C1-S2 (Speech Processing)
- Have working knowledge of Python dataclasses, enums, and type hints
- Understand basic state machine concepts and finite state automata
- Be comfortable with dictionary and list operations for tracking conversational data

## Learning Objectives

By the end of this section, you will be able to:

- **[Beginner]** Define dialogue state tracking and explain its role in maintaining conversational context
- **[Beginner]** Identify the key components of a dialogue turn (intent, entities, transcript, response)
- **[Intermediate]** Implement a DialogueManager class that tracks conversation state across multiple turns
- **[Intermediate]** Configure context memory systems for storing user preferences and interaction history
- **[Advanced]** Architect reference resolution systems that handle pronouns and anaphora in natural language
- **[Advanced]** Optimize dialogue flow for multi-turn clarification and error recovery strategies

## Key Concepts

| Term | Definition |
|------|------------|
| **Dialogue State Tracking** | The process of maintaining and updating a representation of the current conversation status, including active intents, extracted entities, and user goals. |
| **Turn-Taking** | The mechanism by which conversational participants alternate speaking, managed by the robot to ensure natural interaction flow. |
| **Context Memory** | Storage systems (episodic, semantic, working) that retain information across conversation turns and sessions for personalized responses. |
| **Reference Resolution** | The process of determining what pronouns and definite references (like "it", "there", "that") refer to based on conversational context. |
| **Clarification Loop** | A dialogue pattern where the robot requests additional information when required entities are missing or ambiguous. |
| **Episodic Memory** | Memory of specific interactions and events, allowing the robot to recall what happened in previous conversations. |
| **Semantic Memory** | General knowledge and facts stored independently of when they were learned, providing background context for conversations. |
| **Working Memory** | Short-term storage of current conversation context used for immediate reference resolution and response generation. |

:::danger Latency Trap Warning
**Dialogue state tracking MUST be local for natural conversation.** Cloud-based context storage adds round-trip latency to every turn:
- Store dialogue state in local memory on Jetson
- Process reference resolution on-device
- Only sync to cloud asynchronously for logging (not during active dialogue)
:::

---

Dialogue management maintains conversational context, handles turn-taking, and manages multi-turn interactions with users. This section covers dialogue state tracking, context management, and conversation flow control for humanoid robots.

Effective dialogue management enables natural, context-aware conversations where the robot remembers previous exchanges and responds appropriately.

## Dialogue State Tracking

### Maintaining Conversation Context

```python
# Dialogue management for humanoid robots
import time
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass, field
from enum import Enum
from dataclasses import asdict
import json

class DialogueState(Enum):
    """Dialogue states."""
    IDLE = "idle"
    LISTENING = "listening"
    PROCESSING = "processing"
    RESPONDING = "responding"
    WAITING = "waiting"
    ERROR = "error"


class TurnType(Enum):
    """Types of dialogue turns."""
    USER_COMMAND = "user_command"
    USER_QUESTION = "user_question"
    USER_STATEMENT = "user_statement"
    ROBOT_INFO = "robot_info"
    ROBOT_CONFIRM = "robot_confirm"
    ROBOT_CLARIFY = "robot_clarify"
    ROBOT_ERROR = "robot_error"


@dataclass
class DialogueTurn:
    """Single turn in dialogue."""
    turn_type: TurnType
    transcript: str
    intent: str
    entities: Dict
    timestamp: float
    response: str = ""
    success: bool = True


@dataclass
class DialogueState:
    """Current dialogue state."""
    state: DialogueState
    current_intent: str = ""
    current_entities: Dict = field(default_factory=dict)
    topic: str = ""
    unresolved_entities: List[str] = field(default_factory=list)
    clarification_count: int = 0
    turn_count: int = 0


class DialogueManager:
    """
    Dialogue manager for conversational interaction.
    Tracks state, manages turns, and handles context.
    """

    def __init__(self, config: Dict = None):
        """Initialize dialogue manager."""
        self.config = config or self._default_config()

        # State
        self.state = DialogueState(state=DialogueState.IDLE)

        # History
        self.turn_history: List[DialogueTurn] = []

        # Context
        self.context: Dict[str, Any] = {
            'user_name': None,
            'preferred_objects': {},
            'last_location': None,
            'current_task': None,
        }

        # Topic tracking
        self.current_topic: Optional[str] = None
        self.topic_history: List[str] = []

        # Timeouts
        self.last_user_time = 0
        self.idle_timeout = 300  # 5 minutes

    def _default_config(self) -> Dict:
        """Default configuration."""
        return {
            'max_history_length': 20,
            'max_entity_confusion': 3,
            'confirmation_threshold': 0.7,
            'idle_timeout': 300,
        }

    def process_turn(self, transcript: str, intent: str,
                     entities: Dict, response: str) -> Tuple[str, bool]:
        """
        Process a dialogue turn.

        Args:
            transcript: User's spoken text
            intent: Recognized intent
            entities: Extracted entities
            response: Robot's response

        Returns:
            (generated response, success)
        """
        # Determine turn type
        turn_type = self._classify_turn(intent)

        # Create turn
        turn = DialogueTurn(
            turn_type=turn_type,
            transcript=transcript,
            intent=intent,
            entities=entities,
            timestamp=time.time(),
            response=response
        )

        # Update state
        self.state.turn_count += 1
        self.state.current_intent = intent
        self.state.current_entities = entities

        # Update context
        self._update_context(intent, entities, turn_type)

        # Check for clarification needs
        clarification_needed, clarification_text = self._check_clarification(entities)

        if clarification_needed:
            self.state.clarification_count += 1
            return clarification_text, False

        # Check for errors
        if intent == 'unknown':
            self.state.state = DialogueState.ERROR
            return self._handle_unknown_intent(transcript), False

        # Add to history
        self.turn_history.append(turn)

        # Trim history if needed
        if len(self.turn_history) > self.config['max_history_length']:
            self.turn_history = self.turn_history[-self.config['max_history_length']:]

        # Update timing
        self.last_user_time = time.time()
        self.state.state = DialogueState.IDLE

        return response, True

    def _classify_turn(self, intent: str) -> TurnType:
        """Classify turn type from intent."""
        intent_map = {
            'navigate': TurnType.USER_COMMAND,
            'manipulate': TurnType.USER_COMMAND,
            'question': TurnType.USER_QUESTION,
            'converse': TurnType.USER_STATEMENT,
            'greeting': TurnType.USER_STATEMENT,
            'confirmation': TurnType.USER_COMMAND,
            'negation': TurnType.USER_COMMAND,
        }
        return intent_map.get(intent, TurnType.USER_COMMAND)

    def _update_context(self, intent: str, entities: Dict,
                        turn_type: TurnType):
        """Update dialogue context from turn."""
        # Update user name
        if 'person' in entities:
            if entities['person'] == 'me':
                # Don't overwrite existing name
                pass
            else:
                self.context['user_name'] = entities['person']

        # Track locations
        if 'location' in entities:
            self.context['last_location'] = entities['location']

        # Track objects
        if 'object' in entities:
            obj = entities['object']
            self.context['preferred_objects'][obj] = \
                self.context['preferred_objects'].get(obj, 0) + 1

        # Track topic changes
        if turn_type == TurnType.USER_QUESTION:
            topic = entities.get('topic', intent)
            if topic != self.current_topic:
                self.current_topic = topic
                self.topic_history.append(topic)

    def _check_clarification(self, entities: Dict) -> Tuple[bool, str]:
        """Check if clarification is needed."""
        # Check for missing required entities
        required_entities = self._get_required_entities(
            self.state.current_intent
        )

        missing = [e for e in required_entities if e not in entities]

        if missing:
            clarification_map = {
                'location': "Where would you like me to go?",
                'object': "What object should I interact with?",
                'person': "Who are you referring to?",
                'action': "What action should I perform?",
            }

            questions = [clarification_map.get(m, f"Please specify the {m}.")
                        for m in missing[:2]]  # Max 2 clarifications

            return True, " ".join(questions)

        # Check for low confidence entities
        low_confidence = [k for k, v in entities.items()
                         if isinstance(v, dict) and v.get('confidence', 1.0) < 0.5]

        if low_confidence:
            return True, f"I'm not sure what you mean by '{low_confidence[0]}'. Could you clarify?"

        return False, ""

    def _get_required_entities(self, intent: str) -> List[str]:
        """Get required entities for intent."""
        requirements = {
            'navigate': ['location'],
            'manipulate': ['object', 'action'],
            'converse': ['topic'],
            'question': ['topic'],
        }
        return requirements.get(intent, [])

    def _handle_unknown_intent(self, transcript: str) -> str:
        """Handle unrecognized intent."""
        responses = [
            "I'm sorry, I didn't understand that. Could you rephrase?",
            "I didn't catch what you said. Can you say it differently?",
            "I'm not sure what you mean. Could you clarify?",
        ]
        import random
        return random.choice(responses)

    def get_context_summary(self) -> str:
        """Get summary of current context."""
        summary_parts = []

        if self.context['user_name']:
            summary_parts.append(f"User: {self.context['user_name']}")

        if self.context['last_location']:
            summary_parts.append(f"Current location: {self.context['last_location']}")

        if self.current_topic:
            summary_parts.append(f"Topic: {self.current_topic}")

        if self.context['preferred_objects']:
            top_objects = sorted(
                self.context['preferred_objects'].items(),
                key=lambda x: x[1],
                reverse=True
            )[:3]
            obj_names = ', '.join([o[0] for o in top_objects])
            summary_parts.append(f"Recent objects: {obj_names}")

        return ' | '.join(summary_parts) if summary_parts else "No context"

    def serialize_state(self) -> str:
        """Serialize dialogue state to JSON."""
        state_dict = {
            'state': self.state.state.value,
            'current_intent': self.state.current_intent,
            'current_entities': self.state.current_entities,
            'topic': self.current_topic,
            'turn_count': self.state.turn_count,
            'context': self.context,
            'last_user_time': self.last_user_time,
        }
        return json.dumps(state_dict)

    def load_state(self, state_json: str):
        """Load dialogue state from JSON."""
        state_dict = json.loads(state_json)
        self.state.state = DialogueState(state_dict['state'])
        self.state.current_intent = state_dict.get('current_intent', '')
        self.state.current_entities = state_dict.get('current_entities', {})
        self.context = state_dict.get('context', {})
        self.last_user_time = state_dict.get('last_user_time', 0)


class ConversationFlow:
    """
    Manage conversation flow and responses.
    Handles multi-turn dialogues and follow-up questions.
    """

    def __init__(self, dialogue_manager: DialogueManager):
        """Initialize conversation flow."""
        self.dialogue = dialogue_manager

        # Response templates
        self.templates = {
            'greeting': [
                "Hello! How can I help you today?",
                "Hi there! What would you like me to do?",
                "Good to see you! How can I assist?",
            ],
            'confirmation': [
                "Got it! I'll do that.",
                "Understood! One moment please.",
                "Okay, I'm working on it.",
            ],
            'completion': [
                "All done! Is there anything else?",
                "I've finished that task. What next?",
                "Complete! Let me know if you need anything else.",
            ],
            'error': [
                "I'm sorry, I couldn't complete that request.",
                "Something went wrong. Let me try again.",
                "I had trouble with that. Can we try a different approach?",
            ],
        }

    def get_follow_up(self, intent: str, entities: Dict) -> str:
        """
        Generate appropriate follow-up question.

        Args:
            intent: Current intent
            entities: Extracted entities

        Returns:
            Follow-up question or empty string
        """
        follow_ups = {
            'navigate': "I've arrived. Would you like me to do anything else here?",
            'manipulate': "Done! What should I do with this?",
            'converse': "Is there more you'd like to know about this?",
            'question': "Do you have any other questions?",
        }

        return follow_ups.get(intent, "")

    def get_response(self, template_type: str,
                     context: Dict = None) -> str:
        """
        Get appropriate response from templates.

        Args:
            template_type: Type of response
            context: Additional context

        Returns:
            Response string
        """
        templates = self.templates.get(template_type, [""])

        # Could add context-based selection here
        import random
        response = random.choice(templates)

        return response
```

## Context Management

### Maintaining Long-Term Context

```python
# Long-term context management
from typing import Dict, List, Any
from collections import defaultdict
import time

class ContextMemory:
    """
    Long-term memory for dialogue context.
    Stores user preferences and interaction history.
    """

    def __init__(self, max_entries: int = 1000):
        """Initialize context memory."""
        self.max_entries = max_entries

        # Memory stores
        self.episodic_memory: List[Dict] = []  # Specific interactions
        self.semantic_memory: Dict[str, Any] = {}  # General knowledge
        self.working_memory: Dict[str, Any] = {}  # Current context

        # User preferences
        self.user_preferences: Dict[str, Dict] = {}

    def store_interaction(self, user_id: str, interaction: Dict):
        """
        Store interaction in episodic memory.

        Args:
            user_id: User identifier
            interaction: Interaction data
        """
        entry = {
            'user_id': user_id,
            'timestamp': time.time(),
            'data': interaction
        }

        self.episodic_memory.append(entry)

        # Trim if needed
        if len(self.episodic_memory) > self.max_entries:
            self.episodic_memory = self.episodic_memory[-self.max_entries:]

        # Update preferences
        self._update_preferences(user_id, interaction)

    def _update_preferences(self, user_id: str, interaction: Dict):
        """Update user preferences from interaction."""
        if user_id not in self.user_preferences:
            self.user_preferences[user_id] = {
                'locations': defaultdict(int),
                'objects': defaultdict(int),
                'greetings': [],
                'total_interactions': 0,
            }

        prefs = self.user_preferences[user_id]

        # Count locations
        if 'location' in interaction:
            prefs['locations'][interaction['location']] += 1

        # Count objects
        if 'object' in interaction:
            prefs['objects'][interaction['object']] += 1

        # Count greetings
        if interaction.get('intent') == 'greeting':
            prefs['greetings'].append(interaction.get('transcript', ''))

        prefs['total_interactions'] += 1

    def get_user_preferences(self, user_id: str) -> Dict:
        """Get user preferences."""
        return self.user_preferences.get(user_id, {})

    def get_common_location(self, user_id: str) -> str:
        """Get user's most common location."""
        prefs = self.user_preferences.get(user_id, {})
        locations = prefs.get('locations', {})

        if not locations:
            return None

        return max(locations.items(), key=lambda x: x[1])[0]

    def get_common_object(self, user_id: str) -> str:
        """Get user's most common object."""
        prefs = self.user_preferences.get(user_id, {})
        objects = prefs.get('objects', {})

        if not objects:
            return None

        return max(objects.items(), key=lambda x: x[1])[0]

    def get_recent_interactions(self, user_id: str,
                               count: int = 5) -> List[Dict]:
        """Get recent interactions for user."""
        recent = [
            entry['data'] for entry in reversed(self.episodic_memory)
            if entry['user_id'] == user_id
        ][:count]

        return recent

    def store_fact(self, fact: str, value: Any):
        """Store fact in semantic memory."""
        self.semantic_memory[fact] = {
            'value': value,
            'timestamp': time.time()
        }

    def get_fact(self, fact: str) -> Any:
        """Retrieve fact from semantic memory."""
        return self.semantic_memory.get(fact, {}).get('value')


class ReferenceResolver:
    """
    Resolve references using context.
    Handles pronouns and definite references.
    """

    def __init__(self, memory: ContextMemory):
        """Initialize reference resolver."""
        self.memory = memory

        # Reference patterns
        self.pronouns = {
            'me': self._resolve_me,
            'my': self._resolve_my,
            'this': self._resolve_this,
            'that': self._resolve_that,
            'it': self._resolve_it,
            'there': self._resolve_there,
        }

    def resolve(self, text: str, context: Dict) -> str:
        """
        Resolve references in text.

        Args:
            text: Input text with potential references
            context: Current context

        Returns:
            Text with references resolved
        """
        resolved = text

        for pronoun, resolve_func in self.pronouns.items():
            # Find pronoun occurrences
            pattern = r'\b' + pronoun + r'\b'
            if re.search(pattern, resolved):
                replacement = resolve_func(context)
                resolved = re.sub(pattern, replacement, resolved)

        return resolved

    def _resolve_me(self, context: Dict) -> str:
        """Resolve 'me' to user name or 'you'."""
        user_name = context.get('user_name', 'you')
        return user_name if user_name != 'you' else 'you'

    def _resolve_my(self, context: Dict) -> str:
        """Resolve 'my' to user's."""
        user_name = context.get('user_name', '')
        return f"{user_name}'s" if user_name else 'your'

    def _resolve_this(self, context: Dict) -> str:
        """Resolve 'this' based on context."""
        if 'last_object' in context:
            return context['last_object']
        return 'this'

    def _resolve_that(self, context: Dict) -> str:
        """Resolve 'that' based on context."""
        if 'pointed_object' in context:
            return context['pointed_object']
        return 'that'

    def _resolve_it(self, context: Dict) -> str:
        """Resolve 'it' based on context."""
        if 'last_object' in context:
            return context['last_object']
        return 'it'

    def _resolve_there(self, context: Dict) -> str:
        """Resolve 'there' based on context."""
        if 'last_location' in context:
            return context['last_location']
        return 'there'
```

---

## Connection to Capstone

This section directly supports the capstone project by enabling the **Voice** component to maintain coherent, context-aware conversations throughout the robot's operation pipeline.

| Capstone Component | How This Section Helps |
|-------------------|------------------------|
| **Voice Command** | Dialogue management tracks conversation state, enabling multi-turn command refinement. When a user says "Pick up the red cup" followed by "Now put it on the table," the dialogue manager resolves "it" to the red cup and maintains the task context. |
| **Planning** | Context memory stores user preferences and past interactions, allowing the planner to make personalized decisions. If a user frequently requests items from the kitchen, the planner can optimize navigation paths accordingly. |
| **Navigation** | Reference resolution handles spatial references like "over there" or "by the door," converting conversational location references into actionable navigation goals for the robot. |
| **Vision** | The dialogue manager's entity tracking helps the vision system know what objects to focus on. When the user asks about "that thing," the system can use gesture context to identify the referenced object. |
| **Manipulation** | Clarification loops ensure the robot fully understands manipulation commands before executing. The dialogue manager confirms ambiguous instructions ("Do you mean the large cup or the small one?") to prevent manipulation errors. |

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         CAPSTONE PIPELINE                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Voice ──▶ Plan ──▶ Navigate ──▶ Vision ──▶ Manipulate                    │
│     │         │          │          │            │                          │
│     └─────────┴──────────┴──────────┴────────────┘                          │
│                          │                                                  │
│              ┌───────────┴───────────┐                                      │
│              │  DIALOGUE MANAGEMENT  │                                      │
│              │  ─────────────────────│                                      │
│              │  • State Tracking     │                                      │
│              │  • Context Memory     │                                      │
│              │  • Reference Resolver │                                      │
│              │  • Clarification Flow │                                      │
│              └───────────────────────┘                                      │
│                                                                             │
│   Dialogue Management provides the conversational backbone that enables     │
│   natural language commands to flow through all pipeline stages with        │
│   maintained context and resolved references.                               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Next Steps

With Dialogue Management covered, you can now maintain context across conversation turns. The next section explores Gesture and Pointing Detection for understanding non-verbal communication.
