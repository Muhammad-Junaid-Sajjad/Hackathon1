---
id: m4-c2-s5
title: Error Handling and Replanning
sidebar_position: 5
keywords: ['error-handling', 'replanning', 'recovery', 'robustness', 'fault-tolerance']
---

# Error Handling and Replanning

## Prerequisites

Before starting this section, you should:
- Understand Language-to-Action Grounding from M4-C2-S4
- Be familiar with ROS 2 action servers and feedback (M1-C2-S2)
- Know behavior tree basics from M4-C2-S2
- Have working knowledge of LLM prompting from M4-C1-S3

## Learning Objectives

By the end of this section, you will be able to:
- **Detect** action failures including navigation timeouts, grasp failures, and sensor errors
- **Implement** replanning triggers that invoke LLM-based recovery
- **Design** LLM replan prompts that preserve context while requesting alternative approaches
- **Build** recovery behavior patterns for common humanoid robot failures

## Key Concepts

| Term | Definition |
|------|------------|
| **Error Detection** | The process of identifying when a robot action has failed or deviated from expected behavior |
| **Replanning** | Generating a new action sequence when the original plan cannot be executed |
| **Recovery Behavior** | Pre-defined or dynamically generated actions to restore the robot to a safe, operable state |
| **Fault Tolerance** | The system's ability to continue operating correctly despite component failures |
| **Graceful Degradation** | Maintaining partial functionality when full capability is unavailable |

:::danger Latency Trap Warning
**Error detection and recovery MUST run locally.** A falling robot cannot wait for cloud-based replanning:
- Run error detectors on Jetson with direct sensor access
- Use local rule-based recovery for immediate responses (sub-100ms)
- LLM replanning can use cloud APIs only after safe state is achieved
:::

---

## Introduction

What happens when your humanoid robot reaches for a cup and misses? When the navigation system times out because a human walked through its planned path? When the voice command was misheard and the robot started the wrong task?

In the real world, **failures are not exceptions—they are expectations**. A robust Vision-Language-Action system must anticipate failures, detect them quickly, and recover gracefully. This separates toy demonstrations from production-ready robots.

This section teaches you to build resilient systems that turn failures into learning opportunities. Your robot won't just fail gracefully—it will adapt, replan, and try alternative approaches using the same LLM intelligence that generates its original plans.

:::tip Why This Matters
Industry robots like Amazon's warehouse systems handle millions of picks daily. Even with 99.9% success rates, that means thousands of failures per day. Without robust error handling and replanning, those failures cascade into system-wide problems. Your capstone humanoid must be equally resilient.
:::

---

## Error Detection Architecture

### What Is Error Detection?

**Error detection** is the systematic process of identifying when a robot action has failed, is failing, or is about to fail. Unlike simple boolean success/failure checks, robust error detection provides rich context about *what* went wrong, *why* it might have happened, and *what state* the robot is currently in.

For humanoid robots, error detection spans multiple subsystems: manipulation (did the grasp succeed?), navigation (did we reach the goal?), perception (can we still see the target?), and communication (is the action server responding?).

### Why Do We Need Error Detection?

**Without Error Detection:**
- Robot continues executing invalid plans, potentially causing damage
- Silent failures accumulate, making debugging impossible
- User receives no feedback about task progress
- Recovery is impossible because the system doesn't know something went wrong

**With Error Detection:**
- Immediate awareness of failure enables rapid recovery
- Rich error context enables intelligent replanning
- User can be informed and consulted if needed
- System maintains safety invariants even during failures

### How Does Error Detection Work?

```
┌─────────────────────────────────────────────────────────────────┐
│                   ERROR DETECTION PIPELINE                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐      │
│  │   Action     │───▶│   Monitor    │───▶│   Classify   │      │
│  │   Executor   │    │   Feedback   │    │   Error      │      │
│  └──────────────┘    └──────────────┘    └──────────────┘      │
│         │                   │                   │               │
│         ▼                   ▼                   ▼               │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐      │
│  │   Timeout    │    │   Deviation  │    │   Recovery   │      │
│  │   Watchdog   │    │   Detector   │    │   Selector   │      │
│  └──────────────┘    └──────────────┘    └──────────────┘      │
│                                                                 │
│  Detection Sources:                                             │
│  • Action server feedback (ABORTED, CANCELED, timeout)          │
│  • Sensor validation (gripper force, joint positions)           │
│  • State monitors (object lost from view, collision detected)   │
│  • Watchdog timers (action taking too long)                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementing Error Detection

```python
# File: error_detection.py
# Purpose: Comprehensive error detection for humanoid robot actions

import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.action.client import ClientGoalHandle
from action_msgs.msg import GoalStatus
from typing import Dict, List, Optional, Callable, Any
from dataclasses import dataclass, field
from enum import Enum
import time


class ErrorSeverity(Enum):
    """Severity levels for detected errors."""
    INFO = "info"           # Noteworthy but not problematic
    WARNING = "warning"     # May need attention
    ERROR = "error"         # Action failed, recovery needed
    CRITICAL = "critical"   # System-level failure, immediate stop


class ErrorCategory(Enum):
    """Categories of robot errors."""
    NAVIGATION = "navigation"
    MANIPULATION = "manipulation"
    PERCEPTION = "perception"
    COMMUNICATION = "communication"
    PLANNING = "planning"
    HARDWARE = "hardware"


@dataclass
class DetectedError:
    """Structured representation of a detected error."""
    category: ErrorCategory
    severity: ErrorSeverity
    code: str
    message: str
    timestamp: float
    context: Dict[str, Any] = field(default_factory=dict)
    recoverable: bool = True
    suggested_recovery: Optional[str] = None


class ErrorDetector:
    """
    Central error detection system for humanoid robot operations.
    Monitors action execution and detects failures across subsystems.
    """

    def __init__(self, node: Node):
        """Initialize error detector with ROS node reference."""
        self.node = node
        self.error_history: List[DetectedError] = []
        self.error_callbacks: List[Callable[[DetectedError], None]] = []

        # Configurable thresholds
        self.config = {
            'nav_timeout_sec': 60.0,
            'grasp_timeout_sec': 30.0,
            'perception_timeout_sec': 5.0,
            'max_nav_retries': 3,
            'max_grasp_retries': 2,
            'position_tolerance_m': 0.1,
            'force_threshold_n': 50.0,
        }

        # Active monitors
        self._active_watchdogs: Dict[str, float] = {}

    def register_callback(self, callback: Callable[[DetectedError], None]):
        """Register callback to be notified of errors."""
        self.error_callbacks.append(callback)

    def detect_action_failure(
        self,
        goal_handle: ClientGoalHandle,
        action_name: str,
        expected_duration: float
    ) -> Optional[DetectedError]:
        """
        Detect if an action has failed based on goal handle status.

        Args:
            goal_handle: ROS 2 action client goal handle
            action_name: Name of the action for error context
            expected_duration: Expected time to complete (for timeout detection)

        Returns:
            DetectedError if failure detected, None otherwise
        """
        status = goal_handle.status

        # Map ROS 2 goal statuses to errors
        if status == GoalStatus.STATUS_ABORTED:
            return self._create_error(
                category=self._categorize_action(action_name),
                severity=ErrorSeverity.ERROR,
                code=f"{action_name}_ABORTED",
                message=f"Action '{action_name}' was aborted by the server",
                context={'goal_status': 'ABORTED', 'action': action_name},
                suggested_recovery="retry_with_modified_goal"
            )

        elif status == GoalStatus.STATUS_CANCELED:
            return self._create_error(
                category=self._categorize_action(action_name),
                severity=ErrorSeverity.WARNING,
                code=f"{action_name}_CANCELED",
                message=f"Action '{action_name}' was canceled",
                context={'goal_status': 'CANCELED', 'action': action_name},
                suggested_recovery="check_preemption_reason"
            )

        return None

    def detect_timeout(
        self,
        action_id: str,
        start_time: float,
        timeout_sec: float
    ) -> Optional[DetectedError]:
        """
        Detect if an action has exceeded its timeout.

        Args:
            action_id: Unique identifier for the action
            start_time: When the action started (time.time())
            timeout_sec: Maximum allowed duration

        Returns:
            DetectedError if timeout detected, None otherwise
        """
        elapsed = time.time() - start_time

        if elapsed > timeout_sec:
            return self._create_error(
                category=ErrorCategory.COMMUNICATION,
                severity=ErrorSeverity.ERROR,
                code=f"{action_id}_TIMEOUT",
                message=f"Action '{action_id}' timed out after {elapsed:.1f}s (limit: {timeout_sec}s)",
                context={
                    'elapsed_sec': elapsed,
                    'timeout_sec': timeout_sec,
                    'action_id': action_id
                },
                suggested_recovery="cancel_and_retry"
            )

        return None

    def detect_navigation_error(
        self,
        current_pose: Dict[str, float],
        goal_pose: Dict[str, float],
        nav_result: Any
    ) -> Optional[DetectedError]:
        """
        Detect navigation-specific errors.

        Args:
            current_pose: Robot's current position {'x', 'y', 'theta'}
            goal_pose: Target position
            nav_result: Result from Nav2 action

        Returns:
            DetectedError if navigation failed, None otherwise
        """
        # Check if we reached the goal (within tolerance)
        distance = (
            (current_pose['x'] - goal_pose['x'])**2 +
            (current_pose['y'] - goal_pose['y'])**2
        ) ** 0.5

        if distance > self.config['position_tolerance_m']:
            return self._create_error(
                category=ErrorCategory.NAVIGATION,
                severity=ErrorSeverity.ERROR,
                code="NAV_GOAL_NOT_REACHED",
                message=f"Navigation ended {distance:.2f}m from goal (tolerance: {self.config['position_tolerance_m']}m)",
                context={
                    'current_pose': current_pose,
                    'goal_pose': goal_pose,
                    'distance_from_goal': distance
                },
                suggested_recovery="retry_navigation"
            )

        return None

    def detect_grasp_failure(
        self,
        gripper_state: Dict[str, float],
        expected_object: str
    ) -> Optional[DetectedError]:
        """
        Detect manipulation/grasp failures.

        Args:
            gripper_state: Current gripper state {'position', 'force', 'holding'}
            expected_object: What the robot was trying to grasp

        Returns:
            DetectedError if grasp failed, None otherwise
        """
        # Check if gripper is holding something
        if not gripper_state.get('holding', False):
            return self._create_error(
                category=ErrorCategory.MANIPULATION,
                severity=ErrorSeverity.ERROR,
                code="GRASP_FAILED",
                message=f"Failed to grasp '{expected_object}' - gripper not holding object",
                context={
                    'gripper_position': gripper_state.get('position'),
                    'gripper_force': gripper_state.get('force'),
                    'target_object': expected_object
                },
                suggested_recovery="reposition_and_retry_grasp"
            )

        # Check for excessive force (object might be stuck)
        if gripper_state.get('force', 0) > self.config['force_threshold_n']:
            return self._create_error(
                category=ErrorCategory.MANIPULATION,
                severity=ErrorSeverity.WARNING,
                code="GRASP_HIGH_FORCE",
                message=f"Grasp force {gripper_state['force']:.1f}N exceeds threshold",
                context={
                    'gripper_force': gripper_state.get('force'),
                    'threshold': self.config['force_threshold_n']
                },
                suggested_recovery="reduce_grasp_force"
            )

        return None

    def detect_perception_error(
        self,
        object_id: str,
        last_seen_time: float,
        required_for_action: bool = True
    ) -> Optional[DetectedError]:
        """
        Detect perception/tracking failures.

        Args:
            object_id: ID of object being tracked
            last_seen_time: Timestamp when object was last detected
            required_for_action: Whether current action needs this object

        Returns:
            DetectedError if perception failed, None otherwise
        """
        time_since_seen = time.time() - last_seen_time

        if time_since_seen > self.config['perception_timeout_sec']:
            severity = ErrorSeverity.ERROR if required_for_action else ErrorSeverity.WARNING

            return self._create_error(
                category=ErrorCategory.PERCEPTION,
                severity=severity,
                code="OBJECT_LOST",
                message=f"Lost track of object '{object_id}' for {time_since_seen:.1f}s",
                context={
                    'object_id': object_id,
                    'time_since_seen': time_since_seen,
                    'required_for_action': required_for_action
                },
                suggested_recovery="search_for_object"
            )

        return None

    def _create_error(
        self,
        category: ErrorCategory,
        severity: ErrorSeverity,
        code: str,
        message: str,
        context: Dict,
        suggested_recovery: str
    ) -> DetectedError:
        """Create and record an error."""
        error = DetectedError(
            category=category,
            severity=severity,
            code=code,
            message=message,
            timestamp=time.time(),
            context=context,
            recoverable=severity != ErrorSeverity.CRITICAL,
            suggested_recovery=suggested_recovery
        )

        self.error_history.append(error)

        # Notify callbacks
        for callback in self.error_callbacks:
            callback(error)

        # Log the error
        self.node.get_logger().error(f"[{code}] {message}")

        return error

    def _categorize_action(self, action_name: str) -> ErrorCategory:
        """Categorize an action by name."""
        action_lower = action_name.lower()

        if any(kw in action_lower for kw in ['nav', 'move', 'goto', 'walk']):
            return ErrorCategory.NAVIGATION
        elif any(kw in action_lower for kw in ['grasp', 'grip', 'pick', 'place', 'manipulate']):
            return ErrorCategory.MANIPULATION
        elif any(kw in action_lower for kw in ['detect', 'recognize', 'track', 'perceive']):
            return ErrorCategory.PERCEPTION
        else:
            return ErrorCategory.PLANNING

    def get_recent_errors(
        self,
        category: Optional[ErrorCategory] = None,
        since_sec: float = 60.0
    ) -> List[DetectedError]:
        """Get recent errors, optionally filtered by category."""
        cutoff = time.time() - since_sec

        errors = [e for e in self.error_history if e.timestamp > cutoff]

        if category:
            errors = [e for e in errors if e.category == category]

        return errors

    def clear_history(self):
        """Clear error history."""
        self.error_history.clear()
```

**Expected Output** (when errors are detected):
```
[ERROR] [NAV_GOAL_NOT_REACHED] Navigation ended 0.45m from goal (tolerance: 0.1m)
[ERROR] [GRASP_FAILED] Failed to grasp 'red_cup' - gripper not holding object
[WARNING] [OBJECT_LOST] Lost track of object 'target_mug' for 6.2s
```

**What to Observe**:
- Each error includes category, severity, code, message, and context
- Suggested recovery actions are provided with each error
- Error history enables pattern detection (e.g., repeated failures)

:::warning Common Mistake
Don't treat all errors equally. A navigation timeout in a cluttered environment might just need a retry, but repeated grasp failures on the same object suggest the object may have moved or the grasp strategy is wrong. Use error patterns, not just individual errors, to choose recovery strategies.
:::

---

## Replanning Triggers

### What Is a Replanning Trigger?

**Replanning triggers** are conditions that, when met, cause the system to pause current execution and generate a new plan. Unlike simple retries (doing the same thing again), replanning involves re-invoking the LLM planner with updated context about what went wrong.

### Why Do We Need Replanning Triggers?

**Without Replanning Triggers:**
- Robot retries the same failing action indefinitely
- No learning from failures—same mistakes repeated
- Context about the failure is lost

**With Replanning Triggers:**
- System knows *when* to stop retrying and seek alternatives
- LLM receives failure context to generate smarter plans
- Robot can adapt strategy based on what went wrong

### How Do Replanning Triggers Work?

```
┌─────────────────────────────────────────────────────────────────┐
│                   REPLANNING DECISION TREE                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│                      ┌─────────────────┐                        │
│                      │  Error Detected │                        │
│                      └────────┬────────┘                        │
│                               │                                 │
│                               ▼                                 │
│                      ┌─────────────────┐                        │
│                      │ Retry Counter   │                        │
│                      │ < Max Retries?  │                        │
│                      └────────┬────────┘                        │
│                         │           │                           │
│                       Yes          No                           │
│                         │           │                           │
│                         ▼           ▼                           │
│              ┌──────────────┐  ┌──────────────┐                 │
│              │ Simple Retry │  │   Trigger    │                 │
│              │ Same Action  │  │  Replanning  │                 │
│              └──────────────┘  └──────────────┘                 │
│                                      │                          │
│                                      ▼                          │
│                           ┌──────────────────┐                  │
│                           │ Build Replan     │                  │
│                           │ Context + Prompt │                  │
│                           └────────┬─────────┘                  │
│                                    │                            │
│                                    ▼                            │
│                           ┌──────────────────┐                  │
│                           │   Invoke LLM     │                  │
│                           │   for New Plan   │                  │
│                           └──────────────────┘                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Implementing Replanning Triggers

```python
# File: replanning_triggers.py
# Purpose: Determine when to trigger LLM replanning vs simple retry

from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum
import time


class ReplanningDecision(Enum):
    """Possible decisions when an error occurs."""
    RETRY_SAME = "retry_same"           # Try exact same action again
    RETRY_MODIFIED = "retry_modified"   # Retry with modified parameters
    REPLAN_PARTIAL = "replan_partial"   # Replan from current step
    REPLAN_FULL = "replan_full"         # Replan entire task
    ABORT_TASK = "abort_task"           # Give up on the task
    ASK_HUMAN = "ask_human"             # Request human intervention


@dataclass
class ReplanContext:
    """Context passed to LLM for replanning."""
    original_task: str
    completed_steps: List[str]
    failed_step: str
    error_details: Dict
    retry_count: int
    environment_state: Dict
    constraints: List[str] = field(default_factory=list)


class ReplanningTriggerManager:
    """
    Manages decisions about when to retry vs replan.
    Uses error patterns and history to make intelligent decisions.
    """

    def __init__(self):
        """Initialize trigger manager."""
        self.retry_counts: Dict[str, int] = {}
        self.failure_history: List[Dict] = []

        # Configuration
        self.config = {
            'max_retries_navigation': 3,
            'max_retries_manipulation': 2,
            'max_retries_perception': 5,
            'max_consecutive_failures': 3,
            'replan_cooldown_sec': 10.0,
            'human_intervention_threshold': 5,
        }

        self._last_replan_time: float = 0

    def evaluate(
        self,
        error: 'DetectedError',
        current_step: str,
        task_context: Dict
    ) -> Tuple[ReplanningDecision, Optional[ReplanContext]]:
        """
        Evaluate whether to retry, replan, or abort.

        Args:
            error: The detected error
            current_step: Description of the step that failed
            task_context: Current task state

        Returns:
            Tuple of (decision, replan_context if replanning needed)
        """
        # Update retry count
        step_key = f"{current_step}_{error.code}"
        self.retry_counts[step_key] = self.retry_counts.get(step_key, 0) + 1
        retry_count = self.retry_counts[step_key]

        # Record failure
        self._record_failure(error, current_step, retry_count)

        # Check for critical errors (never retry)
        if error.severity == ErrorSeverity.CRITICAL:
            return ReplanningDecision.ABORT_TASK, None

        # Check consecutive failure threshold
        if self._check_consecutive_failures() >= self.config['max_consecutive_failures']:
            return ReplanningDecision.ASK_HUMAN, self._build_context(
                error, current_step, task_context, retry_count
            )

        # Get max retries for this error category
        max_retries = self._get_max_retries(error.category)

        # Decision logic
        if retry_count <= max_retries:
            # Try simple retry or modified retry
            if self._should_modify_retry(error):
                return ReplanningDecision.RETRY_MODIFIED, None
            return ReplanningDecision.RETRY_SAME, None

        elif retry_count <= max_retries + 2:
            # Exhausted retries, trigger partial replan
            return ReplanningDecision.REPLAN_PARTIAL, self._build_context(
                error, current_step, task_context, retry_count
            )

        else:
            # Multiple replans failed, do full replan
            return ReplanningDecision.REPLAN_FULL, self._build_context(
                error, current_step, task_context, retry_count
            )

    def _get_max_retries(self, category: ErrorCategory) -> int:
        """Get maximum retries for error category."""
        category_map = {
            ErrorCategory.NAVIGATION: self.config['max_retries_navigation'],
            ErrorCategory.MANIPULATION: self.config['max_retries_manipulation'],
            ErrorCategory.PERCEPTION: self.config['max_retries_perception'],
        }
        return category_map.get(category, 2)

    def _should_modify_retry(self, error: 'DetectedError') -> bool:
        """Determine if retry should use modified parameters."""
        # Modify retry for certain error types
        modification_triggers = [
            'GRASP_FAILED',      # Try different grasp pose
            'NAV_GOAL_NOT_REACHED',  # Try different approach angle
            'OBJECT_LOST',       # Search different area
        ]
        return error.code in modification_triggers

    def _record_failure(
        self,
        error: 'DetectedError',
        step: str,
        retry_count: int
    ):
        """Record failure for pattern analysis."""
        self.failure_history.append({
            'error_code': error.code,
            'category': error.category,
            'step': step,
            'retry_count': retry_count,
            'timestamp': time.time()
        })

        # Keep only recent history
        cutoff = time.time() - 300  # 5 minutes
        self.failure_history = [
            f for f in self.failure_history
            if f['timestamp'] > cutoff
        ]

    def _check_consecutive_failures(self) -> int:
        """Count consecutive failures (no successes between them)."""
        if not self.failure_history:
            return 0

        # Count failures in last 60 seconds
        cutoff = time.time() - 60
        recent = [f for f in self.failure_history if f['timestamp'] > cutoff]
        return len(recent)

    def _build_context(
        self,
        error: 'DetectedError',
        current_step: str,
        task_context: Dict,
        retry_count: int
    ) -> ReplanContext:
        """Build context for LLM replanning."""
        return ReplanContext(
            original_task=task_context.get('original_command', 'Unknown task'),
            completed_steps=task_context.get('completed_steps', []),
            failed_step=current_step,
            error_details={
                'code': error.code,
                'message': error.message,
                'category': error.category.value,
                'context': error.context
            },
            retry_count=retry_count,
            environment_state=task_context.get('environment_state', {}),
            constraints=self._get_replan_constraints(error)
        )

    def _get_replan_constraints(self, error: 'DetectedError') -> List[str]:
        """Generate constraints for replanning based on error."""
        constraints = []

        if error.code == 'NAV_GOAL_NOT_REACHED':
            constraints.append("Previous navigation path was blocked")
            constraints.append("Consider alternative approach direction")

        elif error.code == 'GRASP_FAILED':
            constraints.append("Direct grasp from above failed")
            constraints.append("Consider side grasp or moving object first")

        elif error.code == 'OBJECT_LOST':
            constraints.append("Object may have moved or been occluded")
            constraints.append("Search nearby area before proceeding")

        return constraints

    def reset_for_new_task(self):
        """Reset counters for a new task."""
        self.retry_counts.clear()
        self.failure_history.clear()


# Integration with behavior tree / task executor
class ReplanningExecutor:
    """
    Executes replanning decisions by coordinating with LLM and action system.
    """

    def __init__(
        self,
        error_detector: ErrorDetector,
        trigger_manager: ReplanningTriggerManager,
        llm_planner: 'LLMPlanner'  # From M4-C1-S3
    ):
        """Initialize executor with dependencies."""
        self.error_detector = error_detector
        self.trigger_manager = trigger_manager
        self.llm_planner = llm_planner

        # Register as error callback
        self.error_detector.register_callback(self._on_error)

        self._current_task_context: Dict = {}
        self._pending_replan: Optional[ReplanContext] = None

    def set_task_context(self, context: Dict):
        """Set context for current task."""
        self._current_task_context = context

    def _on_error(self, error: DetectedError):
        """Handle detected error."""
        current_step = self._current_task_context.get('current_step', 'unknown')

        decision, context = self.trigger_manager.evaluate(
            error, current_step, self._current_task_context
        )

        print(f"[REPLANNING] Decision: {decision.value}")

        if decision == ReplanningDecision.REPLAN_PARTIAL:
            self._execute_partial_replan(context)
        elif decision == ReplanningDecision.REPLAN_FULL:
            self._execute_full_replan(context)
        elif decision == ReplanningDecision.ASK_HUMAN:
            self._request_human_help(context)
        elif decision == ReplanningDecision.ABORT_TASK:
            self._abort_current_task(error)

    def _execute_partial_replan(self, context: ReplanContext):
        """Execute partial replanning from failed step."""
        print(f"[REPLANNING] Partial replan from: {context.failed_step}")

        # Build replan prompt
        prompt = self._build_replan_prompt(context, partial=True)

        # Get new plan from LLM
        new_plan = self.llm_planner.generate_plan(prompt)

        # Resume execution with new plan
        self._resume_with_plan(new_plan, context.completed_steps)

    def _execute_full_replan(self, context: ReplanContext):
        """Execute full task replanning."""
        print(f"[REPLANNING] Full replan for: {context.original_task}")

        # Build replan prompt with full context
        prompt = self._build_replan_prompt(context, partial=False)

        # Get completely new plan
        new_plan = self.llm_planner.generate_plan(prompt)

        # Start fresh with new plan
        self._resume_with_plan(new_plan, [])

    def _build_replan_prompt(
        self,
        context: ReplanContext,
        partial: bool
    ) -> str:
        """Build prompt for LLM replanning."""
        if partial:
            return f"""
The robot was executing the task: "{context.original_task}"

Completed steps:
{self._format_steps(context.completed_steps)}

The following step FAILED: {context.failed_step}
Error: {context.error_details['message']}
Error context: {context.error_details['context']}

This step has been retried {context.retry_count} times without success.

Constraints for replanning:
{self._format_constraints(context.constraints)}

Current environment state:
{context.environment_state}

Generate an ALTERNATIVE approach to complete the remaining task.
Do NOT repeat the exact same action that failed.
Consider why the action failed and plan around it.

Output format: JSON array of action steps.
"""
        else:
            return f"""
The robot attempted the task: "{context.original_task}"

The task has FAILED despite multiple replanning attempts.

Failure history:
- Failed step: {context.failed_step}
- Error: {context.error_details['message']}
- Retry count: {context.retry_count}

Constraints:
{self._format_constraints(context.constraints)}

Current environment state:
{context.environment_state}

Generate a COMPLETELY NEW approach to accomplish this task.
Think creatively - the straightforward approach has failed.

Output format: JSON array of action steps.
"""

    def _format_steps(self, steps: List[str]) -> str:
        """Format step list for prompt."""
        if not steps:
            return "  (none completed)"
        return "\n".join(f"  ✓ {step}" for step in steps)

    def _format_constraints(self, constraints: List[str]) -> str:
        """Format constraints for prompt."""
        if not constraints:
            return "  (no specific constraints)"
        return "\n".join(f"  - {c}" for c in constraints)

    def _resume_with_plan(self, new_plan: List[Dict], completed: List[str]):
        """Resume task execution with new plan."""
        # Implementation depends on behavior tree / executor architecture
        print(f"[REPLANNING] Resuming with {len(new_plan)} new steps")
        # Signal behavior tree to switch to new plan

    def _request_human_help(self, context: ReplanContext):
        """Request human intervention."""
        print(f"[REPLANNING] Requesting human help for: {context.failed_step}")
        # Publish to human intervention topic
        # Play audio prompt
        # Wait for human response

    def _abort_current_task(self, error: DetectedError):
        """Abort the current task safely."""
        print(f"[REPLANNING] Aborting task due to: {error.code}")
        # Return to safe pose
        # Release any held objects
        # Report failure to user
```

**Expected Output** (during replanning):
```
[REPLANNING] Decision: retry_same
[REPLANNING] Decision: retry_modified
[REPLANNING] Decision: replan_partial
[REPLANNING] Partial replan from: grasp_red_cup
[REPLANNING] Resuming with 3 new steps
```

---

## LLM Replan Prompts

### Designing Effective Replan Prompts

The quality of replanning depends heavily on how you communicate failure context to the LLM. A good replan prompt includes:

1. **What the robot was trying to do** (original task)
2. **What succeeded** (completed steps)
3. **What failed and why** (error details)
4. **Current state** (environment, robot position, held objects)
5. **Constraints** (what NOT to try again)

```python
# File: replan_prompts.py
# Purpose: LLM prompt templates for replanning

from typing import Dict, List, Optional
from dataclasses import dataclass


@dataclass
class ReplanPromptConfig:
    """Configuration for replan prompts."""
    include_error_details: bool = True
    include_environment: bool = True
    include_constraints: bool = True
    max_alternatives: int = 3
    require_reasoning: bool = True


class ReplanPromptBuilder:
    """
    Builds effective prompts for LLM replanning.
    """

    def __init__(self, config: ReplanPromptConfig = None):
        """Initialize with configuration."""
        self.config = config or ReplanPromptConfig()

        # Prompt templates
        self.templates = {
            'navigation_failure': self._nav_failure_template,
            'grasp_failure': self._grasp_failure_template,
            'perception_failure': self._perception_failure_template,
            'generic_failure': self._generic_failure_template,
        }

    def build(
        self,
        context: 'ReplanContext',
        failure_type: str = 'generic_failure'
    ) -> str:
        """
        Build a replan prompt from context.

        Args:
            context: Replanning context with failure details
            failure_type: Type of failure for specialized prompts

        Returns:
            Complete prompt string for LLM
        """
        template_fn = self.templates.get(
            failure_type,
            self._generic_failure_template
        )
        return template_fn(context)

    def _nav_failure_template(self, context: 'ReplanContext') -> str:
        """Template for navigation failures."""
        return f"""You are a robot task planner. The robot failed to navigate.

ORIGINAL TASK: {context.original_task}

COMPLETED STEPS:
{self._format_completed(context.completed_steps)}

FAILED STEP: {context.failed_step}

NAVIGATION ERROR:
{context.error_details.get('message', 'Navigation failed')}

CURRENT POSITION:
{context.environment_state.get('robot_position', 'Unknown')}

TARGET POSITION:
{context.error_details.get('context', {}).get('goal_pose', 'Unknown')}

KNOWN OBSTACLES:
{context.environment_state.get('obstacles', 'None detected')}

CONSTRAINTS (do NOT do these):
{self._format_constraints(context.constraints)}

Generate an alternative navigation approach. Options include:
1. Different approach angle to the goal
2. Intermediate waypoints to avoid obstacles
3. Asking human to clear the path
4. Alternative goal location if original is blocked

OUTPUT FORMAT:
Return a JSON object with "reasoning" (string) and "steps" (array of action objects).
Each action has "action" (string) and "params" (object with action-specific parameters).
"""

    def _grasp_failure_template(self, context: 'ReplanContext') -> str:
        """Template for grasp/manipulation failures."""
        return f"""You are a robot manipulation planner. The robot failed to grasp an object.

ORIGINAL TASK: {context.original_task}

COMPLETED STEPS:
{self._format_completed(context.completed_steps)}

FAILED STEP: {context.failed_step}

GRASP ERROR:
{context.error_details.get('message', 'Grasp failed')}

TARGET OBJECT:
{context.error_details.get('context', {}).get('target_object', 'Unknown')}

GRIPPER STATE:
- Position: {context.environment_state.get('gripper_position', 'Unknown')}
- Force: {context.environment_state.get('gripper_force', 'Unknown')}

OBJECT POSITION (last known):
{context.environment_state.get('object_position', 'Unknown')}

CONSTRAINTS (previous attempts that failed):
{self._format_constraints(context.constraints)}

Generate an alternative grasp approach. Options include:
1. Different grasp orientation (top, side, angled)
2. Repositioning the robot for better reach
3. Moving nearby objects to clear space
4. Using a different grasp primitive
5. Asking human to hand over the object

OUTPUT FORMAT:
Return a JSON object with "reasoning" (string) and "steps" (array of action objects).
Each action has "action" (string like "move_arm", "grasp") and "params" (object with pose, approach, force, etc.).
"""

    def _perception_failure_template(self, context: 'ReplanContext') -> str:
        """Template for perception/detection failures."""
        return f"""You are a robot perception planner. The robot lost track of an object.

ORIGINAL TASK: {context.original_task}

COMPLETED STEPS:
{self._format_completed(context.completed_steps)}

FAILED STEP: {context.failed_step}

PERCEPTION ERROR:
{context.error_details.get('message', 'Object lost')}

LOST OBJECT:
{context.error_details.get('context', {}).get('object_id', 'Unknown')}

LAST KNOWN POSITION:
{context.environment_state.get('last_object_position', 'Unknown')}

TIME SINCE SEEN:
{context.error_details.get('context', {}).get('time_since_seen', 'Unknown')} seconds

CURRENT CAMERA VIEW:
{context.environment_state.get('visible_objects', 'Unknown')}

CONSTRAINTS:
{self._format_constraints(context.constraints)}

Generate a search and recovery approach. Options include:
1. Pan camera to search nearby area
2. Move robot to get different viewing angle
3. Search likely locations (table, shelf, floor)
4. Ask human where the object is
5. Use a different object if suitable substitute exists

OUTPUT FORMAT:
Return a JSON object with "reasoning" (string) and "steps" (array of action objects).
Each action has "action" (string like "look_at", "detect_object") and "params" (object with direction, target, etc.).
"""

    def _generic_failure_template(self, context: 'ReplanContext') -> str:
        """Generic template for any failure type."""
        return f"""You are a robot task planner. An action has failed and replanning is needed.

ORIGINAL TASK: {context.original_task}

PROGRESS:
- Completed: {len(context.completed_steps)} steps
- Failed at: {context.failed_step}
- Retry attempts: {context.retry_count}

ERROR DETAILS:
- Code: {context.error_details.get('code', 'UNKNOWN')}
- Message: {context.error_details.get('message', 'No details')}
- Category: {context.error_details.get('category', 'unknown')}

ENVIRONMENT STATE:
{self._format_environment(context.environment_state)}

CONSTRAINTS (what has already failed):
{self._format_constraints(context.constraints)}

Generate an alternative approach to complete the task.
- Do NOT repeat actions that have already failed
- Consider why the failure occurred
- Think about alternative strategies

OUTPUT FORMAT:
Return a JSON object with: "reasoning" (string), "confidence" (float 0-1),
"steps" (array of action objects), and "fallback" (string describing backup plan).
Each step has "action" (string) and "params" (object with action-specific parameters).
"""

    def _format_completed(self, steps: List[str]) -> str:
        """Format completed steps."""
        if not steps:
            return "  (No steps completed yet)"
        return "\n".join(f"  ✓ {i+1}. {step}" for i, step in enumerate(steps))

    def _format_constraints(self, constraints: List[str]) -> str:
        """Format constraints list."""
        if not constraints:
            return "  (No specific constraints)"
        return "\n".join(f"  ✗ {c}" for c in constraints)

    def _format_environment(self, state: Dict) -> str:
        """Format environment state."""
        if not state:
            return "  (Environment state unknown)"

        lines = []
        for key, value in state.items():
            lines.append(f"  - {key}: {value}")
        return "\n".join(lines)


# Example usage
def demonstrate_replan_prompts():
    """Demonstrate replan prompt generation."""
    builder = ReplanPromptBuilder()

    # Simulate a grasp failure context
    context = ReplanContext(
        original_task="Pick up the red cup and bring it to me",
        completed_steps=[
            "Detected red cup on table",
            "Navigated to table",
            "Positioned arm above cup"
        ],
        failed_step="Grasp red cup",
        error_details={
            'code': 'GRASP_FAILED',
            'message': 'Gripper closed but no object detected',
            'category': 'manipulation',
            'context': {'target_object': 'red_cup', 'gripper_force': 5.2}
        },
        retry_count=2,
        environment_state={
            'robot_position': {'x': 1.2, 'y': 0.5},
            'gripper_position': 'open',
            'gripper_force': 0.0,
            'object_position': {'x': 1.3, 'y': 0.6, 'z': 0.8},
            'visible_objects': ['red_cup', 'blue_plate', 'spoon']
        },
        constraints=[
            "Top-down grasp failed twice",
            "Object may have shifted"
        ]
    )

    prompt = builder.build(context, 'grasp_failure')
    print("Generated Replan Prompt:")
    print("-" * 50)
    print(prompt)
```

---

## Recovery Behaviors

### Pre-defined Recovery Patterns

While LLM replanning handles complex failures, simple failures benefit from pre-defined recovery behaviors that execute faster without LLM latency.

```python
# File: recovery_behaviors.py
# Purpose: Pre-defined recovery behaviors for common failures

from typing import Dict, List, Optional, Callable
from dataclasses import dataclass
from enum import Enum
import time


class RecoveryType(Enum):
    """Types of recovery behaviors."""
    RETRY = "retry"
    SEARCH = "search"
    REPOSITION = "reposition"
    RELEASE = "release"
    SAFE_STOP = "safe_stop"
    ASK_HUMAN = "ask_human"


@dataclass
class RecoveryBehavior:
    """A pre-defined recovery behavior."""
    name: str
    recovery_type: RecoveryType
    applicable_errors: List[str]
    execute: Callable[[Dict], bool]
    timeout_sec: float = 30.0
    description: str = ""


class RecoveryBehaviorLibrary:
    """
    Library of pre-defined recovery behaviors.
    Fast fallbacks that don't require LLM replanning.
    """

    def __init__(self, robot_interface: 'RobotInterface'):
        """Initialize with robot interface."""
        self.robot = robot_interface
        self.behaviors: Dict[str, RecoveryBehavior] = {}

        # Register default behaviors
        self._register_defaults()

    def _register_defaults(self):
        """Register default recovery behaviors."""

        # Navigation recovery: back up and retry
        self.register(RecoveryBehavior(
            name="nav_backup_retry",
            recovery_type=RecoveryType.REPOSITION,
            applicable_errors=['NAV_GOAL_NOT_REACHED', 'NAV_STUCK'],
            execute=self._nav_backup_retry,
            timeout_sec=20.0,
            description="Back up 0.5m and retry navigation"
        ))

        # Navigation recovery: rotate and scan
        self.register(RecoveryBehavior(
            name="nav_rotate_scan",
            recovery_type=RecoveryType.SEARCH,
            applicable_errors=['NAV_NO_PATH', 'NAV_COSTMAP_ERROR'],
            execute=self._nav_rotate_scan,
            timeout_sec=30.0,
            description="Rotate 360° to update costmap"
        ))

        # Grasp recovery: release and reposition
        self.register(RecoveryBehavior(
            name="grasp_release_retry",
            recovery_type=RecoveryType.RELEASE,
            applicable_errors=['GRASP_FAILED', 'GRASP_SLIP'],
            execute=self._grasp_release_retry,
            timeout_sec=15.0,
            description="Open gripper, reposition, retry"
        ))

        # Grasp recovery: try side grasp
        self.register(RecoveryBehavior(
            name="grasp_side_approach",
            recovery_type=RecoveryType.REPOSITION,
            applicable_errors=['GRASP_FAILED'],
            execute=self._grasp_side_approach,
            timeout_sec=25.0,
            description="Approach from side instead of top"
        ))

        # Perception recovery: pan and search
        self.register(RecoveryBehavior(
            name="perception_pan_search",
            recovery_type=RecoveryType.SEARCH,
            applicable_errors=['OBJECT_LOST', 'DETECTION_FAILED'],
            execute=self._perception_pan_search,
            timeout_sec=20.0,
            description="Pan camera to search for object"
        ))

        # Perception recovery: move closer
        self.register(RecoveryBehavior(
            name="perception_move_closer",
            recovery_type=RecoveryType.REPOSITION,
            applicable_errors=['OBJECT_TOO_FAR', 'DETECTION_LOW_CONFIDENCE'],
            execute=self._perception_move_closer,
            timeout_sec=30.0,
            description="Move 0.5m closer to target area"
        ))

        # General recovery: safe stop
        self.register(RecoveryBehavior(
            name="safe_stop",
            recovery_type=RecoveryType.SAFE_STOP,
            applicable_errors=['COLLISION_IMMINENT', 'HARDWARE_ERROR', 'CRITICAL'],
            execute=self._safe_stop,
            timeout_sec=5.0,
            description="Immediate safe stop"
        ))

        # Human intervention
        self.register(RecoveryBehavior(
            name="ask_human",
            recovery_type=RecoveryType.ASK_HUMAN,
            applicable_errors=['REPEATED_FAILURE', 'UNKNOWN_ERROR'],
            execute=self._ask_human,
            timeout_sec=60.0,
            description="Request human assistance"
        ))

    def register(self, behavior: RecoveryBehavior):
        """Register a recovery behavior."""
        self.behaviors[behavior.name] = behavior

    def get_recovery(
        self,
        error_code: str,
        preferred_type: Optional[RecoveryType] = None
    ) -> Optional[RecoveryBehavior]:
        """
        Get appropriate recovery behavior for an error.

        Args:
            error_code: The error code to recover from
            preferred_type: Preferred recovery type (optional)

        Returns:
            Matching recovery behavior or None
        """
        candidates = []

        for behavior in self.behaviors.values():
            if error_code in behavior.applicable_errors:
                candidates.append(behavior)

        if not candidates:
            return None

        # Filter by preferred type if specified
        if preferred_type:
            typed = [b for b in candidates if b.recovery_type == preferred_type]
            if typed:
                return typed[0]

        return candidates[0]

    def execute_recovery(
        self,
        error_code: str,
        context: Dict
    ) -> bool:
        """
        Execute appropriate recovery for an error.

        Args:
            error_code: The error to recover from
            context: Current context for recovery

        Returns:
            True if recovery succeeded
        """
        behavior = self.get_recovery(error_code)

        if not behavior:
            print(f"[RECOVERY] No recovery behavior for: {error_code}")
            return False

        print(f"[RECOVERY] Executing: {behavior.name}")
        print(f"[RECOVERY] Description: {behavior.description}")

        try:
            success = behavior.execute(context)
            print(f"[RECOVERY] Result: {'Success' if success else 'Failed'}")
            return success
        except Exception as e:
            print(f"[RECOVERY] Error during recovery: {e}")
            return False

    # Recovery implementations
    def _nav_backup_retry(self, context: Dict) -> bool:
        """Back up and retry navigation."""
        # Back up 0.5 meters
        self.robot.move_relative(x=-0.5, y=0, theta=0)
        time.sleep(2.0)

        # Retry navigation to original goal
        goal = context.get('goal_pose')
        if goal:
            return self.robot.navigate_to(goal)
        return False

    def _nav_rotate_scan(self, context: Dict) -> bool:
        """Rotate to update costmap."""
        # Rotate 360 degrees slowly
        for _ in range(4):
            self.robot.rotate(90)  # degrees
            time.sleep(1.0)
        return True

    def _grasp_release_retry(self, context: Dict) -> bool:
        """Release and retry grasp."""
        # Open gripper
        self.robot.open_gripper()
        time.sleep(0.5)

        # Move arm up slightly
        self.robot.move_arm_relative(z=0.1)
        time.sleep(0.5)

        # Move back down and try again
        self.robot.move_arm_relative(z=-0.1)
        self.robot.close_gripper()

        return self.robot.gripper_holding()

    def _grasp_side_approach(self, context: Dict) -> bool:
        """Try grasp from side."""
        object_pos = context.get('object_position')
        if not object_pos:
            return False

        # Move to side approach position
        side_pos = {
            'x': object_pos['x'] + 0.15,
            'y': object_pos['y'],
            'z': object_pos['z']
        }

        self.robot.move_arm_to(side_pos, orientation='horizontal')
        self.robot.close_gripper()

        return self.robot.gripper_holding()

    def _perception_pan_search(self, context: Dict) -> bool:
        """Pan camera to search for object."""
        target = context.get('target_object')

        # Pan left, center, right
        for pan_angle in [-30, 0, 30]:
            self.robot.pan_camera(pan_angle)
            time.sleep(1.0)

            detected = self.robot.detect_object(target)
            if detected:
                return True

        return False

    def _perception_move_closer(self, context: Dict) -> bool:
        """Move closer to target area."""
        target_area = context.get('target_area', {'x': 1.0, 'y': 0.0})

        # Calculate position 0.5m closer
        # Simplified - real implementation would use proper geometry
        self.robot.move_relative(x=0.3, y=0, theta=0)

        return True

    def _safe_stop(self, context: Dict) -> bool:
        """Immediate safe stop."""
        self.robot.emergency_stop()
        self.robot.open_gripper()
        return True

    def _ask_human(self, context: Dict) -> bool:
        """Request human assistance."""
        message = f"I need help with: {context.get('failed_step', 'current task')}"
        self.robot.speak(message)
        self.robot.play_attention_sound()

        # Wait for human acknowledgment
        # In real implementation, would wait for confirmation
        time.sleep(5.0)
        return True


# Placeholder robot interface
class RobotInterface:
    """Placeholder for actual robot interface."""
    def move_relative(self, x, y, theta): pass
    def navigate_to(self, goal): return True
    def rotate(self, degrees): pass
    def open_gripper(self): pass
    def close_gripper(self): pass
    def gripper_holding(self): return True
    def move_arm_relative(self, z): pass
    def move_arm_to(self, pos, orientation): pass
    def pan_camera(self, angle): pass
    def detect_object(self, target): return True
    def emergency_stop(self): pass
    def speak(self, message): pass
    def play_attention_sound(self): pass
```

---

## Putting It All Together

### Complete Error Handling Pipeline

```python
# File: complete_error_handling.py
# Purpose: Integrated error handling and replanning system

from typing import Dict, List, Optional
from dataclasses import dataclass
import time


class IntegratedErrorHandler:
    """
    Complete error handling system integrating:
    - Error detection
    - Replanning triggers
    - Recovery behaviors
    - LLM replanning
    """

    def __init__(
        self,
        node: 'rclpy.Node',
        llm_planner: 'LLMPlanner',
        robot: 'RobotInterface'
    ):
        """Initialize integrated handler."""
        self.node = node

        # Initialize components
        self.detector = ErrorDetector(node)
        self.trigger_manager = ReplanningTriggerManager()
        self.recovery_library = RecoveryBehaviorLibrary(robot)
        self.prompt_builder = ReplanPromptBuilder()
        self.llm_planner = llm_planner

        # State
        self.current_task: Optional[Dict] = None
        self.is_recovering = False

    def handle_action_result(
        self,
        action_name: str,
        goal_handle: 'ClientGoalHandle',
        result: any,
        context: Dict
    ) -> Dict:
        """
        Handle action completion, detecting and recovering from errors.

        Args:
            action_name: Name of completed action
            goal_handle: ROS action goal handle
            result: Action result
            context: Current task context

        Returns:
            Handler result with next action or recovery status
        """
        self.current_task = context

        # Step 1: Detect errors
        error = self.detector.detect_action_failure(
            goal_handle,
            action_name,
            context.get('expected_duration', 30.0)
        )

        if not error:
            # No error - action succeeded
            return {
                'status': 'success',
                'continue': True,
                'next_action': context.get('next_action')
            }

        # Step 2: Determine recovery strategy
        self.is_recovering = True

        decision, replan_context = self.trigger_manager.evaluate(
            error,
            action_name,
            context
        )

        print(f"[ERROR_HANDLER] Error: {error.code}")
        print(f"[ERROR_HANDLER] Decision: {decision.value}")

        # Step 3: Execute recovery
        if decision == ReplanningDecision.RETRY_SAME:
            return self._handle_retry(action_name, context, modified=False)

        elif decision == ReplanningDecision.RETRY_MODIFIED:
            return self._handle_retry(action_name, context, modified=True)

        elif decision == ReplanningDecision.REPLAN_PARTIAL:
            return self._handle_replan(replan_context, partial=True)

        elif decision == ReplanningDecision.REPLAN_FULL:
            return self._handle_replan(replan_context, partial=False)

        elif decision == ReplanningDecision.ASK_HUMAN:
            return self._handle_human_request(error, context)

        else:  # ABORT_TASK
            return self._handle_abort(error)

    def _handle_retry(
        self,
        action_name: str,
        context: Dict,
        modified: bool
    ) -> Dict:
        """Handle retry strategy."""
        # Try pre-defined recovery behavior first
        recovery_success = self.recovery_library.execute_recovery(
            context.get('last_error_code', 'UNKNOWN'),
            context
        )

        if recovery_success or not modified:
            return {
                'status': 'retry',
                'action': action_name,
                'params': self._modify_params(context) if modified else context.get('params'),
                'continue': True
            }

        return {
            'status': 'recovery_failed',
            'continue': False
        }

    def _handle_replan(
        self,
        context: 'ReplanContext',
        partial: bool
    ) -> Dict:
        """Handle LLM replanning."""
        # Determine failure type for specialized prompt
        failure_type = self._classify_failure(context.error_details)

        # Build prompt
        prompt = self.prompt_builder.build(context, failure_type)

        # Get new plan from LLM
        try:
            new_plan = self.llm_planner.generate_plan(prompt)

            return {
                'status': 'replanned',
                'new_plan': new_plan,
                'partial': partial,
                'completed_steps': context.completed_steps if partial else [],
                'continue': True
            }
        except Exception as e:
            print(f"[ERROR_HANDLER] Replanning failed: {e}")
            return {
                'status': 'replan_failed',
                'continue': False
            }

    def _handle_human_request(
        self,
        error: 'DetectedError',
        context: Dict
    ) -> Dict:
        """Request human intervention."""
        self.recovery_library.execute_recovery('REPEATED_FAILURE', {
            'failed_step': context.get('current_step'),
            'error': error.message
        })

        return {
            'status': 'awaiting_human',
            'error': error.message,
            'continue': False
        }

    def _handle_abort(self, error: 'DetectedError') -> Dict:
        """Handle task abortion."""
        # Execute safe stop
        self.recovery_library.execute_recovery('CRITICAL', {})

        return {
            'status': 'aborted',
            'error': error.message,
            'continue': False
        }

    def _modify_params(self, context: Dict) -> Dict:
        """Modify action parameters for retry."""
        params = context.get('params', {}).copy()

        # Apply modifications based on error type
        error_code = context.get('last_error_code', '')

        if 'GRASP' in error_code:
            # Adjust grasp parameters
            params['approach_offset'] = params.get('approach_offset', 0) + 0.02
            params['grasp_force'] = params.get('grasp_force', 30) * 1.1

        elif 'NAV' in error_code:
            # Adjust navigation parameters
            params['tolerance'] = params.get('tolerance', 0.1) * 1.5

        return params

    def _classify_failure(self, error_details: Dict) -> str:
        """Classify failure type for prompt selection."""
        category = error_details.get('category', '')

        if category == 'navigation':
            return 'navigation_failure'
        elif category == 'manipulation':
            return 'grasp_failure'
        elif category == 'perception':
            return 'perception_failure'
        else:
            return 'generic_failure'

    def reset(self):
        """Reset handler for new task."""
        self.trigger_manager.reset_for_new_task()
        self.detector.clear_history()
        self.is_recovering = False
        self.current_task = None
```

**Expected Output** (complete error handling flow):
```
[ERROR_HANDLER] Error: GRASP_FAILED
[ERROR_HANDLER] Decision: retry_modified
[RECOVERY] Executing: grasp_release_retry
[RECOVERY] Description: Open gripper, reposition, retry
[RECOVERY] Result: Failed
[ERROR_HANDLER] Error: GRASP_FAILED
[ERROR_HANDLER] Decision: replan_partial
[REPLANNING] Building prompt for: grasp_failure
[REPLANNING] LLM generated 4 alternative steps
[ERROR_HANDLER] Status: replanned
```

---

## Connection to Capstone

This section directly supports the capstone project by:

| Capstone Component | How This Section Helps |
|-------------------|------------------------|
| **Voice Command** | Handles ASR errors and requests clarification |
| **Planning** | Enables recovery when plans fail mid-execution |
| **Navigation** | Recovers from blocked paths, timeout, and localization errors |
| **Manipulation** | Recovers from failed grasps with alternative approaches |

```
┌─────────────────────────────────────────────────────────────────┐
│                    CAPSTONE PIPELINE                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Voice ──▶ Plan ──▶ Navigate ──▶ Vision ──▶ Manipulate         │
│    │         │          │          │           │                │
│    └─────────┴──────────┴──────────┴───────────┴────────────── │
│                          │                                      │
│              ┌───────────▼───────────┐                          │
│              │   ERROR HANDLING &    │                          │
│              │     REPLANNING        │                          │
│              │    [THIS SECTION]     │                          │
│              └───────────────────────┘                          │
│                                                                 │
│  Every stage can fail → Error detection catches it              │
│  Every failure can be recovered → Replanning fixes it           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Summary

In this section, you learned:
- **Error detection** captures failures across navigation, manipulation, and perception subsystems
- **Replanning triggers** intelligently decide between retry, replan, and abort strategies
- **LLM replan prompts** provide rich context enabling the model to generate alternative approaches
- **Recovery behaviors** offer fast, pre-defined responses to common failures

**Key Patterns to Remember**:
```python
# Error detection pattern
error = detector.detect_action_failure(goal_handle, action_name, timeout)
if error:
    decision, context = trigger_manager.evaluate(error, step, task_context)

# Replanning pattern
prompt = prompt_builder.build(context, failure_type)
new_plan = llm_planner.generate_plan(prompt)

# Recovery pattern
recovery = library.get_recovery(error_code)
recovery.execute(context)
```

---

## Practice Exercises

### Exercise 1: Basic Error Detection
Extend the `ErrorDetector` class to detect a new error type: `BATTERY_LOW`. The error should trigger when battery level drops below 20% and become `CRITICAL` below 10%.

### Exercise 2: Custom Recovery Behavior
Implement a recovery behavior called `manipulation_two_hand_grasp` that attempts to use both arms to grasp a large object when single-arm grasp fails.

### Exercise 3: Advanced Replanning
Create a replan prompt template for `communication_failure` - when the robot loses connection to a remote service. The prompt should consider local-only alternatives.

---

## Troubleshooting

| Problem | Cause | Solution |
|---------|-------|----------|
| "Recovery keeps retrying indefinitely" | Max retries not configured | Set `max_retries` in trigger manager config |
| "LLM replan takes too long" | Full context in every prompt | Use partial replanning with incremental context |
| "Same error keeps recurring after replan" | Constraints not passed to LLM | Include failed attempts in `constraints` field |
| "Robot stops after any error" | All errors marked CRITICAL | Review severity classification logic |

---

## What's Next?

In the next section, **Safety Constraints and Guardrails**, you will learn:
- How to enforce safety limits on all robot actions
- Implementing ethical constraints in robot behavior
- Building fail-safe mechanisms for human-robot interaction

This will ensure your replanning system generates only **safe** alternative plans, preventing dangerous recovery attempts.

---

## Further Reading

- [ROS 2 Action Design](https://design.ros2.org/articles/actions.html) - Understanding action feedback and cancellation
- [Behavior Trees in Robotics](https://arxiv.org/abs/1709.00084) - Failure handling in BT frameworks
- [LLM Agents for Robotics](https://arxiv.org/abs/2305.00991) - Survey of language models in robot planning

:::info Industry Insight
Amazon Robotics systems process error recovery decisions in under 100ms using a tiered approach: hardware safety stops are instantaneous, pre-defined recoveries execute in under 1 second, and LLM replanning is reserved for truly novel situations. Your capstone should follow a similar tiered architecture.
:::
