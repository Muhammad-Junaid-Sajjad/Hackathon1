---
id: m4-c2-s7
title: Hierarchical Task Networks
sidebar_position: 7
keywords: ['htn', 'hierarchical', 'task', 'planning']
---

# Hierarchical Task Networks

Hierarchical Task Networks (HTN) provide a structured approach to task decomposition, organizing complex goals into subtask hierarchies. This section covers HTN planning fundamentals, domain definition, and integration with humanoid robot task execution.

For humanoid robots, HTN planning excels at household tasks with clear procedural structure, like cooking or cleaning, where tasks naturally decompose into ordered subtasks.

## Prerequisites

Before starting this section, you should:
- Understand LLM-based planning from M4-C2-S1 and M4-C2-S2
- Be familiar with error handling and replanning from M4-C2-S5
- Know Python dataclasses, enums, and recursive data structures
- Have working knowledge of tree traversal algorithms
- Understand task execution and monitoring patterns

## Learning Objectives

| Level | Objective |
|-------|-----------|
| **[Beginner]** | Define HTN planning and explain how tasks decompose into subtasks |
| **[Beginner]** | Identify when HTN planning is preferable to flat action sequences |
| **[Intermediate]** | Implement HTN domains with operators and decomposition methods |
| **[Intermediate]** | Configure task execution with monitoring and failure handling |
| **[Advanced]** | Architect scalable HTN systems for complex multi-step tasks |
| **[Advanced]** | Design domain-specific planners for household robotics applications |

## Key Concepts

| Term | Definition |
|------|------------|
| **Task** | A unit of work that can be primitive (directly executable) or compound (decomposable) |
| **Operator** | A primitive action the robot can execute directly (e.g., grasp, move) |
| **Method** | A recipe for decomposing a compound task into subtasks |
| **Precondition** | A condition that must be true for a method or operator to be applicable |
| **HTN Domain** | The complete specification of operators and methods for a planning problem |
| **Task Decomposition** | The process of breaking compound tasks into primitive actions |
| **Ordered Subtasks** | Subtasks that must execute sequentially (vs. parallel) |
| **Plan Monitoring** | Runtime tracking of task execution with callbacks for events |

## HTN Planning Fundamentals

### Domain and Task Representation

```python
# Hierarchical Task Network planning for humanoid robots
import time
from typing import Dict, List, Optional, Tuple, Set
from dataclasses import dataclass, field
from enum import Enum
from abc import ABC, abstractmethod
import json


class TaskStatus(Enum):
    """Status of task execution."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"


@dataclass
class Task:
    """Individual task in HTN."""
    name: str
    task_type: str
    parameters: Dict = field(default_factory=dict)
    status: TaskStatus = TaskStatus.PENDING
    subtasks: List['Task'] = field(default_factory=list)
    parent: Optional['Task'] = None
    start_time: float = 0
    end_time: float = 0

    def add_subtask(self, subtask: 'Task'):
        """Add subtask with parent reference."""
        subtask.parent = self
        self.subtasks.append(subtask)

    def is_leaf(self) -> bool:
        """Check if task has no subtasks."""
        return len(self.subtasks) == 0


@dataclass
class Method:
    """HTN method for decomposing a task."""
    name: str
    task_name: str  # Task this method applies to
    preconditions: List[str]  # Conditions that must be true
    subtasks: List[Dict]  # Subtask definitions
    ordered: bool = True  # Whether subtasks must be ordered

    def applicable(self, state: Dict) -> bool:
        """Check if method is applicable."""
        for precond in self.preconditions:
            if not self._check_condition(precond, state):
                return False
        return True

    def _check_condition(self, condition: str, state: Dict) -> bool:
        """Check a single condition."""
        # Parse condition like "holding:cup"
        if ':' in condition:
            key, value = condition.split(':', 1)
            return state.get(key) == value

        # Boolean condition
        return state.get(condition, False)


@dataclass
class Operator:
    """HTN operator (primitive action)."""
    name: str
    parameters: List[str]
    preconditions: List[str]
    effects: List[str]  # List of "key:value" or "key:removed"

    def applicable(self, state: Dict) -> bool:
        """Check if operator preconditions are met."""
        for precond in self.preconditions:
            if ':' in precond:
                key, value = precond.split(':', 1)
                if state.get(key) != value:
                    return False
            elif not state.get(precond, False):
                return False
        return True

    def apply(self, state: Dict) -> Dict:
        """Apply operator effects to state."""
        new_state = state.copy()

        for effect in self.effects:
            if effect.startswith('-'):
                # Remove predicate
                key = effect[1:]
                new_state.pop(key, None)
            elif ':' in effect:
                # Add/update predicate
                key, value = effect.split(':', 1)
                new_state[key] = value

        return new_state


class HTNPlanner:
    """
    Hierarchical Task Network planner for robot tasks.
    """

    def __init__(self):
        """Initialize HTN planner."""
        self.methods: Dict[str, List[Method]] = {}
        self.operators: Dict[str, Operator] = {}
        self.primitive_tasks: Set[str] = set()

        # Initialize default domain
        self._init_default_domain()

    def _init_default_domain(self):
        """Initialize default robot domain."""
        # Define operators
        self.add_operator(Operator(
            name="navigate_to",
            parameters=['location'],
            preconditions=['at:current'],
            effects=['at:location', '-at:current']
        ))

        self.add_operator(Operator(
            name="grasp",
            parameters=['object'],
            preconditions=['at:object_location', 'gripper:empty'],
            effects=['holding:object', '-gripper:empty', 'object_location:cleared']
        ))

        self.add_operator(Operator(
            name="place",
            parameters=['object', 'surface'],
            preconditions=['holding:object', 'at:surface'],
            effects=['-holding:object', 'gripper:empty', 'object_on:surface']
        ))

        self.add_operator(Operator(
            name="open",
            parameters=['container'],
            preconditions=['at:container', 'container:closed'],
            effects=['container:open', '-container:closed']
        ))

        self.add_operator(Operator(
            name="close",
            parameters=['container'],
            preconditions=['container:open'],
            effects=['-container:open', 'container:closed']
        ))

        self.add_operator(Operator(
            name="speak",
            parameters=['message'],
            preconditions=[],
            effects=['said:message']
        ))

        self.add_operator(Operator(
            name="observe",
            parameters=[],
            preconditions=[],
            effects=['observed:true']
        ))

        # Define methods
        self.add_method(Method(
            name="fetch_object",
            task_name="fetch",
            preconditions=['object_type:known', 'object_location:known'],
            subtasks=[
                {'task': 'navigate_to', 'params': {'location': '${object_location}'}},
                {'task': 'grasp', 'params': {'object': '${object}'}},
                {'task': 'navigate_to', 'params': {'location': 'destination'}}
            ]
        ))

        self.add_method(Method(
            name="set_table",
            task_name="set_table",
            preconditions=[],
            subtasks=[
                {'task': 'fetch_plates', 'params': {}},
                {'task': 'fetch_utensils', 'params': {}},
                {'task': 'place_items', 'params': {}}
            ],
            ordered=True
        ))

        self.add_method(Method(
            name="fetch_plates",
            task_name="fetch_plates",
            preconditions=[],
            subtasks=[
                {'task': 'navigate_to', 'params': {'location': 'kitchen'}},
                {'task': 'open', 'params': {'container': 'cabinet'}},
                {'task': 'grasp', 'params': {'object': 'plate'}},
                {'task': 'close', 'params': {'container': 'cabinet'}}
            ]
        ))

        self.add_method(Method(
            name="cleanup_room",
            task_name="cleanup",
            preconditions=[],
            subtasks=[
                {'task': 'collect_items', 'params': {}},
                {'task': 'dispose_waste', 'params': {}},
                {'task': 'organize_items', 'params': {}}
            ],
            ordered=True
        ))

        # Mark primitive tasks
        self.primitive_tasks = {
            'navigate_to', 'grasp', 'place', 'open', 'close',
            'speak', 'observe'
        }

    def add_method(self, method: Method):
        """Add a method to the domain."""
        if method.task_name not in self.methods:
            self.methods[method.task_name] = []
        self.methods[method.task_name].append(method)

    def add_operator(self, operator: Operator):
        """Add an operator to the domain."""
        self.operators[operator.name] = operator

    def decompose(self, task: Task, state: Dict,
                  max_depth: int = 10) -> Tuple[bool, Task, Dict]:
        """
        Decompose a task into subtasks.

        Args:
            task: Task to decompose
            state: Current world state
            max_depth: Maximum decomposition depth

        Returns:
            (success, decomposed_task, final_state)
        """
        if max_depth <= 0:
            return False, task, state

        # Check if task is primitive
        if task.name in self.primitive_tasks:
            return True, task, state

        # Find applicable method
        applicable_methods = [
            m for m in self.methods.get(task.name, [])
            if m.applicable(state)
        ]

        if not applicable_methods:
            return False, task, state

        # Use first applicable method
        method = applicable_methods[0]

        # Create subtasks from method
        for subtask_def in method.subtasks:
            subtask = Task(
                name=subtask_def['task'],
                task_type=subtask_def['task'],
                parameters=subtask_def.get('params', {})
            )
            task.add_subtask(subtask)

        # Recursively decompose subtasks
        current_state = state
        for subtask in task.subtasks:
            success, subtask, current_state = self.decompose(
                subtask, current_state, max_depth - 1
            )
            if not success:
                return False, task, current_state

        return True, task, current_state

    def plan(self, task: Task, initial_state: Dict) -> Tuple[bool, Task, Dict]:
        """
        Create a complete plan from high-level task.

        Args:
            task: High-level task to plan
            initial_state: Initial world state

        Returns:
            (success, decomposed_task, final_state)
        """
        # Decompose task hierarchy
        success, task, state = self.decompose(task, initial_state)

        if not success:
            return False, task, initial_state

        return True, task, state

    def execute_plan(self, task: Task, executor) -> Dict:
        """
        Execute a decomposed plan.

        Args:
            task: Root task of plan
            executor: Execution engine

        Returns:
            Execution result
        """
        results = {
            'success': True,
            'completed_tasks': [],
            'failed_tasks': [],
            'final_state': {}
        }

        def execute_task(t: Task):
            """Recursively execute task."""
            t.status = TaskStatus.IN_PROGRESS
            t.start_time = time.time()

            if t.is_leaf():
                # Primitive task - execute
                try:
                    success = executor.execute(t)
                    if success:
                        t.status = TaskStatus.COMPLETED
                        results['completed_tasks'].append(t.name)
                    else:
                        t.status = TaskStatus.FAILED
                        results['failed_tasks'].append(t.name)
                        results['success'] = False
                except Exception as e:
                    t.status = TaskStatus.FAILED
                    results['failed_tasks'].append(t.name)
                    results['success'] = False
            else:
                # Compound task - execute subtasks
                for subtask in t.subtasks:
                    if not results['success']:
                        subtask.status = TaskStatus.SKIPPED
                        continue
                    execute_task(subtask)

            t.end_time = time.time()

        execute_task(task)

        return results


class TaskExecutor:
    """
    Execute primitive robot tasks.
    """

    def __init__(self, robot_controller):
        """Initialize executor with robot controller."""
        self.robot = robot_controller

    def execute(self, task: Task) -> bool:
        """Execute a primitive task."""
        task_name = task.name
        params = task.parameters

        if task_name == 'navigate_to':
            return self._navigate_to(params.get('location'))

        elif task_name == 'grasp':
            return self._grasp(params.get('object'))

        elif task_name == 'place':
            return self._place(params.get('object'), params.get('surface'))

        elif task_name == 'open':
            return self._open(params.get('container'))

        elif task_name == 'close':
            return self._close(params.get('container'))

        elif task_name == 'speak':
            return self._speak(params.get('message'))

        elif task_name == 'observe':
            return self._observe()

        else:
            print(f"Unknown task: {task_name}")
            return False

    def _navigate_to(self, location: str) -> bool:
        """Navigate to location."""
        # Would call robot navigation
        print(f"Navigating to {location}")
        return True

    def _grasp(self, obj: str) -> bool:
        """Grasp object."""
        print(f"Grasping {obj}")
        return True

    def _place(self, obj: str, surface: str) -> bool:
        """Place object on surface."""
        print(f"Placing {obj} on {surface}")
        return True

    def _open(self, container: str) -> bool:
        """Open container."""
        print(f"Opening {container}")
        return True

    def _close(self, container: str) -> bool:
        """Close container."""
        print(f"Closing {container}")
        return True

    def _speak(self, message: str) -> bool:
        """Speak message."""
        print(f"Speaking: {message}")
        return True

    def _observe(self) -> bool:
        """Observe environment."""
        print("Observing environment")
        return True
```

## HTN Domain Construction

### Building Robot Task Domains

```python
# HTN domain construction utilities
from typing import Dict, List, Optional
import json


class HTNDomainBuilder:
    """
    Builder for HTN domains.
    Simplifies domain creation for robot tasks.
    """

    def __init__(self):
        """Initialize domain builder."""
        self.methods: List[Dict] = []
        self.operators: List[Dict] = []
        self.types: Dict[str, List[str]] = {}

    def add_type(self, type_name: str, subtypes: List[str] = None):
        """Add a type to the domain."""
        self.types[type_name] = subtypes or []

    def add_operator(self, name: str, parameters: List[str],
                     preconditions: List[str], effects: List[str]):
        """Add an operator to the domain."""
        self.operators.append({
            'name': name,
            'parameters': parameters,
            'preconditions': preconditions,
            'effects': effects
        })

    def add_method(self, name: str, task: str,
                   preconditions: List[str],
                   subtasks: List[Dict],
                   ordered: bool = True):
        """Add a method to the domain."""
        self.methods.append({
            'name': name,
            'task': task,
            'preconditions': preconditions,
            'subtasks': subtasks,
            'ordered': ordered
        })

    def to_json(self) -> str:
        """Export domain as JSON."""
        return json.dumps({
            'types': self.types,
            'operators': self.operators,
            'methods': self.methods
        }, indent=2)

    def create_kitchen_domain(self):
        """Create HTN domain for kitchen tasks."""
        # Types
        self.add_type('location', ['kitchen', 'dining_room', 'living_room'])
        self.add_type('container', ['cabinet', 'drawer', 'fridge', 'microwave'])
        self.add_type('utensil', ['fork', 'knife', 'spoon', 'spatula'])
        self.add_type('dish', ['plate', 'bowl', 'cup', 'mug'])

        # Operators
        self.add_operator(
            'navigate',
            ['destination'],
            ['can_navigate'],
            ['at:destination', '-at:previous']
        )

        self.add_operator(
            'pick_up',
            ['object'],
            ['at:object', 'gripper:empty'],
            ['holding:object', '-gripper:empty']
        )

        self.add_operator(
            'put_down',
            ['object', 'surface'],
            ['holding:object', 'at:surface'],
            ['-holding:object', 'gripper:empty', 'on_surface:object']
        )

        self.add_operator(
            'open_container',
            ['container'],
            ['at:container', 'container:closed'],
            ['container:open', '-container:closed']
        )

        self.add_operator(
            'close_container',
            ['container'],
            ['container:open'],
            ['-container:open', 'container:closed']
        )

        # Methods
        self.add_method(
            'make_sandwich',
            'make_sandwich',
            [],
            [
                {'task': 'gather_ingredients', 'params': {}},
                {'task': 'assemble_sandwich', 'params': {}}
            ],
            ordered=True
        )

        self.add_method(
            'gather_ingredients',
            'gather_ingredients',
            [],
            [
                {'task': 'navigate', 'params': {'destination': 'fridge'}},
                {'task': 'open_container', 'params': {'container': 'fridge'}},
                {'task': 'pick_up', 'params': {'object': 'bread'}},
                {'task': 'pick_up', 'params': {'object': 'cheese'}},
                {'task': 'close_container', 'params': {'container': 'fridge'}}
            ],
            ordered=True
        )

        self.add_method(
            'wash_dishes',
            'wash_dishes',
            [],
            [
                {'task': 'navigate', 'params': {'destination': 'sink'}},
                {'task': 'collect_dishes', 'params': {}},
                {'task': 'wash_items', 'params': {}},
                {'task': 'dry_items', 'params': {}},
                {'task': 'put_away', 'params': {}}
            ],
            ordered=True
        )

        return self

    def create_assistance_domain(self):
        """Create HTN domain for assistance tasks."""
        # Operators for assistance
        self.add_operator(
            'approach_human',
            ['human_id'],
            [],
            ['near:human_id']
        )

        self.add_operator(
            'listen_request',
            ['human_id'],
            ['near:human_id'],
            ['heard:request']
        )

        self.add_operator(
            'confirm_understanding',
            [],
            ['heard:request'],
            ['user:confirmed']
        )

        self.add_operator(
            'perform_task',
            ['task_name'],
            ['user:confirmed'],
            ['task:completed']
        )

        self.add_operator(
            'report_completion',
            [],
            ['task:completed'],
            ['user:notified']
        )

        # Methods
        self.add_method(
            'assist_human',
            'assist',
            [],
            [
                {'task': 'approach_human', 'params': {'human_id': 'user'}},
                {'task': 'listen_request', 'params': {'human_id': 'user'}},
                {'task': 'confirm_understanding', 'params': {}},
                {'task': 'perform_task', 'params': {'task_name': '${task}'}},
                {'task': 'report_completion', 'params': {}}
            ],
            ordered=True
        )

        return self


def create_task_from_template(template: Dict) -> Task:
    """
    Create a task from template definition.

    Args:
        template: Task template with name, type, and parameters

    Returns:
        Task object
    """
    return Task(
        name=template.get('name', 'unknown'),
        task_type=template.get('type', 'primitive'),
        parameters=template.get('parameters', {})
    )


def load_domain_from_file(filepath: str) -> HTNDomainBuilder:
    """Load HTN domain from JSON file."""
    with open(filepath, 'r') as f:
        data = json.load(f)

    builder = HTNDomainBuilder()
    builder.types = data.get('types', {})
    builder.operators = data.get('operators', [])
    builder.methods = data.get('methods', [])

    return builder
```

## Plan Execution and Monitoring

### Executing and Monitoring HTN Plans

```python
# HTN plan execution and monitoring
from typing import Dict, List, Optional, Callable
from dataclasses import dataclass
from enum import Enum
import time


class ExecutionState(Enum):
    """Plan execution states."""
    PENDING = "pending"
    RUNNING = "running"
    PAUSED = "paused"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


@dataclass
class ExecutionConfig:
    """Configuration for plan execution."""
    timeout_seconds: float = 300.0
    retry_failed: bool = True
    max_retries: int = 3
    pause_on_failure: bool = False


class HTNExecutor:
    """
    Execute and monitor HTN plans.
    """

    def __init__(self, executor: TaskExecutor,
                 config: ExecutionConfig = None):
        """Initialize executor."""
        self.task_executor = executor
        self.config = config or ExecutionConfig()

        self.state = ExecutionState.PENDING
        self.start_time = 0
        self.task_log: List[Dict] = []

    def execute(self, root_task: Task) -> Dict:
        """
        Execute a complete HTN plan.

        Args:
            root_task: Root task of decomposed plan

        Returns:
            Execution result
        """
        self.state = ExecutionState.RUNNING
        self.start_time = time.time()
        self.task_log = []

        result = self._execute_task(root_task)

        if result['success']:
            self.state = ExecutionState.COMPLETED
        else:
            self.state = ExecutionState.FAILED

        return {
            'success': result['success'],
            'state': self.state.value,
            'duration': time.time() - self.start_time,
            'tasks_executed': len([t for t in self.task_log if t['status'] == 'completed']),
            'tasks_failed': len([t for t in self.task_log if t['status'] == 'failed']),
            'task_log': self.task_log
        }

    def _execute_task(self, task: Task, depth: int = 0) -> Dict:
        """Recursively execute task."""
        if time.time() - self.start_time > self.config.timeout_seconds:
            return {'success': False, 'reason': 'timeout'}

        task_record = {
            'task': task.name,
            'parameters': task.parameters,
            'status': 'pending',
            'start_time': time.time(),
            'subtasks': []
        }

        if task.is_leaf():
            # Primitive task
            success = self._execute_primitive(task)
            task_record['status'] = 'completed' if success else 'failed'
        else:
            # Compound task - execute subtasks
            subtask_results = []
            for subtask in task.subtasks:
                if not self.task_executor:  # Check parent success
                    subtask_record = {
                        'task': subtask.name,
                        'status': 'skipped'
                    }
                    subtask_results.append(subtask_record)
                    continue

                result = self._execute_task(subtask, depth + 1)
                subtask_results.append(result)

                if not result['success'] and self.config.pause_on_failure:
                    break

            all_success = all(r['success'] for r in subtask_results)
            task_record['status'] = 'completed' if all_success else 'failed'
            task_record['subtasks'] = subtask_results

        task_record['duration'] = time.time() - task_record['start_time']
        self.task_log.append(task_record)

        return {
            'success': task_record['status'] == 'completed',
            'reason': task_record.get('reason')
        }

    def _execute_primitive(self, task: Task) -> bool:
        """Execute a primitive task."""
        try:
            return self.task_executor.execute(task)
        except Exception as e:
            print(f"Task execution failed: {e}")
            return False

    def pause(self):
        """Pause execution."""
        self.state = ExecutionState.PAUSED

    def resume(self):
        """Resume execution."""
        if self.state == ExecutionState.PAUSED:
            self.state = ExecutionState.RUNNING

    def cancel(self):
        """Cancel execution."""
        self.state = ExecutionState.CANCELLED


class PlanMonitor:
    """
    Monitor HTN plan execution with callbacks.
    """

    def __init__(self, executor: HTNExecutor):
        """Initialize monitor."""
        self.executor = executor
        self.callbacks: Dict[str, List[Callable]] = {
            'task_start': [],
            'task_complete': [],
            'task_fail': [],
            'plan_complete': [],
            'plan_fail': []
        }

    def on_task_start(self, callback: Callable):
        """Register task start callback."""
        self.callbacks['task_start'].append(callback)

    def on_task_complete(self, callback: Callable):
        """Register task complete callback."""
        self.callbacks['task_complete'].append(callback)

    def on_plan_complete(self, callback: Callable):
        """Register plan complete callback."""
        self.callbacks['plan_complete'].append(callback)

    def execute_with_monitoring(self, root_task: Task) -> Dict:
        """Execute plan with monitoring callbacks."""
        # Wrap execution with callbacks
        original_execute = self.executor._execute_primitive

        def wrapped_execute(task):
            # Task start callback
            for cb in self.callbacks['task_start']:
                cb(task)

            result = original_execute(task)

            # Task complete/fail callback
            if result:
                for cb in self.callbacks['task_complete']:
                    cb(task)
            else:
                for cb in self.callbacks['task_fail']:
                    cb(task)

            return result

        self.executor._execute_primitive = wrapped_execute

        # Execute
        result = self.executor.execute(root_task)

        # Plan complete/fail callback
        if result['success']:
            for cb in self.callbacks['plan_complete']:
                cb(result)
        else:
            for cb in self.callbacks['plan_fail']:
                cb(result)

        return result
```

## Connection to Capstone

| Capstone Stage | How This Section Helps |
|----------------|------------------------|
| **Voice** | HTN provides the structure for decomposing verbal commands into executable steps |
| **Plan** | HTN methods define how high-level goals become primitive robot actions |
| **Execute** | Task monitoring tracks progress through the decomposed plan hierarchy |
| **Recover** | Subtask failures trigger method re-selection or task replanning |

:::tip Capstone Integration
Your humanoid uses HTN as the backbone of task execution:
1. **Parse command** → "make coffee" becomes root task
2. **Select method** → choose decomposition based on kitchen state
3. **Expand subtasks** → get_cup, fill_water, add_coffee, brew, deliver
4. **Execute primitives** → each leaf task maps to robot actions
5. **Monitor progress** → callbacks update UI and detect failures
:::

## Next Steps

With Hierarchical Task Networks covered, you now have a complete framework for complex task decomposition and execution. This completes Module 4 Chapter 2 on Data Pipelines for Physical AI.

The next chapter (Module 4 Chapter 3) explores Deployment strategies for deploying humanoid robot systems on edge hardware.
