---
id: m4-c2-s8
title: Cloud Robotics and Fleet Management
sidebar_position: 8
keywords: ['cloud', 'robotics', 'fleet', 'aws', 'robomaker', 'kubernetes', 'deployment']
---

# Cloud Robotics and Fleet Management

## Prerequisites

Before diving into this section, ensure you have:

- **Solid understanding of ROS 2** architecture and communication patterns
- **Experience with containerization** (Docker basics)
- **Familiarity with cloud concepts** (VMs, storage, networking)
- **Completion of M4 C1-C2** sections on system integration
- **Basic knowledge of REST APIs** and web services

## Learning Objectives

By the end of this section, you will be able to:

| Level | Objective |
|-------|-----------|
| **[Beginner]** | Explain the benefits and challenges of cloud robotics architectures |
| **[Beginner]** | Identify when cloud offloading is appropriate vs. edge processing |
| **[Intermediate]** | Deploy ROS 2 nodes in Docker containers for cloud execution |
| **[Intermediate]** | Implement cloud-edge communication patterns for robot control |
| **[Advanced]** | Design fleet management systems for multi-robot coordination |
| **[Advanced]** | Configure simulation-at-scale using cloud infrastructure |
| **[Expert]** | Architect production cloud robotics systems with fault tolerance |

## Key Concepts

| Term | Definition | Why It Matters |
|------|------------|----------------|
| **Cloud Robotics** | Offloading computation from robots to cloud servers | Enables complex AI without edge hardware limits |
| **Edge Computing** | Processing data locally on the robot | Ensures real-time control and reduces latency |
| **Fleet Management** | Coordinating multiple robots as a unified system | Essential for warehouse, delivery, and multi-robot applications |
| **Digital Twin** | Cloud-hosted simulation mirroring physical robots | Enables monitoring, prediction, and virtual testing |
| **OTA Updates** | Over-the-air software deployment to robots | Maintains fleet software without physical access |
| **Teleoperation** | Remote human control via cloud infrastructure | Enables intervention and supervision at scale |
| **Multi-Robot SLAM** | Shared mapping across multiple robots | Faster environment coverage and consistency |

:::danger Latency Trap Warning
**Cloud offloading adds 50-200ms network latency.** Only offload tasks that can tolerate delays:
- ✅ Semantic understanding, LLM planning, map updates
- ❌ Real-time control, balance, collision avoidance
- Design systems with graceful degradation when cloud is unavailable
:::

---

## Cloud Robotics Architecture

### Hybrid Edge-Cloud Design

```
┌─────────────────────────────────────────────────────────────────┐
│                         CLOUD LAYER                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │ Fleet Manager│  │ ML Training  │  │ Digital Twin │          │
│  │              │  │   Server     │  │  Simulation  │          │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘          │
│         │                 │                 │                   │
│  ┌──────┴─────────────────┴─────────────────┴───────┐          │
│  │              Cloud Message Broker                 │          │
│  │         (MQTT / ROS 2 Cloud Bridge)              │          │
│  └──────────────────────┬───────────────────────────┘          │
└─────────────────────────┼───────────────────────────────────────┘
                          │ Internet (50-200ms latency)
┌─────────────────────────┼───────────────────────────────────────┐
│                         │        EDGE LAYER                     │
│  ┌──────────────────────┴───────────────────────┐               │
│  │           Edge Gateway / Jetson              │               │
│  │    ┌─────────┐ ┌─────────┐ ┌─────────┐      │               │
│  │    │ Control │ │Perception│ │ Safety  │      │               │
│  │    │  Loop   │ │ Pipeline │ │ Monitor │      │               │
│  │    └─────────┘ └─────────┘ └─────────┘      │               │
│  └──────────────────────────────────────────────┘               │
│                           │                                      │
│            ┌──────────────┼──────────────┐                      │
│            │              │              │                      │
│      ┌─────┴─────┐ ┌─────┴─────┐ ┌─────┴─────┐                 │
│      │  Robot 1  │ │  Robot 2  │ │  Robot N  │                 │
│      └───────────┘ └───────────┘ └───────────┘                 │
└─────────────────────────────────────────────────────────────────┘
```

### Task Distribution Matrix

| Task | Location | Latency Tolerance | Justification |
|------|----------|-------------------|---------------|
| Balance control | Robot | 1-5ms | Safety-critical |
| Collision avoidance | Robot | 5-20ms | Safety-critical |
| Object detection | Edge | 20-50ms | Real-time perception |
| Path planning | Edge/Cloud | 100-500ms | Can pre-compute |
| LLM task planning | Cloud | 500-2000ms | Complex reasoning |
| Map updates | Cloud | 1-10s | Background task |
| ML training | Cloud | Hours | Batch processing |
| Fleet coordination | Cloud | 100-500ms | Global optimization |

---

## Implementation

### ROS 2 Cloud Bridge

```python
"""
Cloud robotics bridge for ROS 2.
Enables secure communication between edge robots and cloud services.
"""

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy
import paho.mqtt.client as mqtt
import json
import ssl
from dataclasses import dataclass, asdict
from typing import Dict, Any, Callable, Optional
from enum import Enum
import threading
import time


class CloudConnectionState(Enum):
    """Cloud connection states."""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    RECONNECTING = "reconnecting"


@dataclass
class CloudConfig:
    """Cloud connection configuration."""
    broker_host: str = "mqtt.cloud-robotics.example.com"
    broker_port: int = 8883
    robot_id: str = "humanoid-001"
    fleet_id: str = "fleet-alpha"
    use_tls: bool = True
    ca_cert_path: str = "/etc/ssl/certs/ca-certificates.crt"
    client_cert_path: Optional[str] = None
    client_key_path: Optional[str] = None
    keepalive: int = 60
    reconnect_delay: float = 5.0


class CloudRoboticsBridge(Node):
    """
    ROS 2 node bridging local topics to cloud MQTT.

    Provides:
    - Bidirectional topic bridging (ROS 2 <-> MQTT)
    - Automatic reconnection with backoff
    - Message compression for bandwidth efficiency
    - Heartbeat monitoring for connection health
    """

    def __init__(self, config: CloudConfig):
        super().__init__('cloud_robotics_bridge')
        self.config = config

        # Connection state
        self.state = CloudConnectionState.DISCONNECTED
        self.last_heartbeat = time.time()

        # MQTT client setup
        self.mqtt_client = mqtt.Client(
            client_id=f"{config.fleet_id}/{config.robot_id}"
        )
        self._setup_mqtt_client()

        # Topic mappings: ROS topic -> MQTT topic
        self.ros_to_cloud_topics: Dict[str, str] = {}
        self.cloud_to_ros_topics: Dict[str, str] = {}
        self.ros_publishers: Dict[str, Any] = {}
        self.ros_subscribers: Dict[str, Any] = {}

        # Heartbeat timer
        self.heartbeat_timer = self.create_timer(
            10.0, self._send_heartbeat
        )

        # Connection monitor
        self.connection_timer = self.create_timer(
            1.0, self._check_connection
        )

    def _setup_mqtt_client(self):
        """Configure MQTT client with TLS and callbacks."""
        # TLS configuration
        if self.config.use_tls:
            self.mqtt_client.tls_set(
                ca_certs=self.config.ca_cert_path,
                certfile=self.config.client_cert_path,
                keyfile=self.config.client_key_path,
                tls_version=ssl.PROTOCOL_TLS
            )

        # Callbacks
        self.mqtt_client.on_connect = self._on_connect
        self.mqtt_client.on_disconnect = self._on_disconnect
        self.mqtt_client.on_message = self._on_message

        # Last will message (announced on unexpected disconnect)
        will_topic = f"fleet/{self.config.fleet_id}/robots/{self.config.robot_id}/status"
        will_payload = json.dumps({
            "robot_id": self.config.robot_id,
            "status": "offline",
            "reason": "unexpected_disconnect"
        })
        self.mqtt_client.will_set(will_topic, will_payload, qos=1, retain=True)

    def connect(self):
        """Initiate connection to cloud broker."""
        self.state = CloudConnectionState.CONNECTING
        self.get_logger().info(
            f"Connecting to cloud broker: {self.config.broker_host}"
        )

        try:
            self.mqtt_client.connect(
                self.config.broker_host,
                self.config.broker_port,
                self.config.keepalive
            )
            self.mqtt_client.loop_start()
        except Exception as e:
            self.get_logger().error(f"Connection failed: {e}")
            self.state = CloudConnectionState.DISCONNECTED

    def _on_connect(self, client, userdata, flags, rc):
        """Handle MQTT connection established."""
        if rc == 0:
            self.state = CloudConnectionState.CONNECTED
            self.get_logger().info("Connected to cloud broker")

            # Subscribe to cloud topics
            for cloud_topic in self.cloud_to_ros_topics.keys():
                client.subscribe(cloud_topic, qos=1)
                self.get_logger().info(f"Subscribed to: {cloud_topic}")

            # Announce online status
            self._publish_status("online")
        else:
            self.get_logger().error(f"Connection failed with code: {rc}")

    def _on_disconnect(self, client, userdata, rc):
        """Handle MQTT disconnection."""
        self.state = CloudConnectionState.RECONNECTING
        self.get_logger().warn(f"Disconnected from cloud (rc={rc})")

        if rc != 0:
            # Unexpected disconnect - will auto-reconnect
            self.get_logger().info("Attempting reconnection...")

    def _on_message(self, client, userdata, msg):
        """Handle incoming MQTT message."""
        cloud_topic = msg.topic

        if cloud_topic in self.cloud_to_ros_topics:
            ros_topic = self.cloud_to_ros_topics[cloud_topic]

            try:
                # Decode and publish to ROS
                payload = json.loads(msg.payload.decode())
                self._publish_to_ros(ros_topic, payload)
            except Exception as e:
                self.get_logger().error(f"Message processing error: {e}")

    def bridge_ros_to_cloud(
        self,
        ros_topic: str,
        ros_msg_type,
        cloud_topic: str,
        transform_fn: Optional[Callable] = None
    ):
        """
        Bridge ROS 2 topic to cloud MQTT topic.

        Args:
            ros_topic: Local ROS 2 topic name
            ros_msg_type: ROS 2 message type
            cloud_topic: Cloud MQTT topic
            transform_fn: Optional function to transform message
        """
        full_cloud_topic = (
            f"fleet/{self.config.fleet_id}/"
            f"robots/{self.config.robot_id}/{cloud_topic}"
        )

        self.ros_to_cloud_topics[ros_topic] = full_cloud_topic

        def callback(msg):
            if self.state != CloudConnectionState.CONNECTED:
                return

            # Transform message to JSON-serializable dict
            if transform_fn:
                payload = transform_fn(msg)
            else:
                payload = self._ros_msg_to_dict(msg)

            # Publish to cloud
            self.mqtt_client.publish(
                full_cloud_topic,
                json.dumps(payload),
                qos=1
            )

        self.ros_subscribers[ros_topic] = self.create_subscription(
            ros_msg_type,
            ros_topic,
            callback,
            10
        )

        self.get_logger().info(
            f"Bridging ROS {ros_topic} -> Cloud {full_cloud_topic}"
        )

    def bridge_cloud_to_ros(
        self,
        cloud_topic: str,
        ros_topic: str,
        ros_msg_type,
        transform_fn: Optional[Callable] = None
    ):
        """
        Bridge cloud MQTT topic to local ROS 2 topic.

        Args:
            cloud_topic: Cloud MQTT topic pattern
            ros_topic: Local ROS 2 topic name
            ros_msg_type: ROS 2 message type
            transform_fn: Optional function to transform payload to message
        """
        full_cloud_topic = (
            f"fleet/{self.config.fleet_id}/"
            f"robots/{self.config.robot_id}/{cloud_topic}"
        )

        self.cloud_to_ros_topics[full_cloud_topic] = ros_topic

        # Create publisher
        self.ros_publishers[ros_topic] = self.create_publisher(
            ros_msg_type,
            ros_topic,
            10
        )

        # Subscribe to MQTT topic if already connected
        if self.state == CloudConnectionState.CONNECTED:
            self.mqtt_client.subscribe(full_cloud_topic, qos=1)

        self.get_logger().info(
            f"Bridging Cloud {full_cloud_topic} -> ROS {ros_topic}"
        )

    def _ros_msg_to_dict(self, msg) -> Dict[str, Any]:
        """Convert ROS message to dictionary."""
        result = {}
        for field_name in msg.get_fields_and_field_types().keys():
            value = getattr(msg, field_name)
            if hasattr(value, 'get_fields_and_field_types'):
                result[field_name] = self._ros_msg_to_dict(value)
            elif isinstance(value, (list, tuple)):
                result[field_name] = list(value)
            else:
                result[field_name] = value
        return result

    def _send_heartbeat(self):
        """Send periodic heartbeat to cloud."""
        if self.state != CloudConnectionState.CONNECTED:
            return

        heartbeat = {
            "robot_id": self.config.robot_id,
            "timestamp": time.time(),
            "status": "active",
            "battery": 85.0,  # Would come from real sensor
            "cpu_usage": 45.0,
            "memory_usage": 62.0
        }

        topic = f"fleet/{self.config.fleet_id}/robots/{self.config.robot_id}/heartbeat"
        self.mqtt_client.publish(topic, json.dumps(heartbeat), qos=0)
        self.last_heartbeat = time.time()

    def _check_connection(self):
        """Monitor connection health."""
        if self.state == CloudConnectionState.DISCONNECTED:
            # Attempt reconnection
            self.connect()
        elif self.state == CloudConnectionState.CONNECTED:
            # Check for stale connection
            if time.time() - self.last_heartbeat > 30:
                self.get_logger().warn("Heartbeat timeout - checking connection")

    def _publish_status(self, status: str):
        """Publish robot status to cloud."""
        topic = f"fleet/{self.config.fleet_id}/robots/{self.config.robot_id}/status"
        payload = {
            "robot_id": self.config.robot_id,
            "status": status,
            "timestamp": time.time()
        }
        self.mqtt_client.publish(topic, json.dumps(payload), qos=1, retain=True)

    def _publish_to_ros(self, ros_topic: str, payload: Dict):
        """Publish payload to ROS topic."""
        if ros_topic in self.ros_publishers:
            # Would need message-specific conversion here
            self.get_logger().debug(f"Publishing to {ros_topic}: {payload}")
```

---

### Fleet Management System

```python
"""
Fleet management system for coordinating multiple robots.
Runs in the cloud and communicates with individual robot bridges.
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set
from enum import Enum
import asyncio
import json
import time
from collections import defaultdict


class RobotState(Enum):
    """Robot operational states."""
    IDLE = "idle"
    ACTIVE = "active"
    CHARGING = "charging"
    ERROR = "error"
    OFFLINE = "offline"
    MAINTENANCE = "maintenance"


class TaskPriority(Enum):
    """Task priority levels."""
    LOW = 1
    NORMAL = 2
    HIGH = 3
    URGENT = 4


@dataclass
class RobotInfo:
    """Information about a single robot in the fleet."""
    robot_id: str
    fleet_id: str
    state: RobotState = RobotState.OFFLINE
    battery_level: float = 0.0
    position: tuple = (0.0, 0.0, 0.0)
    current_task: Optional[str] = None
    capabilities: Set[str] = field(default_factory=set)
    last_heartbeat: float = 0.0
    error_count: int = 0


@dataclass
class FleetTask:
    """Task to be assigned to fleet robots."""
    task_id: str
    task_type: str
    priority: TaskPriority
    parameters: Dict
    assigned_robot: Optional[str] = None
    status: str = "pending"
    created_at: float = field(default_factory=time.time)
    started_at: Optional[float] = None
    completed_at: Optional[float] = None


class FleetManager:
    """
    Central fleet management system.

    Responsibilities:
    - Track robot states and health
    - Assign tasks optimally to robots
    - Monitor fleet-wide performance
    - Handle failures and reassignment
    - Coordinate multi-robot tasks
    """

    def __init__(self, fleet_id: str):
        self.fleet_id = fleet_id
        self.robots: Dict[str, RobotInfo] = {}
        self.tasks: Dict[str, FleetTask] = {}
        self.task_queue: List[str] = []

        # Performance metrics
        self.metrics = defaultdict(lambda: defaultdict(float))

        # Configuration
        self.heartbeat_timeout = 30.0  # seconds
        self.task_timeout = 300.0  # seconds

    async def register_robot(self, robot_id: str, capabilities: Set[str]):
        """Register a new robot with the fleet."""
        self.robots[robot_id] = RobotInfo(
            robot_id=robot_id,
            fleet_id=self.fleet_id,
            capabilities=capabilities,
            last_heartbeat=time.time()
        )
        print(f"Robot {robot_id} registered with capabilities: {capabilities}")

    async def update_robot_status(self, robot_id: str, status: Dict):
        """Update robot status from heartbeat."""
        if robot_id not in self.robots:
            return

        robot = self.robots[robot_id]
        robot.last_heartbeat = time.time()
        robot.battery_level = status.get('battery', robot.battery_level)
        robot.state = RobotState(status.get('state', robot.state.value))

        if 'position' in status:
            robot.position = tuple(status['position'])

    async def submit_task(self, task: FleetTask) -> str:
        """Submit a new task to the fleet."""
        self.tasks[task.task_id] = task
        self.task_queue.append(task.task_id)

        # Trigger task assignment
        await self._assign_pending_tasks()

        return task.task_id

    async def _assign_pending_tasks(self):
        """Assign pending tasks to available robots."""
        # Sort queue by priority
        self.task_queue.sort(
            key=lambda tid: self.tasks[tid].priority.value,
            reverse=True
        )

        for task_id in self.task_queue[:]:
            task = self.tasks[task_id]

            if task.status != "pending":
                continue

            # Find best available robot
            best_robot = self._find_best_robot(task)

            if best_robot:
                await self._assign_task(task, best_robot)
                self.task_queue.remove(task_id)

    def _find_best_robot(self, task: FleetTask) -> Optional[str]:
        """Find the best robot for a task based on multiple criteria."""
        candidates = []

        for robot_id, robot in self.robots.items():
            # Check availability
            if robot.state != RobotState.IDLE:
                continue

            # Check capabilities
            required_caps = set(task.parameters.get('required_capabilities', []))
            if not required_caps.issubset(robot.capabilities):
                continue

            # Check battery
            if robot.battery_level < 20:
                continue

            # Score the robot
            score = self._score_robot(robot, task)
            candidates.append((robot_id, score))

        if not candidates:
            return None

        # Return highest scoring robot
        candidates.sort(key=lambda x: x[1], reverse=True)
        return candidates[0][0]

    def _score_robot(self, robot: RobotInfo, task: FleetTask) -> float:
        """Score a robot's suitability for a task."""
        score = 0.0

        # Battery level (prefer higher)
        score += robot.battery_level * 0.3

        # Proximity to task location (prefer closer)
        if 'location' in task.parameters:
            task_loc = task.parameters['location']
            dist = self._calculate_distance(robot.position, task_loc)
            score += max(0, 100 - dist) * 0.4

        # Error history (prefer fewer errors)
        score += max(0, 100 - robot.error_count * 10) * 0.2

        # Recent activity (prefer robots that haven't been overworked)
        score += 50 * 0.1  # Placeholder for utilization metric

        return score

    async def _assign_task(self, task: FleetTask, robot_id: str):
        """Assign a task to a specific robot."""
        task.assigned_robot = robot_id
        task.status = "assigned"
        task.started_at = time.time()

        robot = self.robots[robot_id]
        robot.current_task = task.task_id
        robot.state = RobotState.ACTIVE

        print(f"Task {task.task_id} assigned to robot {robot_id}")

        # Send task to robot via MQTT
        await self._send_task_to_robot(robot_id, task)

    async def _send_task_to_robot(self, robot_id: str, task: FleetTask):
        """Send task assignment to robot via cloud bridge."""
        # This would publish to MQTT topic
        message = {
            "task_id": task.task_id,
            "task_type": task.task_type,
            "parameters": task.parameters,
            "priority": task.priority.value
        }
        # mqtt_client.publish(f"fleet/{self.fleet_id}/robots/{robot_id}/tasks", ...)
        print(f"Sent task to robot: {message}")

    async def handle_task_completion(self, robot_id: str, task_id: str, result: Dict):
        """Handle task completion notification from robot."""
        if task_id not in self.tasks:
            return

        task = self.tasks[task_id]
        task.status = "completed" if result.get('success') else "failed"
        task.completed_at = time.time()

        robot = self.robots[robot_id]
        robot.current_task = None
        robot.state = RobotState.IDLE

        # Update metrics
        duration = task.completed_at - task.started_at
        self.metrics['tasks']['completed'] += 1
        self.metrics['tasks']['total_duration'] += duration

        print(f"Task {task_id} completed by {robot_id}: {result}")

        # Assign next task
        await self._assign_pending_tasks()

    async def monitor_health(self):
        """Periodic health monitoring of fleet."""
        while True:
            current_time = time.time()

            for robot_id, robot in self.robots.items():
                # Check heartbeat timeout
                if current_time - robot.last_heartbeat > self.heartbeat_timeout:
                    if robot.state != RobotState.OFFLINE:
                        robot.state = RobotState.OFFLINE
                        print(f"Robot {robot_id} went offline")

                        # Reassign any active task
                        if robot.current_task:
                            await self._handle_robot_failure(robot_id)

            await asyncio.sleep(5)

    async def _handle_robot_failure(self, robot_id: str):
        """Handle robot failure and reassign tasks."""
        robot = self.robots[robot_id]

        if robot.current_task:
            task = self.tasks[robot.current_task]
            task.status = "pending"
            task.assigned_robot = None
            self.task_queue.append(task.task_id)

            print(f"Reassigning task {task.task_id} from failed robot {robot_id}")
            await self._assign_pending_tasks()

    def _calculate_distance(self, pos1: tuple, pos2: tuple) -> float:
        """Calculate Euclidean distance between positions."""
        return sum((a - b) ** 2 for a, b in zip(pos1, pos2)) ** 0.5

    def get_fleet_status(self) -> Dict:
        """Get overall fleet status summary."""
        online = sum(1 for r in self.robots.values() if r.state != RobotState.OFFLINE)
        active = sum(1 for r in self.robots.values() if r.state == RobotState.ACTIVE)

        return {
            "fleet_id": self.fleet_id,
            "total_robots": len(self.robots),
            "online_robots": online,
            "active_robots": active,
            "pending_tasks": len([t for t in self.tasks.values() if t.status == "pending"]),
            "completed_tasks": int(self.metrics['tasks']['completed']),
            "avg_task_duration": (
                self.metrics['tasks']['total_duration'] /
                max(1, self.metrics['tasks']['completed'])
            )
        }
```

---

## Cloud Deployment Patterns

### Docker Containerization

```dockerfile
# Dockerfile for ROS 2 cloud robotics node
FROM ros:humble-ros-base

# Install dependencies
RUN apt-get update && apt-get install -y \
    python3-pip \
    ros-kilted-rmw-cyclonedds-cpp \
    && rm -rf /var/lib/apt/lists/*

# Install Python packages
RUN pip3 install \
    paho-mqtt \
    boto3 \
    redis \
    prometheus-client

# Copy ROS 2 workspace
COPY ./ros2_ws /ros2_ws

# Build workspace
WORKDIR /ros2_ws
RUN . /opt/ros/humble/setup.sh && \
    colcon build --symlink-install

# Setup entrypoint
COPY ./entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

ENTRYPOINT ["/entrypoint.sh"]
CMD ["ros2", "launch", "cloud_robotics", "bridge.launch.py"]
```

### Kubernetes Deployment

```yaml
# kubernetes/fleet-manager-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fleet-manager
  labels:
    app: fleet-manager
spec:
  replicas: 2
  selector:
    matchLabels:
      app: fleet-manager
  template:
    metadata:
      labels:
        app: fleet-manager
    spec:
      containers:
      - name: fleet-manager
        image: robotics/fleet-manager:latest
        ports:
        - containerPort: 8080
        env:
        - name: MQTT_BROKER
          valueFrom:
            secretKeyRef:
              name: mqtt-credentials
              key: broker
        - name: FLEET_ID
          value: "production-fleet-1"
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: fleet-manager-service
spec:
  selector:
    app: fleet-manager
  ports:
  - port: 80
    targetPort: 8080
  type: LoadBalancer
```

---

## AWS RoboMaker Integration

### Simulation at Scale

```python
"""
AWS RoboMaker integration for cloud simulation.
"""

import boto3
from dataclasses import dataclass
from typing import List, Dict


@dataclass
class SimulationConfig:
    """Configuration for cloud simulation job."""
    world_config: str
    robot_application: str
    simulation_application: str
    max_duration: int = 3600
    instance_type: str = "c5.4xlarge"


class RoboMakerSimulation:
    """
    Interface to AWS RoboMaker for simulation at scale.
    """

    def __init__(self, region: str = "us-west-2"):
        self.client = boto3.client('robomaker', region_name=region)

    def create_simulation_job(
        self,
        config: SimulationConfig,
        num_robots: int = 1
    ) -> str:
        """Launch a simulation job in RoboMaker."""
        response = self.client.create_simulation_job(
            maxJobDurationInSeconds=config.max_duration,
            iamRole="arn:aws:iam::ACCOUNT:role/RoboMakerRole",
            robotApplications=[{
                "application": config.robot_application,
                "launchConfig": {
                    "packageName": "humanoid_sim",
                    "launchFile": "robot.launch.py",
                    "environmentVariables": {
                        "NUM_ROBOTS": str(num_robots)
                    }
                }
            }],
            simulationApplications=[{
                "application": config.simulation_application,
                "worldConfigs": [{
                    "world": config.world_config
                }],
                "launchConfig": {
                    "packageName": "humanoid_worlds",
                    "launchFile": "world.launch.py"
                }
            }],
            compute={
                "simulationUnitLimit": 15
            }
        )

        return response['arn']

    def batch_simulation(
        self,
        config: SimulationConfig,
        parameter_variations: List[Dict]
    ) -> List[str]:
        """Run batch simulations with parameter sweeps."""
        job_arns = []

        for params in parameter_variations:
            # Modify config with parameters
            env_vars = {k: str(v) for k, v in params.items()}

            response = self.client.create_simulation_job(
                maxJobDurationInSeconds=config.max_duration,
                robotApplications=[{
                    "application": config.robot_application,
                    "launchConfig": {
                        "packageName": "humanoid_sim",
                        "launchFile": "robot.launch.py",
                        "environmentVariables": env_vars
                    }
                }],
                simulationApplications=[{
                    "application": config.simulation_application,
                    "launchConfig": {
                        "packageName": "humanoid_worlds",
                        "launchFile": "world.launch.py"
                    }
                }]
            )

            job_arns.append(response['arn'])

        return job_arns
```

---

## Connection to Capstone

Cloud robotics enables the capstone humanoid assistant to:

1. **Offload LLM Reasoning**: Send complex task planning to cloud GPT/Claude instances
2. **Fleet Coordination**: Deploy multiple humanoids with centralized management
3. **Continuous Learning**: Upload data for cloud-based model training
4. **Remote Monitoring**: Digital twin visualization in cloud dashboard
5. **OTA Updates**: Deploy software updates without physical access

---

## Exercises

### Exercise 1: Basic Cloud Bridge (Beginner)

Set up a local MQTT broker and bridge a ROS 2 topic:

```bash
# Install Mosquitto broker locally
sudo apt install mosquitto mosquitto-clients

# Your task: Bridge /robot/pose to MQTT
```

### Exercise 2: Fleet Simulation (Intermediate)

Simulate a 3-robot fleet with centralized task assignment:
- Launch 3 simulated robots in Gazebo
- Implement fleet manager with task queue
- Assign tasks based on proximity to task location

### Exercise 3: Hybrid Architecture (Advanced)

Design and implement a system where:
- Perception runs on edge (Jetson)
- Planning runs in cloud
- Control runs on robot
- Gracefully handles cloud disconnection

---

## Summary

Cloud robotics enables scalable, sophisticated robot deployments:

- **Offload complex computation** while keeping safety-critical tasks local
- **Fleet management** coordinates multiple robots efficiently
- **Digital twins** enable monitoring and virtual testing
- **Design for disconnection** ensures robots remain functional offline

:::tip Best Practice
Start with a robust edge-only system, then add cloud capabilities incrementally. Never depend on cloud for safety-critical functions.
:::

