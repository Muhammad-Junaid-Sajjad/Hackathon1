---
id: m4-c2-s2
title: Behavior Trees for Hierarchical Planning
sidebar_position: 2
keywords: ['behavior-trees', 'planning', 'hierarchical', 'control']
---

# Behavior Trees for Hierarchical Planning

## Prerequisites

Before diving into behavior trees, ensure you have:

- **Basic Python proficiency** including classes, inheritance, and the `abc` module for abstract base classes
- **Understanding of finite state machines (FSMs)** and their limitations for complex robotic behaviors
- **Familiarity with task decomposition** concepts from Module 4 Chapter 1 (LLM-based planning)
- **Knowledge of robot control fundamentals** including sensors, actuators, and feedback loops
- **Experience with asynchronous programming patterns** such as callbacks and event-driven architectures

## Learning Objectives

By the end of this section, you will be able to:

- **[Beginner]** Define behavior trees and identify the four core node types (Sequence, Selector, Parallel, Decorator)
- **[Beginner]** Explain the tick-based execution model and node status values (SUCCESS, FAILURE, RUNNING)
- **[Intermediate]** Implement custom behavior tree nodes for humanoid robot tasks using Python
- **[Intermediate]** Configure blackboard-based data sharing between nodes for state management
- **[Advanced]** Architect hierarchical behavior trees that integrate with LLM-generated task plans
- **[Advanced]** Optimize multi-tree execution with priority-based interruption and parallel task management

## Key Concepts

| Term | Definition |
|------|------------|
| **Behavior Tree** | A hierarchical, modular control structure that organizes robot behaviors as a tree of composable nodes |
| **Tick** | A single execution cycle where the tree traverses nodes and updates their status |
| **Node Status** | The execution state of a node: SUCCESS, FAILURE, RUNNING, or IDLE |
| **Sequence Node** | A composite node that executes children in order, succeeding only if all children succeed |
| **Selector Node** | A composite node that tries children in order until one succeeds (fallback behavior) |
| **Parallel Node** | A composite node that executes multiple children simultaneously based on success policies |
| **Blackboard** | A shared data storage mechanism that enables communication between behavior tree nodes |
| **Decorator Node** | A single-child wrapper that modifies child behavior (e.g., inverting results, repeating execution) |

:::danger Latency Trap Warning
**Behavior tree ticks MUST run locally at 10-100 Hz.** Remote BT execution adds latency to every decision:
- Run behavior tree executor on Jetson with direct sensor access
- Blackboard reads/writes must be local (no network database)
- Only log tree state to cloud asynchronously (not in tick loop)
:::

Behavior trees provide a structured, modular approach to robot task execution, enabling complex hierarchical behaviors through composable node types. This section covers behavior tree fundamentals, implementation for humanoid robots, and integration with LLM-generated plans.

For humanoid robots, behavior trees offer a clear way to structure task execution, handle failures gracefully, and enable non-preemptive multitasking.

## Behavior Tree Fundamentals

### Node Types and Control Flow

```python
# Behavior tree implementation for humanoid robots
import time
from typing import Dict, List, Optional, Callable, Any
from dataclasses import dataclass, field
from enum import Enum
from abc import ABC, abstractmethod
from copy import deepcopy


class NodeStatus(Enum):
    """Behavior tree node status."""
    SUCCESS = "success"
    FAILURE = "failure"
    RUNNING = "running"
    IDLE = "idle"


@dataclass
class Blackboard:
    """Shared data storage for behavior tree."""
    data: Dict = field(default_factory=dict)

    def set(self, key: str, value: Any):
        """Set a value."""
        self.data[key] = value

    def get(self, key: str, default: Any = None) -> Any:
        """Get a value."""
        return self.data.get(key, default)

    def has(self, key: str) -> bool:
        """Check if key exists."""
        return key in self.data


class BehaviorNode(ABC):
    """Abstract base class for behavior tree nodes."""

    def __init__(self, name: str = None):
        """Initialize node."""
        self.name = name or self.__class__.__name__
        self.status = NodeStatus.IDLE
        self.children: List[BehaviorNode] = []
        self.parent: BehaviorNode = None

    def add_child(self, child: 'BehaviorNode') -> 'BehaviorNode':
        """Add a child node."""
        child.parent = self
        self.children.append(child)
        return self

    def remove_child(self, child: 'BehaviorNode') -> bool:
        """Remove a child node."""
        if child in self.children:
            self.children.remove(child)
            child.parent = None
            return True
        return False

    def reset(self):
        """Reset node state."""
        self.status = NodeStatus.IDLE
        for child in self.children:
            child.reset()

    @abstractmethod
    def tick(self, blackboard: Blackboard) -> NodeStatus:
        """Execute node tick."""
        pass

    def __repr__(self):
        return f"{self.__class__.__name__}({self.name})"


class LeafNode(BehaviorNode):
    """Leaf node with action or condition."""

    def __init__(self, name: str, action: Callable[[Blackboard], NodeStatus]):
        """Initialize leaf node."""
        super().__init__(name)
        self.action = action

    def tick(self, blackboard: Blackboard) -> NodeStatus:
        """Execute action."""
        self.status = self.action(blackboard)
        return self.status


class CompositeNode(BehaviorNode):
    """Base class for composite nodes with multiple children."""

    def __init__(self, name: str):
        """Initialize composite node."""
        super().__init__(name)

    def add_child(self, child: BehaviorNode) -> BehaviorNode:
        """Add child and set parent."""
        child.parent = self
        self.children.append(child)
        return self


class SequenceNode(CompositeNode):
    """
    Sequence node: executes children in order.
    Returns SUCCESS if all children succeed.
    Returns FAILURE if any child fails.
    Returns RUNNING if current child is running.
    """

    def __init__(self, name: str = "Sequence"):
        """Initialize sequence."""
        super().__init__(name)
        self.current_child = 0

    def reset(self):
        """Reset sequence state."""
        super().reset()
        self.current_child = 0

    def tick(self, blackboard: Blackboard) -> NodeStatus:
        """Tick all children in sequence."""
        if not self.children:
            return NodeStatus.SUCCESS

        # Reset if starting new sequence
        if self.status == NodeStatus.IDLE:
            self.current_child = 0

        # Tick current child
        while self.current_child < len(self.children):
            child = self.children[self.current_child]
            child_status = child.tick(blackboard)

            if child_status == NodeStatus.RUNNING:
                self.status = NodeStatus.RUNNING
                return NodeStatus.RUNNING

            elif child_status == NodeStatus.FAILURE:
                self.current_child = 0
                self.status = NodeStatus.FAILURE
                return NodeStatus.FAILURE

            # Child succeeded, move to next
            self.current_child += 1

        # All children succeeded
        self.current_child = 0
        self.status = NodeStatus.SUCCESS
        return NodeStatus.SUCCESS


class SelectorNode(CompositeNode):
    """
    Selector node (priority-based): tries children in order.
    Returns SUCCESS if any child succeeds.
    Returns FAILURE if all children fail.
    Returns RUNNING if current child is running.
    """

    def __init__(self, name: str = "Selector"):
        """Initialize selector."""
        super().__init__(name)
        self.current_child = 0

    def reset(self):
        """Reset selector state."""
        super().reset()
        self.current_child = 0

    def tick(self, blackboard: Blackboard) -> NodeStatus:
        """Try children until one succeeds."""
        if not self.children:
            return NodeStatus.FAILURE

        if self.status == NodeStatus.IDLE:
            self.current_child = 0

        while self.current_child < len(self.children):
            child = self.children[self.current_child]
            child_status = child.tick(blackboard)

            if child_status == NodeStatus.RUNNING:
                self.status = NodeStatus.RUNNING
                return NodeStatus.RUNNING

            elif child_status == NodeStatus.SUCCESS:
                self.current_child = 0
                self.status = NodeStatus.SUCCESS
                return NodeStatus.SUCCESS

            # Child failed, try next
            self.current_child += 1

        # All children failed
        self.current_child = 0
        self.status = NodeStatus.FAILURE
        return NodeStatus.FAILURE


class ParallelNode(CompositeNode):
    """
    Parallel node: ticks all children simultaneously.
    Returns SUCCESS based on policy (all succeed, any succeeds, etc.)
    """

    def __init__(self, name: str = "Parallel", success_policy: str = "all"):
        """
        Initialize parallel node.

        Args:
            success_policy: "all" (all must succeed), "any" (any succeeds)
        """
        super().__init__(name)
        self.success_policy = success_policy

    def tick(self, blackboard: Blackboard) -> NodeStatus:
        """Tick all children."""
        if not self.children:
            return NodeStatus.SUCCESS

        results = []
        for child in self.children:
            if child.status != NodeStatus.SUCCESS:
                child.tick(blackboard)
            results.append(child.status)

        # Check policy
        if self.success_policy == "all":
            if all(r == NodeStatus.SUCCESS for r in results):
                return NodeStatus.SUCCESS
            if any(r == NodeStatus.FAILURE for r in results):
                return NodeStatus.FAILURE
        elif self.success_policy == "any":
            if any(r == NodeStatus.SUCCESS for r in results):
                return NodeStatus.SUCCESS
            if all(r == NodeStatus.FAILURE for r in results):
                return NodeStatus.FAILURE

        return NodeStatus.RUNNING


class DecoratorNode(BehaviorNode):
    """Decorator node: wraps a single child with modified behavior."""

    def __init__(self, name: str, child: BehaviorNode = None):
        """Initialize decorator."""
        super().__init__(name)
        if child:
            self.add_child(child)

    def add_child(self, child: BehaviorNode) -> BehaviorNode:
        """Add single child."""
        if self.children:
            self.children[0].parent = None
        child.parent = self
        self.children = [child]
        return child


class ConditionNode(LeafNode):
    """Condition node that returns SUCCESS/FAILURE."""

    def __init__(self, name: str, condition: Callable[[Blackboard], bool]):
        """Initialize condition."""
        def check_condition(bb):
            return NodeStatus.SUCCESS if condition(bb) else NodeStatus.FAILURE
        super().__init__(name, check_condition)


class InverterNode(DecoratorNode):
    """Inverts child status: SUCCESS -> FAILURE, FAILURE -> SUCCESS."""

    def __init__(self, name: str = "Inverter", child: BehaviorNode = None):
        """Initialize inverter."""
        super().__init__(name, child)

    def tick(self, blackboard: Blackboard) -> NodeStatus:
        """Tick with inversion."""
        if not self.children:
            return NodeStatus.FAILURE

        child = self.children[0]
        child_status = child.tick(blackboard)

        if child_status == NodeStatus.SUCCESS:
            return NodeStatus.FAILURE
        elif child_status == NodeStatus.FAILURE:
            return NodeStatus.SUCCESS
        return child_status


class RepeatNode(DecoratorNode):
    """Repeats child a specified number of times."""

    def __init__(self, name: str = "Repeat", count: int = 1, child: BehaviorNode = None):
        """Initialize repeat node."""
        super().__init__(name, child)
        self.count = count
        self.remaining = count

    def reset(self):
        """Reset repeat counter."""
        super().reset()
        self.remaining = self.count

    def tick(self, blackboard: Blackboard) -> NodeStatus:
        """Tick with repetition."""
        if not self.children:
            return NodeStatus.SUCCESS

        child = self.children[0]

        while self.remaining > 0:
            child_status = child.tick(blackboard)

            if child_status == NodeStatus.RUNNING:
                return NodeStatus.RUNNING

            if child_status == NodeStatus.FAILURE:
                self.remaining = self.count
                return NodeStatus.FAILURE

            # Child succeeded
            self.remaining -= 1
            if self.remaining > 0:
                child.reset()

        self.remaining = self.count
        return NodeStatus.SUCCESS
```

## Robot-Specific Behavior Trees

### Task Trees for Household Activities

```python
# Robot behavior tree templates
from typing import Dict, List
import time


class RobotBehaviorTrees:
    """
    Pre-built behavior trees for common robot tasks.
    """

    @staticmethod
    def create_fetch_tree(object_name: str) -> BehaviorNode:
        """Create behavior tree for fetching an object."""
        return SequenceNode("FetchTask").add_child(
            SequenceNode("NavigateToSearch").add_child(
                SelectorNode("NavigateApproach").add_child(
                    LeafNode("GoToLivingRoom",
                            lambda bb: NodeStatus.SUCCESS if bb.get('current_location') == 'living room' else NodeStatus.FAILURE),
                    LeafNode("NavigateToRoom",
                            lambda bb: (bb.set('target_location', 'living room'),
                                       NodeStatus.SUCCESS)[1])
                )
            ).add_child(
                SequenceNode("SearchForObject").add_child(
                    LeafNode("ScanRoom",
                            lambda bb: (bb.set('object_found', True), NodeStatus.SUCCESS)[1]),
                    ConditionNode("CheckObjectFound",
                                 lambda bb: bb.get('object_found', False))
                )
            ).add_child(
                SequenceNode("GraspObject").add_child(
                    LeafNode("ApproachObject",
                            lambda bb: NodeStatus.SUCCESS),
                    LeafNode("GraspWithHand",
                            lambda bb: (bb.set('holding_object', object_name), NodeStatus.SUCCESS)[1])
                )
            ).add_child(
                LeafNode("ConfirmFetch",
                        lambda bb: (bb.set('task_complete', True), NodeStatus.SUCCESS)[1])
            )
        )

    @staticmethod
    def create_set_table_tree() -> BehaviorNode:
        """Create behavior tree for setting the table."""
        return SequenceNode("SetTableTask").add_child(
            SequenceNode("GetPlates").add_child(
                LeafNode("NavigateToKitchen",
                        lambda bb: (bb.set('current_location', 'kitchen'), NodeStatus.SUCCESS)[1]),
                LeafNode("OpenCabinet",
                        lambda bb: NodeStatus.SUCCESS),
                LeafNode("GraspPlate",
                        lambda bb: (bb.set('holding', 'plate'), NodeStatus.SUCCESS)[1])
            )
        ).add_child(
            SequenceNode("GoToDining").add_child(
                LeafNode("NavigateToDiningRoom",
                        lambda bb: (bb.set('current_location', 'dining room'), NodeStatus.SUCCESS)[1]),
                LeafNode("PlacePlateOnTable",
                        lambda bb: (bb.set('holding', None), NodeStatus.SUCCESS)[1])
            )
        ).add_child(
            SequenceNode("GetUtensils").add_child(
                LeafNode("NavigateToKitchen",
                        lambda bb: (bb.set('current_location', 'kitchen'), NodeStatus.SUCCESS)[1]),
                LeafNode("GraspFork",
                        lambda bb: (bb.set('holding', 'fork'), NodeStatus.SUCCESS)[1]),
                LeafNode("NavigateToDiningRoom",
                        lambda bb: (bb.set('current_location', 'dining room'), NodeStatus.SUCCESS)[1]),
                LeafNode("PlaceForkOnTable",
                        lambda bb: (bb.set('holding', None), NodeStatus.SUCCESS)[1])
            )
        )

    @staticmethod
    def create_cleanup_tree() -> BehaviorNode:
        """Create behavior tree for cleaning up a room."""
        return SequenceNode("CleanupTask").add_child(
            ParallelNode("CleanAllAreas", success_policy="all").add_child(
                SequenceNode("CleanLivingRoom").add_child(
                    LeafNode("NavigateToLivingRoom",
                            lambda bb: NodeStatus.SUCCESS),
                    LeafNode("IdentifyClutter",
                            lambda bb: (bb.set('clutter_items', ['cup', 'book']), NodeStatus.SUCCESS)[1]),
                    SelectorNode("HandleEachItem").add_child(
                        SequenceNode("PickupItem1").add_child(
                            LeafNode("GraspCup",
                                    lambda bb: (bb.set('holding', 'cup'), NodeStatus.SUCCESS)[1]),
                            LeafNode("NavigateToTrash",
                                    lambda bb: NodeStatus.SUCCESS)
                        )
                    )
                ),
                SequenceNode("CleanKitchen").add_child(
                    LeafNode("NavigateToKitchen",
                            lambda bb: NodeStatus.SUCCESS),
                    LeafNode("WipeCounter",
                            lambda bb: NodeStatus.SUCCESS)
                )
            )
        )

    @staticmethod
    def create_assist_human_tree() -> BehaviorNode:
        """Create behavior tree for assisting a human."""
        return SequenceNode("AssistHuman").add_child(
            SequenceNode("DetectHumanRequest").add_child(
                LeafNode("ListenForCommand",
                        lambda bb: (bb.set('heard_command', "bring me water"), NodeStatus.SUCCESS)[1]),
                ConditionNode("CommandReceived",
                             lambda bb: bb.get('heard_command') is not None)
            ).add_child(
                SequenceNode("ParseRequest").add_child(
                    LeafNode("UnderstandIntent",
                            lambda bb: (bb.set('task_type', 'fetch'), NodeStatus.SUCCESS)[1]),
                    LeafNode("IdentifyObject",
                            lambda bb: (bb.set('target_object', 'water'), NodeStatus.SUCCESS)[1])
                )
            ).add_child(
                SequenceNode("ExecuteTask").add_child(
                    RobotBehaviorTrees.create_fetch_tree("water").add_child(
                        LeafNode("DeliverToHuman",
                                lambda bb: (bb.set('delivered', True), NodeStatus.SUCCESS)[1])
                    )
                )
            ).add_child(
                LeafNode("ConfirmCompletion",
                        lambda bb: NodeStatus.SUCCESS)
            )
        )


class BehaviorTreeExecutor:
    """Execute behavior trees with monitoring."""

    def __init__(self):
        """Initialize executor."""
        self.blackboard = Blackboard()
        self.root = None
        self.is_running = False

    def load_tree(self, root: BehaviorNode):
        """Load a behavior tree."""
        self.root = root
        self.reset()

    def reset(self):
        """Reset tree execution."""
        if self.root:
            self.root.reset()
        self.is_running = False

    def tick(self) -> NodeStatus:
        """Execute one tick of the tree."""
        if not self.root:
            return NodeStatus.FAILURE

        self.is_running = True
        status = self.root.tick(self.blackboard)

        if status in [NodeStatus.SUCCESS, NodeStatus.FAILURE]:
            self.is_running = False

        return status

    def execute_until_complete(self, timeout: float = 30.0,
                               tick_rate: float = 0.1) -> NodeStatus:
        """Execute tree until complete or timeout."""
        start_time = time.time()

        while self.is_running and (time.time() - start_time) < timeout:
            status = self.tick()
            if not self.is_running:
                return status
            time.sleep(tick_rate)

        return self.root.status if self.root else NodeStatus.FAILURE

    def get_execution_state(self) -> Dict:
        """Get current execution state."""
        return {
            'is_running': self.is_running,
            'status': self.root.status if self.root else None,
            'blackboard': dict(self.blackboard.data)
        }
```

## Parallel Execution and Interruption

### Managing Multiple Behavior Trees

```python
# Multi-tree execution manager
from typing import Dict, List, Optional
from dataclasses import dataclass
from enum import Enum
import threading


class Priority(Enum):
    """Task priority levels."""
    CRITICAL = 0
    HIGH = 1
    NORMAL = 2
    LOW = 3


@dataclass
class Task:
    """Executable task."""
    name: str
    tree: BehaviorNode
    priority: Priority
    interruptible: bool = True
    preconditions: Dict = None


class BehaviorTreeManager:
    """
    Manager for multiple behavior trees with priority and interruption.
    """

    def __init__(self):
        """Initialize manager."""
        self.tasks: Dict[str, Task] = {}
        self.active_tasks: List[Task] = []
        self.blocked_tasks: List[Task] = []
        self.executor = BehaviorTreeExecutor()
        self.lock = threading.Lock()

    def add_task(self, task: Task):
        """Add a task to the manager."""
        with self.lock:
            self.tasks[task.name] = task

    def remove_task(self, task_name: str):
        """Remove a task."""
        with self.lock:
            if task_name in self.tasks:
                del self.tasks[task_name]

    def start_task(self, task_name: str) -> bool:
        """Start executing a task."""
        with self.lock:
            if task_name not in self.tasks:
                return False

            task = self.tasks[task_name]

            # Check preconditions
            if not self._check_preconditions(task):
                self.blocked_tasks.append(task)
                return False

            # Check for interruption
            for active in self.active_tasks[:]:
                if task.priority.value < active.priority.value and active.interruptible:
                    self._interrupt_task(active)
                elif task.priority.value >= active.priority.value and not task.interruptible:
                    # Cannot interrupt, wait
                    return False

            self.active_tasks.append(task)
            self.executor.load_tree(task.tree)
            return True

    def _check_preconditions(self, task: Task) -> bool:
        """Check task preconditions."""
        if not task.preconditions:
            return True

        bb = self.executor.blackboard
        for key, value in task.preconditions.items():
            if bb.get(key) != value:
                return False
        return True

    def _interrupt_task(self, task: Task):
        """Interrupt an active task."""
        self.active_tasks.remove(task)
        self.executor.reset()

    def tick(self) -> Dict[str, NodeStatus]:
        """Tick all active tasks."""
        with self.lock:
            results = {}

            for task in self.active_tasks[:]:
                self.executor.load_tree(task.tree)
                status = self.executor.tick()
                results[task.name] = status

                if status in [NodeStatus.SUCCESS, NodeStatus.FAILURE]:
                    self.active_tasks.remove(task)

            return results

    def tick_all(self, tick_rate: float = 0.1):
        """Continuously tick all active tasks."""
        import time

        while True:
            with self.lock:
                if not self.active_tasks:
                    time.sleep(tick_rate)
                    continue

            results = self.tick()
            time.sleep(tick_rate)

    def get_active_tasks(self) -> List[str]:
        """Get list of active task names."""
        return [t.name for t in self.active_tasks]

    def get_blocked_tasks(self) -> List[str]:
        """Get list of blocked task names."""
        return [t.name for t in self.blocked_tasks]
```

## Connection to Capstone

Behavior trees are the **Plan execution engine** in the Voice-to-Plan-to-Navigate-to-Vision-to-Manipulate pipeline:

- **Voice Integration**: When the speech recognition system (Module 2) captures a user command like "set the table," the LLM planner (Module 4, Chapter 1) generates a high-level task sequence. Behavior trees translate these abstract plans into executable robot actions with proper sequencing and failure handling.

- **Navigation Coordination**: The `NavigateToKitchen` and `NavigateToDiningRoom` leaf nodes in the table-setting tree interface directly with the navigation stack (Module 3). Behavior trees manage the state transitions between navigation goals and manipulation tasks.

- **Vision-Driven Conditions**: ConditionNodes such as `CheckObjectFound` query the vision system (Module 5) for object detection results. The blackboard stores detected object poses that the manipulation nodes consume for grasp planning.

- **Manipulation Sequencing**: Complex manipulation tasks like `GraspPlate` and `PlaceForkOnTable` become composable behavior tree subtrees. The Sequence and Selector nodes ensure proper preconditions (gripper empty, object visible) before attempting grasps.

- **Capstone Application**: In your final project, behavior trees orchestrate the entire pipeline. A voice command triggers plan generation, the plan becomes a behavior tree, navigation nodes move the robot, vision conditions verify world state, and manipulation leaf nodes execute the physical actions. The priority-based `BehaviorTreeManager` handles interruptions when the user issues new commands mid-task.

## Next Steps

With Behavior Trees for Hierarchical Planning covered, you can now structure complex robot tasks. The next section explores Scene Context and Affordances for understanding object interactions.
