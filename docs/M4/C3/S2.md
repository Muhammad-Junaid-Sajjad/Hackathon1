---
id: m4-c3-s2
title: "Capstone Part 2: Plan to Navigate"
sidebar_position: 2
keywords: ['capstone', 'navigation', 'planning', 'execution']
---

# Capstone Part 2: Plan to Navigate

This capstone section focuses on executing navigation plans generated by the planning system. We cover path planning, obstacle avoidance, localization, and the integration between high-level task planning and low-level motor control.

For humanoid robots, reliable navigation is critical for moving between locations to perform tasks, requiring robust perception and adaptive pathfinding.

## Prerequisites

Before starting this section, you should have completed:
- M4-C3-S1 (Voice to Plan) - plan generation from voice commands
- M2-C2 (Motion Planning) - path planning algorithms, trajectory optimization
- M3-C2 (Perception) - obstacle detection, localization
- Understanding of coordinate frames and pose representations

## Learning Objectives

| Level | Objective |
|-------|-----------|
| **[Beginner]** | Describe the navigation pipeline from plan to executed motion |
| **[Beginner]** | Identify the components needed for autonomous navigation |
| **[Intermediate]** | Implement navigation state machines with obstacle avoidance |
| **[Intermediate]** | Configure multi-floor navigation with transition handling |
| **[Advanced]** | Architect robust localization with recovery behaviors |
| **[Advanced]** | Optimize path planning with A* for real-time navigation |

## Key Concepts

| Term | Definition |
|------|------------|
| **Navigation State** | Current phase of navigation (idle, moving, avoiding, arrived) |
| **Pose2D** | Robot position (x, y) and orientation (theta) in 2D space |
| **Path Segment** | A portion of the path between two waypoints |
| **Waypoint** | A target position the robot must pass through |
| **Floor Plan** | Graph representation of navigable space on one floor |
| **Transition Point** | Elevator or stairs connecting different floors |
| **A* Search** | Optimal pathfinding algorithm using heuristic guidance |

## Navigation Plan Execution

### Path Following Architecture

```python
# Navigation plan execution system
import time
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum
from threading import Lock
import math


class NavigationState(Enum):
    """Navigation execution states."""
    IDLE = "idle"
    PLANNING = "planning"
    MOVING = "moving"
    AVOIDING = "avoiding"
    WAITING = "waiting"
    ARRIVED = "arrived"
    FAILED = "failed"


@dataclass
class Pose2D:
    """2D pose with position and orientation."""
    x: float
    y: float
    theta: float  # radians


@dataclass
class PathSegment:
    """Single path segment."""
    start: Pose2D
    end: Pose2D
    length: float
    duration: float


@dataclass
class NavigationPlan:
    """Complete navigation plan."""
    plan_id: str
    target_pose: Pose2D
    target_label: str
    path: List[PathSegment] = field(default_factory=list)
    waypoints: List[Pose2D] = field(default_factory=list)
    constraints: List[str] = field(default_factory=list)
    estimated_time: float = 0.0
    created_at: float = field(default_factory=time.time)


@dataclass
class NavigationStatus:
    """Current navigation status."""
    state: NavigationState
    current_pose: Pose2D
    target_pose: Pose2D
    progress: float  # 0.0 to 1.0
    distance_remaining: float
    time_elapsed: float
    last_waypoint: Optional[int] = None
    obstacle_count: int = 0
    replan_count: int = 0


class NavigationExecutor:
    """
    Execute navigation plans on humanoid robot.
    Handles path following, obstacle avoidance, and recovery.
    """

    def __init__(self, config: Dict = None):
        """Initialize navigation executor."""
        self.config = config or self._default_config()

        # State
        self.current_pose = None
        self.target_pose = None
        self.current_plan = None
        self.state = NavigationState.IDLE

        # Components
        self.local_planner = None
        self.global_planner = None
        self.localizer = None
        self.obstacle_avoider = None

        # Tracking
        self.waypoint_index = 0
        self.last_waypoint_time = None
        self.obstacle_encounters = 0
        self.replan_count = 0

        # Lock for thread safety
        self.lock = Lock()

        # Callbacks
        self.on_arrival = None
        self.on_obstacle = None
        self.on_failure = None

    def _default_config(self) -> Dict:
        """Default configuration."""
        return {
            'max_speed': 0.5,  # m/s
            'max_angular_speed': 1.0,  # rad/s
            'waypoint_tolerance': 0.3,  # meters
            'goal_tolerance': 0.5,  # meters
            'angular_tolerance': 0.2,  # radians
            'obstacle_avoidance_enabled': True,
            'replan_on_obstacle': True,
            'max_replans': 3,
            'wait_timeout': 10.0,  # seconds
            'safety_margin': 0.5  # meters from obstacles
        }

    def initialize(self, local_planner, global_planner,
                   localizer, obstacle_avoider):
        """Initialize navigation components."""
        self.local_planner = local_planner
        self.global_planner = global_planner
        self.localizer = localizer
        self.obstacle_avoider = obstacle_avoider
        print("Navigation executor initialized")

    def execute_plan(self, plan: NavigationPlan) -> NavigationStatus:
        """
        Execute a navigation plan.

        Args:
            plan: NavigationPlan to execute

        Returns:
            NavigationStatus with current state
        """
        with self.lock:
            self.current_plan = plan
            self.target_pose = plan.target_pose
            self.waypoint_index = 0
            self.obstacle_encounters = 0
            self.replan_count = 0
            self.state = NavigationState.PLANNING

        start_time = time.time()

        try:
            # Generate global path if needed
            if not plan.path:
                self.state = NavigationState.PLANNING
                self._generate_global_path(plan)

            # Navigate through waypoints
            self.state = NavigationState.MOVING
            for i, waypoint in enumerate(plan.waypoints):
                status = self._navigate_to_waypoint(waypoint)
                self.waypoint_index = i

                if status['success']:
                    continue
                elif status['replan']:
                    # Retry with replan
                    if self.replan_count < self.config['max_replans']:
                        self.replan_count += 1
                        if self._replan_around_obstacle(status['obstacle_pos']):
                            continue
                    else:
                        self.state = NavigationState.FAILED
                        return self._create_status(start_time, "Max replans exceeded")

                else:  # failure
                    self.state = NavigationState.FAILED
                    return self._create_status(start_time, status['reason'])

            # Final approach to goal
            final_status = self._approach_goal()
            if not final_status['success']:
                self.state = NavigationState.FAILED
                return self._create_status(start_time, final_status['reason'])

            self.state = NavigationState.ARRIVED
            return self._create_status(start_time, None)

        except Exception as e:
            self.state = NavigationState.FAILED
            return self._create_status(start_time, str(e))

    def _generate_global_path(self, plan: NavigationPlan):
        """Generate global path from current pose to goal."""
        current_pose = self.localizer.get_pose()

        if self.global_planner:
            path = self.global_planner.plan(current_pose, plan.target_pose)
            plan.path = path['segments']
            plan.waypoints = path['waypoints']
        else:
            # Simple direct path
            plan.waypoints = [plan.target_pose]

        # Calculate estimated time
        total_distance = sum(seg.length for seg in plan.path)
        plan.estimated_time = total_distance / self.config['max_speed']

    def _navigate_to_waypoint(self, waypoint: Pose2D) -> Dict:
        """Navigate to a single waypoint."""
        self.last_waypoint_time = time.time()

        while True:
            # Update current pose
            self.current_pose = self.localizer.get_pose()

            # Check if reached waypoint
            distance = self._distance(self.current_pose, waypoint)
            if distance < self.config['waypoint_tolerance']:
                return {'success': True}

            # Check for timeout
            if (time.time() - self.last_waypoint_time) > self.config['wait_timeout']:
                return {'success': False, 'reason': 'Waypoint timeout'}

            # Check for obstacles
            if self.config['obstacle_avoidance_enabled']:
                obstacle_check = self._check_obstacles()
                if obstacle_check['obstacle_detected']:
                    self.obstacle_encounters += 1
                    if self.config['replan_on_obstacle']:
                        return {
                            'success': False,
                            'replan': True,
                            'obstacle_pos': obstacle_check['position']
                        }
                    else:
                        self.state = NavigationState.WAITING
                        time.sleep(0.5)
                        self.state = NavigationState.MOVING

            # Execute local planning step
            if self.local_planner:
                velocity = self.local_planner.compute_velocity(
                    self.current_pose, waypoint
                )
                self._execute_velocity(velocity)

            time.sleep(0.05)  # Control loop rate

    def _check_obstacles(self) -> Dict:
        """Check for obstacles in path."""
        if not self.obstacle_avoider:
            return {'obstacle_detected': False}

        # Get robot footprint
        robot_pose = self.localizer.get_pose()

        # Check for obstacles
        obstacles = self.obstacle_avoider.detect_obstacles(
            robot_pose,
            detection_range=1.0
        )

        if obstacles:
            return {
                'obstacle_detected': True,
                'position': obstacles[0]['position'],
                'type': obstacles[0]['type']
            }

        return {'obstacle_detected': False}

    def _replan_around_obstacle(self, obstacle_pos) -> bool:
        """Replan path around detected obstacle."""
        self.state = NavigationState.AVOIDING

        # Get current waypoint as reference
        if self.waypoint_index < len(self.current_plan.waypoints):
            current_waypoint = self.current_plan.waypoints[self.waypoint_index]
        else:
            current_waypoint = self.target_pose

        # Generate avoidance path
        if self.local_planner:
            avoidance_path = self.local_planner.plan_around_obstacle(
                self.current_pose,
                current_waypoint,
                obstacle_pos
            )

            if avoidance_path:
                # Insert avoidance waypoints
                self.current_plan.waypoints.insert(
                    self.waypoint_index + 1,
                    avoidance_path['via_point']
                )
                self.state = NavigationState.MOVING
                return True

        # Fallback: wait for obstacle to clear
        self.state = NavigationState.WAITING
        time.sleep(2.0)
        self.state = NavigationState.MOVING
        return True

    def _approach_goal(self) -> Dict:
        """Final approach to goal with precise positioning."""
        goal = self.target_pose
        start_pose = self.current_pose

        # Approach slowly for precision
        approach_speed = self.config['max_speed'] * 0.5

        while True:
            self.current_pose = self.localizer.get_pose()
            distance = self._distance(self.current_pose, goal)
            angle_diff = self._angle_diff(
                self.current_pose.theta,
                goal.theta
            )

            # Check if reached
            if (distance < self.config['goal_tolerance'] and
                abs(angle_diff) < self.config['angular_tolerance']):
                return {'success': True}

            # Check if too far (something went wrong)
            if distance > self._distance(start_pose, goal) + 1.0:
                return {'success': False, 'reason': 'Drifted from goal'}

            # Execute approach
            if self.local_planner:
                velocity = self.local_planner.compute_velocity(
                    self.current_pose, goal, max_speed=approach_speed
                )
                self._execute_velocity(velocity)

            time.sleep(0.05)

    def _execute_velocity(self, velocity: Dict):
        """Execute velocity command on robot."""
        # Would interface with actual motor controller
        # This is a placeholder implementation
        pass

    def _distance(self, pose1: Pose2D, pose2: Pose2D) -> float:
        """Calculate Euclidean distance between poses."""
        return math.sqrt((pose1.x - pose2.x)**2 + (pose1.y - pose2.y)**2)

    def _angle_diff(self, angle1: float, angle2: float) -> float:
        """Calculate minimal angle difference."""
        diff = angle2 - angle1
        while diff > math.pi:
            diff -= 2 * math.pi
        while diff < -math.pi:
            diff += 2 * math.pi
        return diff

    def _create_status(self, start_time: float,
                       error: Optional[str]) -> NavigationStatus:
        """Create navigation status report."""
        if self.current_pose and self.target_pose:
            remaining = self._distance(self.current_pose, self.target_pose)
        else:
            remaining = 0.0

        if self.current_plan:
            total_distance = sum(seg.length for seg in self.current_plan.path)
            progress = 1.0 - (remaining / total_distance) if total_distance > 0 else 0.0
        else:
            progress = 0.0

        return NavigationStatus(
            state=self.state,
            current_pose=self.current_pose or Pose2D(0, 0, 0),
            target_pose=self.target_pose or Pose2D(0, 0, 0),
            progress=max(0.0, min(1.0, progress)),
            distance_remaining=remaining,
            time_elapsed=time.time() - start_time,
            last_waypoint=self.waypoint_index,
            obstacle_count=self.obstacle_encounters,
            replan_count=self.replan_count
        )

    def cancel_navigation(self):
        """Cancel current navigation."""
        with self.lock:
            self.state = NavigationState.IDLE
            self.current_plan = None
            self._execute_velocity({'linear': 0, 'angular': 0})

    def get_status(self) -> NavigationStatus:
        """Get current navigation status."""
        with self.lock:
            return self._create_status(
                self.current_plan.created_at if self.current_plan else time.time(),
                None
            )
```

## Global Path Planning

### Multi-Floor Navigation

```python
# Global path planning for complex environments
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from enum import Enum
import heapq


class EdgeType(Enum):
    """Types of traversable edges."""
    FLOOR = "floor"
    ELEVATOR = "elevator"
    RAMP = "ramp"
    STAIRS = "stairs"
    DOORWAY = "doorway"


@dataclass
class MapNode:
    """Node in navigation map."""
    node_id: str
    position: Tuple[float, float, float]
    room: str
    is_waypoint: bool = True
    connections: List[str] = None


@dataclass
class MapEdge:
    """Edge connecting map nodes."""
    edge_id: str
    from_node: str
    to_node: str
    edge_type: EdgeType
    length: float
    traversable: bool = True
    constraints: List[str] = None


@dataclass
class FloorPlan:
    """Floor plan with nodes and edges."""
    floor_id: str
    nodes: Dict[str, MapNode] = None
    edges: Dict[str, MapEdge] = None
    obstacles: List[Dict] = None


class GlobalPathPlanner:
    """
    Global path planner using graph-based navigation.
    Supports multi-floor buildings with elevators and stairs.
    """

    def __init__(self, config: Dict = None):
        """Initialize global planner."""
        self.config = config or {}
        self.floor_plans: Dict[str, FloorPlan] = {}
        self.transition_points: Dict[str, Dict] = {}  # elevator/stair nodes

        # Navigation graph
        self.graph: Dict[str, List[Tuple[str, float]]] = {}

    def add_floor_plan(self, floor: FloorPlan):
        """Add a floor plan to the navigation map."""
        self.floor_plans[floor.floor_id] = floor

        # Build floor graph
        self._build_floor_graph(floor)

    def _build_floor_graph(self, floor: FloorPlan):
        """Build navigation graph from floor plan."""
        for edge_id, edge in (floor.edges or {}).items():
            if not edge.traversable:
                continue

            # Add edge to graph
            if edge.from_node not in self.graph:
                self.graph[edge.from_node] = []
            if edge.to_node not in self.graph:
                self.graph[edge.to_node] = []

            self.graph[edge.from_node].append((edge.to_node, edge.length))
            self.graph[edge.to_node].append((edge.from_node, edge.length))

        # Add waypoint connections
        for node_id, node in (floor.nodes or {}).items():
            if node_id not in self.graph:
                self.graph[node_id] = []

    def add_transition(self, transition_type: str,
                       floors: List[str],
                       nodes: List[str]):
        """Add floor transition (elevator, stairs)."""
        self.transition_points[f"{transition_type}_{'_'.join(floors)}"] = {
            'type': transition_type,
            'floors': floors,
            'nodes': nodes,
            'wait_time': 30.0 if transition_type == 'elevator' else 10.0
        }

    def plan(self, start_pose: Tuple, goal_pose: Tuple,
             current_floor: str) -> Dict:
        """
        Plan path from start to goal.

        Args:
            start_pose: (x, y, theta) start position
            goal_pose: (x, y, theta) goal position
            current_floor: Current floor ID

        Returns:
            Path planning result with segments
        """
        # Find nearest nodes
        start_node = self._find_nearest_node(start_pose, current_floor)
        goal_node = self._find_nearest_node(goal_pose, current_floor)

        if not start_node or not goal_node:
            return {
                'success': False,
                'reason': 'Could not find path nodes'
            }

        # Check if same floor
        goal_floor = self._get_node_floor(goal_node)

        if current_floor == goal_floor:
            # Single floor navigation
            return self._plan_single_floor(start_node, goal_node)

        # Multi-floor navigation
        return self._plan_multi_floor(start_node, current_floor,
                                      goal_node, goal_floor)

    def _plan_single_floor(self, start_node: str,
                           goal_node: str) -> Dict:
        """Plan path on single floor using A*."""
        if start_node == goal_node:
            return {
                'success': True,
                'segments': [],
                'waypoints': [],
                'total_length': 0.0
            }

        # A* search
        path, length = self._astar_search(start_node, goal_node)

        if not path:
            return {
                'success': False,
                'reason': 'No path found'
            }

        # Build segments
        segments = self._path_to_segments(path)
        waypoints = self._path_to_waypoints(path)

        return {
            'success': True,
            'segments': segments,
            'waypoints': waypoints,
            'total_length': length
        }

    def _plan_multi_floor(self, start_node: str, start_floor: str,
                          goal_node: str, goal_floor: str) -> Dict:
        """Plan path across multiple floors."""
        path = [start_node]

        # Find transition points
        transition = self._find_transition(start_floor, goal_floor)

        if not transition:
            return {
                'success': False,
                'reason': f'No transition between {start_floor} and {goal_floor}'
            }

        # Plan to transition point
        enter_transition = transition['nodes'][0]
        to_transition, _ = self._astar_search(start_node, enter_transition)
        path.extend(to_transition[:-1])

        # Add transition
        path.extend(transition['nodes'])

        # Plan from transition to goal
        exit_transition = transition['nodes'][-1]
        from_transition, _ = self._astar_search(exit_transition, goal_node)
        path.extend(from_transition)

        segments = self._path_to_segments(path)
        waypoints = self._path_to_waypoints(path)

        # Add transition time
        transition_time = transition['wait_time']

        return {
            'success': True,
            'segments': segments,
            'waypoints': waypoints,
            'total_length': self._calculate_path_length(path),
            'transition_time': transition_time,
            'multi_floor': True
        }

    def _astar_search(self, start: str, goal: str) -> Tuple[List[str], float]:
        """A* search algorithm."""
        # Heuristic: straight-line distance
        def heuristic(node):
            node_pos = self._get_node_position(node)
            goal_pos = self._get_node_position(goal)
            return math.sqrt(
                (node_pos[0] - goal_pos[0])**2 +
                (node_pos[1] - goal_pos[1])**2
            )

        # Priority queue: (f_score, node)
        open_set = [(heuristic(start), start)]
        came_from = {}
        g_score = {start: 0}
        f_score = {start: heuristic(start)}

        closed_set = set()

        while open_set:
            _, current = heapq.heappop(open_set)

            if current == goal:
                # Reconstruct path
                path = [current]
                while current in came_from:
                    current = came_from[current]
                    path.append(current)
                path.reverse()
                return path, g_score[goal]

            if current in closed_set:
                continue
            closed_set.add(current)

            # Check neighbors
            for neighbor, edge_length in self.graph.get(current, []):
                if neighbor in closed_set:
                    continue

                tentative_g = g_score.get(current, float('inf')) + edge_length

                if tentative_g < g_score.get(neighbor, float('inf')):
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score[neighbor] = tentative_g + heuristic(neighbor)
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))

        return [], 0.0

    def _find_nearest_node(self, pose: Tuple, floor: str) -> Optional[str]:
        """Find nearest navigation node to pose."""
        floor_plan = self.floor_plans.get(floor)
        if not floor_plan or not floor_plan.nodes:
            return None

        min_dist = float('inf')
        nearest = None

        px, py, _ = pose

        for node_id, node in floor_plan.nodes.items():
            nx, ny, _ = node.position
            dist = math.sqrt((px - nx)**2 + (py - ny)**2)

            if dist < min_dist:
                min_dist = dist
                node_id = node_id

        return nearest if min_dist < 5.0 else None

    def _find_transition(self, floor1: str, floor2: str) -> Optional[Dict]:
        """Find transition point between floors."""
        for trans_id, trans in self.transition_points.items():
            if floor1 in trans['floors'] and floor2 in trans['floors']:
                return trans
        return None

    def _get_node_position(self, node_id: str) -> Tuple[float, float, float]:
        """Get position of a node."""
        for floor in self.floor_plans.values():
            if node_id in floor.nodes:
                return floor.nodes[node_id].position
        return (0, 0, 0)

    def _get_node_floor(self, node_id: str) -> str:
        """Get floor containing a node."""
        for floor_id, floor in self.floor_plans.items():
            if node_id in floor.nodes:
                return floor_id
        return 'unknown'

    def _path_to_segments(self, path: List[str]) -> List[Dict]:
        """Convert node path to segments."""
        segments = []

        for i in range(len(path) - 1):
            from_pos = self._get_node_position(path[i])
            to_pos = self._get_node_position(path[i + 1])

            length = math.sqrt(
                (from_pos[0] - to_pos[0])**2 +
                (from_pos[1] - to_pos[1])**2
            )

            segments.append({
                'from': path[i],
                'to': path[i + 1],
                'length': length,
                'start': {'x': from_pos[0], 'y': from_pos[1]},
                'end': {'x': to_pos[0], 'y': to_pos[1]}
            })

        return segments

    def _path_to_waypoints(self, path: List[str]) -> List[Dict]:
        """Convert node path to waypoints."""
        waypoints = []
        for node_id in path:
            pos = self._get_node_position(node_id)
            waypoints.append({
                'x': pos[0],
                'y': pos[1],
                'theta': pos[2],
                'node_id': node_id
            })
        return waypoints

    def _calculate_path_length(self, path: List[str]) -> float:
        """Calculate total path length."""
        total = 0.0
        for i in range(len(path) - 1):
            pos1 = self._get_node_position(path[i])
            pos2 = self._get_node_position(path[i + 1])
            total += math.sqrt(
                (pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2
            )
        return total
```

## Connection to Capstone

| Capstone Stage | How This Section Helps |
|----------------|------------------------|
| **Voice** | Navigation goals extracted from voice commands (e.g., "go to kitchen") |
| **Plan** | Plans include navigation steps that this system executes |
| **Execute** | This IS core execution - converting plans to robot movement |
| **Recover** | Navigation failures trigger replanning to alternative paths |

:::tip Capstone Integration
Your humanoid's navigation system bridges planning and action:
1. **Receive goal** → "navigate to living room" from voice pipeline
2. **Find path** → A* search through floor plan graph
3. **Execute motion** → follow waypoints with obstacle avoidance
4. **Handle transitions** → wait for elevator, climb stairs
5. **Confirm arrival** → report success to task executor
:::

## Next Steps

With navigation execution complete, the robot can now move to target locations. The next section explores Navigate-to-Manipulate for integrating manipulation with navigation.
