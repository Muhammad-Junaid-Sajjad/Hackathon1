---
id: m4-c3-s5
title: Optional Physical Deployment
sidebar_position: 5
keywords: ['physical', 'deployment', 'robot', 'real-world']
---

# Optional Physical Deployment

This capstone section covers deploying the tested system to physical humanoid robot hardware. This is an optional but highly recommended step that bridges simulation and real-world operation. Physical deployment introduces new challenges including sensor calibration, hardware variation, and environmental differences from simulation.

For students with access to humanoid robot hardware, this section provides the procedures and code to transfer your simulation-validated system to real hardware.

## Prerequisites

Before starting this section, you should have completed:
- M4-C3-S4 (Simulation Testing) - all benchmarks passed in simulation
- Access to supported robot hardware (Unitree H1, TIAGo, etc.)
- Site-specific safety training and authorization
- Understanding of real-world sensor calibration

## Learning Objectives

| Level | Objective |
|-------|-----------|
| **[Beginner]** | Describe the challenges of sim-to-real transfer |
| **[Beginner]** | Identify hardware requirements for physical deployment |
| **[Intermediate]** | Implement hardware connection and calibration procedures |
| **[Intermediate]** | Configure site-specific deployment settings |
| **[Advanced]** | Architect safe deployment pipelines with comprehensive safety checks |
| **[Advanced]** | Design real-world test suites that validate simulation results |

## Key Concepts

| Term | Definition |
|------|------------|
| **Hardware Spec** | Technical specifications of the physical robot platform |
| **Sim-to-Real Gap** | Differences between simulated and real-world behavior |
| **Site Config** | Environment-specific settings (WiFi, floorplan, obstacles) |
| **Safety Checklist** | Pre-deployment verification of emergency stop, battery, sensors |
| **Deployment Manager** | System that orchestrates hardware connection and initialization |
| **Real-World Test** | Validation of robot performance in physical environment |
| **Calibration** | Adjusting sensors and motors to match expected behavior |

## Hardware Requirements

### Robot Platform Specifications

```python
# Physical deployment configuration
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum


class RobotType(Enum):
    """Supported robot platforms."""
    UNITREE_H1 = "unitree_h1"
    Boston_Dynamics_Atlas = "atlas"
    Pepper = "pepper"
    TIAGo = "tiago"
    Custom = "custom"


@dataclass
class HardwareSpec:
    """Hardware specification for robot."""
    robot_type: RobotType
    dof: int  # Degrees of freedom
    arm_span: float  # meters
    height: float  # meters
    weight: float  # kg
    max_payload: float  # kg
    max_speed: float  # m/s
    battery_capacity: float  # Wh
    runtime: float  # hours

    # Sensor specifications
    cameras: int = 2
    lidar: bool = False
    depth_sensors: int = 0
    microphones: int = 4

    # Computation
    onboard_computer: str = ""
    gpu: str = ""


# Known robot specifications
ROBOT_SPECS = {
    RobotType.UNITREE_H1: HardwareSpec(
        robot_type=RobotType.UNITREE_H1,
        dof=19,
        arm_span=1.5,
        height=1.8,
        weight=50,
        max_payload=5,
        max_speed=1.5,
        battery_capacity=900,
        runtime=2.0,
        cameras=2,
        lidar=False,
        depth_sensors=0,
        microphones=4,
        onboard_computer="NVIDIA Jetson Orin",
        gpu="Orin GPU"
    ),
    RobotType.Pepper: HardwareSpec(
        robot_type=RobotType.Pepper,
        dof=20,
        arm_span=1.2,
        height=1.2,
        weight=28,
        max_payload=0.5,
        max_speed=0.5,
        battery_capacity=700,
        runtime=1.5,
        cameras=3,
        lidar=False,
        depth_sensors=1,
        microphones=4,
        onboard_computer="Intel Atom",
        gpu="None"
    ),
    RobotType.TIAGo: HardwareSpec(
        robot_type=RobotType.TIAGo,
        dof=18,
        arm_span=1.4,
        height=1.35,
        weight=54,
        max_payload=6,
        max_speed=1.0,
        battery_capacity=1200,
        runtime=3.0,
        cameras=2,
        lidar=True,
        depth_sensors=2,
        microphones=4,
        onboard_computer="NVIDIA Jetson TX2",
        gpu="TX2 GPU"
    )
}


@dataclass
class DeploymentConfig:
    """Configuration for physical deployment."""
    robot_type: RobotType
    robot_ip: str = "192.168.1.100"
    robot_port: int = 9559

    # Network configuration
    wifi_ssid: str = ""
    wifi_password: str = ""
    use_ethernet: bool = True

    # Computation offloading
    edge_server_ip: str = ""
    edge_server_port: int = 8080
    use_computation_offloading: bool = False

    # Safety settings
    enable_emergency_stop: bool = True
    max_joint_velocity: float = 0.5
    max_joint_acceleration: float = 1.0
    force_limits: Dict[str, float] = field(default_factory=lambda: {
        'left_arm': 10.0,
        'right_arm': 10.0,
        'torso': 20.0,
        'legs': 30.0
    })

    # Calibration
    calibrate_sensors_on_start: bool = True
    calibrate_motors_on_start: bool = True


class HardwareInterface:
    """
    Hardware interface for physical robot control.
    Abstracts robot-specific details for common operations.
    """

    def __init__(self, config: DeploymentConfig):
        """Initialize hardware interface."""
        self.config = config
        self.robot_type = config.robot_type
        self.spec = ROBOT_SPECS.get(config.robot_type)

        # Connection state
        self.is_connected = False
        self.is_calibrated = False

        # Hardware components
        self.joint_controller = None
        self.sensor_interface = None
        self.camera_interface = None
        self.mic_array = None

    def connect(self) -> bool:
        """
        Connect to robot hardware.

        Returns:
            True if connected successfully
        """
        print(f"Connecting to {self.robot_type.value} at {self.config.robot_ip}...")

        # Robot-specific connection logic
        if self.robot_type == RobotType.UNITREE_H1:
            return self._connect_unitree()
        elif self.robot_type == RobotType.Pepper:
            return self._connect_pepper()
        elif self.robot_type == RobotType.TIAGo:
            return self._connect_tiago()
        else:
            return self._connect_generic()

    def _connect_unitree(self) -> bool:
        """Connect to Unitree H1 robot."""
        # Would use Unitree SDK
        try:
            # Placeholder for actual connection
            self.is_connected = True
            print("Connected to Unitree H1")
            return True
        except Exception as e:
            print(f"Connection failed: {e}")
            return False

    def _connect_pepper(self) -> bool:
        """Connect to Pepper robot."""
        # Would use NAOqi SDK
        self.is_connected = True
        print("Connected to Pepper")
        return True

    def _connect_tiago(self) -> bool:
        """Connect to TIAGo robot."""
        # Would use ROS/TIAGo SDK
        self.is_connected = True
        print("Connected to TIAGo")
        return True

    def _connect_generic(self) -> bool:
        """Generic robot connection."""
        self.is_connected = True
        return True

    def calibrate(self) -> bool:
        """
        Calibrate robot sensors and motors.

        Returns:
            True if calibration successful
        """
        if not self.is_connected:
            print("Not connected to robot")
            return False

        print("Calibrating sensors...")
        sensor_ok = self._calibrate_sensors()

        if not sensor_ok:
            print("Sensor calibration failed")
            return False

        if self.config.calibrate_motors_on_start:
            print("Calibrating motors...")
            motor_ok = self._calibrate_motors()
            if not motor_ok:
                print("Motor calibration failed")
                return False

        self.is_calibrated = True
        print("Calibration complete")
        return True

    def _calibrate_sensors(self) -> bool:
        """Calibrate sensors."""
        # Camera calibration
        if self.camera_interface:
            if not self.camera_interface.calibrate():
                return False

        # Microphone calibration
        if self.mic_array:
            if not self.mic_array.calibrate():
                return False

        return True

    def _calibrate_motors(self) -> bool:
        """Calibrate motors."""
        # Would find motor zero positions
        return True

    def disconnect(self):
        """Disconnect from robot hardware."""
        if self.is_connected:
            print("Disconnecting from robot...")
            self.is_connected = False
            self.is_calibrated = False

    def get_joint_positions(self) -> Dict[str, float]:
        """Get current joint positions."""
        if not self.is_connected:
            return {}
        return self.joint_controller.get_positions()

    def get_joint_velocities(self) -> Dict[str, float]:
        """Get current joint velocities."""
        if not self.is_connected:
            return {}
        return self.joint_controller.get_velocities()

    def set_joint_positions(self, positions: Dict[str, float],
                            duration: float = 1.0) -> bool:
        """
        Set target joint positions.

        Args:
            positions: Dictionary of joint_name -> position (radians)
            duration: Time to reach position

        Returns:
            True if command sent successfully
        """
        if not self.is_connected:
            return False

        # Apply velocity limits
        limited_positions = self._apply_velocity_limits(positions)

        return self.joint_controller.set_positions(limited_positions, duration)

    def set_joint_velocities(self, velocities: Dict[str, float]) -> bool:
        """
        Set target joint velocities.

        Args:
            velocities: Dictionary of joint_name -> velocity (rad/s)

        Returns:
            True if command sent successfully
        """
        if not self.is_connected:
            return False

        return self.joint_controller.set_velocities(velocities)

    def _apply_velocity_limits(self, positions: Dict[str, float]) -> Dict[str, float]:
        """Apply velocity limits to prevent rapid movements."""
        current = self.get_joint_positions()
        max_delta = self.config.max_joint_velocity

        limited = {}
        for joint, target in positions.items():
            if joint in current:
                delta = abs(target - current[joint])
                if delta > max_delta:
                    # Clamp movement
                    direction = 1 if target > current[joint] else -1
                    limited[joint] = current[joint] + direction * max_delta
                else:
                    limited[joint] = target
            else:
                limited[joint] = target

        return limited

    def get_camera_images(self) -> Dict[str, bytes]:
        """Get images from all cameras."""
        if not self.camera_interface:
            return {}
        return self.camera_interface.get_images()

    def get_microphone_audio(self, duration: float = 1.0) -> Dict:
        """Get audio from microphone array."""
        if not self.mic_array:
            return {}
        return self.mic_array.get_audio(duration)

    def get_imu_data(self) -> Dict:
        """Get IMU data."""
        if not self.sensor_interface:
            return {}
        return self.sensor_interface.get_imu()

    def get_foot_pressures(self) -> Dict[str, float]:
        """Get foot pressure sensor data."""
        if not self.sensor_interface:
            return {}
        return self.sensor_interface.get_foot_pressures()

    def execute_emergency_stop(self):
        """Execute emergency stop."""
        print("EMERGENCY STOP ACTIVATED")
        if self.joint_controller:
            self.joint_controller.set_velocities({})
            self.joint_controller.set_positions(
                self.get_joint_positions()  # Hold current position
            )
```

## Sensor Calibration

### Camera and Microphone Setup

```python
# Sensor calibration procedures
from typing import Dict, List, Optional, Tuple
import numpy as np


class CameraCalibrator:
    """
    Camera calibration for humanoid robot.
    Handles intrinsic and extrinsic calibration.
    """

    def __init__(self, camera_interface):
        """Initialize calibrator."""
        self.camera = camera_interface
        self.intrinsics = {}
        self.extrinsics = {}

    def calibrate_intrinsics(self, camera_name: str,
                            calibration_images: List[np.ndarray]) -> Dict:
        """
        Calibrate camera intrinsics using chessboard images.

        Args:
            camera_name: Name of camera to calibrate
            calibration_images: List of chessboard images

        Returns:
            Intrinsic parameters
        """
        # Chessboard parameters
        board_size = (9, 6)  # Interior corners
        square_size = 0.025  # 25mm squares

        # Prepare object points
        obj_points = []
        img_points = []

        objp = np.zeros((board_size[0] * board_size[1], 3), np.float32)
        objp[:, :2] = np.mgrid[0:board_size[0], 0:board_size[1]].T.reshape(-1, 2)
        objp *= square_size

        # Process calibration images
        for gray in calibration_images:
            # Find chessboard corners
            ret, corners = self._find_chessboard_corners(gray, board_size)

            if ret:
                obj_points.append(objp)
                img_points.append(corners)

        if len(img_points) < 10:
            return {'success': False, 'error': 'Not enough valid images'}

        # Calibrate
        ret, intrinsics, dist_coeffs, rvecs, tvecs = cv2.calibrateCamera(
            obj_points, img_points, gray.shape[::-1], None, None
        )

        if ret:
            self.intrinsics[camera_name] = {
                'camera_matrix': intrinsics,
                'distortion_coefficients': dist_coeffs,
                'reprojection_error': ret
            }

            return {
                'success': True,
                'camera_matrix': intrinsics.tolist(),
                'distortion': dist_coeffs.tolist(),
                'reprojection_error': ret
            }

        return {'success': False, 'error': 'Calibration failed'}

    def _find_chessboard_corners(self, image: np.ndarray,
                                  board_size: Tuple) -> Tuple:
        """Find chessboard corners in image."""
        import cv2

        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) if len(image.shape) == 3 else image

        ret, corners = cv2.findChessboardCorners(
            gray, board_size, None,
            cv2.CALIB_CB_ADAPTIVE_THRESH + cv2.CALIB_CB_NORMALIZE_IMAGE
        )

        if ret:
            # Refine corners
            criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
            corners = cv2.cornerSubPix(gray, corners, (11, 11), (-1, -1), criteria)

        return ret, corners

    def calibrate_extrinsics(self, camera_name: str,
                            target_pose: Dict) -> Dict:
        """
        Calibrate camera extrinsics (position relative to robot).

        Args:
            camera_name: Name of camera
            target_pose: Known pose of calibration target

        Returns:
            Extrinsic parameters
        """
        # Would use known target position to compute camera pose
        return {'success': True}


class MicrophoneCalibrator:
    """
    Microphone array calibration.
    Handles beamforming weights and noise cancellation.
    """

    def __init__(self, mic_interface):
        """Initialize calibrator."""
        self.mic = mic_interface
        self.calibration_data = {}

    def calibrate_beamforming(self, calibration_audio: np.ndarray,
                             source_direction: float) -> Dict:
        """
        Calibrate beamforming weights.

        Args:
            calibration_audio: Audio from calibration
            source_direction: Known direction of source (radians)

        Returns:
            Beamforming weights
        """
        # Would compute optimal weights for beamforming
        # based on known source direction

        self.calibration_data['beamforming_weights'] = {
            'direction': source_direction,
            'weights': np.random.randn(4).tolist(),  # Placeholder
            'quality': 0.95
        }

        return self.calibration_data['beamforming_weights']

    def calibrate_noise_cancellation(self, noise_samples: np.ndarray) -> Dict:
        """Calibrate noise cancellation parameters."""
        # Would compute noise profile and cancellation filters

        self.calibration_data['noise_cancellation'] = {
            'noise_profile': np.mean(noise_samples, axis=0).tolist(),
            'filter_coeffs': np.random.randn(64).tolist(),
            'quality': 0.9
        }

        return self.calibration_data['noise_cancellation']

    def calibrate_volume(self, target_db: float = -26) -> Dict:
        """Calibrate microphone volume levels."""
        # Would adjust input gain for consistent levels

        self.calibration_data['volume'] = {
            'target_db': target_db,
            'gain': 1.0,
            'offset_db': 0.0
        }

        return self.calibration_data['volume']

    def save_calibration(self, filepath: str):
        """Save calibration data to file."""
        import json

        with open(filepath, 'w') as f:
            json.dump(self.calibration_data, f)

    def load_calibration(self, filepath: str):
        """Load calibration data from file."""
        import json

        with open(filepath, 'r') as f:
            self.calibration_data = json.load(f)


class IMUCalibrator:
    """
    IMU calibration and bias estimation.
    """

    def __init__(self, sensor_interface):
        """Initialize calibrator."""
        self.sensor = sensor_interface
        self.bias = {'accel': np.zeros(3), 'gyro': np.zeros(3)}
        self.scale = {'accel': np.ones(3), 'gyro': np.ones(3)}

    def collect_samples(self, duration: float = 10.0) -> Dict:
        """Collect IMU samples for calibration."""
        samples = {
            'accel': [],
            'gyro': []
        }

        # Collect samples over duration
        import time
        end_time = time.time() + duration

        while time.time() < end_time:
            data = self.sensor.get_imu()
            samples['accel'].append(data.get('acceleration', np.zeros(3)))
            samples['gyro'].append(data.get('angular_velocity', np.zeros(3)))

        return samples

    def calibrate_static(self, samples: Dict) -> Dict:
        """
        Calibrate IMU assuming stationary.

        Assumes robot is stationary during calibration.
        """
        accel_samples = np.array(samples['accel'])
        gyro_samples = np.array(samples['gyro'])

        # Accelerometer: should measure gravity only
        # When stationary, magnitude should be ~9.81 m/s^2
        # Bias is average offset from expected
        expected_accel = np.array([0, 0, 9.81])
        self.bias['accel'] = np.mean(accel_samples, axis=0) - expected_accel

        # Gyro: should measure zero when stationary
        self.bias['gyro'] = np.mean(gyro_samples, axis=0)

        return {
            'accel_bias': self.bias['accel'].tolist(),
            'gyro_bias': self.bias['gyro'].tolist()
        }

    def apply_calibration(self, raw_data: Dict) -> Dict:
        """Apply calibration to raw IMU data."""
        accel = np.array(raw_data.get('acceleration', np.zeros(3)))
        gyro = np.array(raw_data.get('angular_velocity', np.zeros(3)))

        # Apply bias correction
        accel_corrected = accel - self.bias['accel']
        gyro_corrected = gyro - self.bias['gyro']

        return {
            'acceleration': accel_corrected.tolist(),
            'angular_velocity': gyro_corrected.tolist(),
            'orientation': raw_data.get('orientation', None)
        }
```

## Real-World Testing

### Field Deployment Procedures

```python
# Real-world testing procedures
from typing import Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime
import json


@dataclass
class DeploymentSite:
    """Physical deployment site information."""
    name: str
    address: str
    floorplan_path: str
    obstacles: List[Dict]
    charging_station_location: Tuple[float, float]
    wifi_networks: List[Dict]
    emergency_contact: str

    # Environmental factors
    lighting_conditions: str
    noise_level: str
    floor_surface: str


@dataclass
class DeploymentLog:
    """Log of deployment activities."""
    timestamp: datetime
    event_type: str
    description: str
    data: Dict
    success: bool


class PhysicalDeploymentManager:
    """
    Manage physical deployment of humanoid robot.
    """

    def __init__(self, hardware_interface: HardwareInterface):
        """Initialize deployment manager."""
        self.hardware = hardware_interface
        self.site: Optional[DeploymentSite] = None
        self.deployment_logs: List[DeploymentLog] = []
        self.is_deployed = False

        # Safety checks
        self.safety_checklist = [
            'emergency_stop_tested',
            'battery_checked',
            'joints_freely_moving',
            'sensors_clean',
            'environment_cleared'
        ]

    def setup_site(self, site: DeploymentSite):
        """Configure for deployment site."""
        self.site = site
        self._log_event('site_setup', f"Setting up at {site.name}", {'site': site.name})

        # Configure WiFi
        self._configure_wifi(site.wifi_networks)

        # Load floorplan
        self._load_floorplan(site.floorplan_path)

        # Configure obstacle map
        self._configure_obstacles(site.obstacles)

        self._log_event('site_setup_complete', "Site configuration complete", {})

    def _configure_wifi(self, networks: List[Dict]):
        """Configure WiFi connection."""
        for network in networks:
            self._log_event('wifi_config', f"Configuring {network.get('ssid', 'unknown')}", {})
            # Would configure network connection

    def _load_floorplan(self, floorplan_path: str):
        """Load and process floorplan."""
        self._log_event('floorplan_loaded', f"Loaded floorplan from {floorplan_path}", {})
        # Would load and process floorplan for navigation

    def _configure_obstacles(self, obstacles: List[Dict]):
        """Configure known obstacles."""
        self._log_event('obstacles_configured', f"Configured {len(obstacles)} obstacles", {
            'count': len(obstacles)
        })
        # Would add obstacles to navigation system

    def run_safety_check(self) -> Dict:
        """
        Run safety checklist before deployment.

        Returns:
            Safety check results
        """
        results = {}
        all_passed = True

        # Emergency stop test
        results['emergency_stop_tested'] = self._test_emergency_stop()
        all_passed = all_passed and results['emergency_stop_tested']

        # Battery check
        results['battery_checked'] = self._check_battery()
        all_passed = all_passed and results['battery_checked']

        # Joint freedom check
        results['joints_freely_moving'] = self._check_joint_freedom()
        all_passed = all_passed and results['joints_freely_moving']

        # Sensor check
        results['sensors_clean'] = self._check_sensors()
        all_passed = all_passed and results['sensors_clean']

        # Environment check
        results['environment_cleared'] = self._check_environment()
        all_passed = all_passed and results['environment_cleared']

        self._log_event('safety_check', "Safety check completed", results)

        return {
            'all_passed': all_passed,
            'checks': results
        }

    def _test_emergency_stop(self) -> bool:
        """Test emergency stop functionality."""
        # Would test that emergency stop works
        return True

    def _check_battery(self) -> bool:
        """Check battery level."""
        # Would check actual battery level
        return True

    def _check_joint_freedom(self) -> bool:
        """Check that joints can move freely."""
        # Would command small movements and verify
        return True

    def _check_sensors(self) -> bool:
        """Check that sensors are clean and functional."""
        # Would check camera images, microphone levels
        return True

    def _check_environment(self) -> bool:
        """Check that environment is safe for operation."""
        # Would verify no obstacles, adequate lighting
        return True

    def deploy(self) -> Dict:
        """
        Deploy robot to operation.

        Returns:
            Deployment status
        """
        if not self.site:
            return {'success': False, 'error': 'No site configured'}

        # Run safety check
        safety = self.run_safety_check()
        if not safety['all_passed']:
            return {
                'success': False,
                'error': 'Safety check failed',
                'details': safety
            }

        # Connect to hardware
        if not self.hardware.connect():
            return {'success': False, 'error': 'Hardware connection failed'}

        # Calibrate
        if not self.hardware.calibrate():
            return {'success': False, 'error': 'Calibration failed'}

        # Initialize navigation with site map
        self._initialize_navigation()

        # Initialize speech system
        self._initialize_speech()

        self.is_deployed = True
        self._log_event('deployment', "Robot deployed successfully", {})

        return {
            'success': True,
            'site': self.site.name,
            'timestamp': datetime.now().isoformat()
        }

    def _initialize_navigation(self):
        """Initialize navigation with site information."""
        self._log_event('navigation_init', "Initializing navigation", {})
        # Would initialize navigation with floorplan and obstacles

    def _initialize_speech(self):
        """Initialize speech recognition with environment adaptation."""
        self._log_event('speech_init', "Initializing speech system", {})
        # Would initialize speech with microphone calibration

    def undeploy(self):
        """Undeploy robot and return to charging."""
        if self.is_deployed:
            self._log_event('undeployment', "Undeploying robot", {})

            # Return to charging station
            self._return_to_charging()

            # Disconnect
            self.hardware.disconnect()

            self.is_deployed = False

            self._log_event('undeployment_complete', "Robot undeployed", {})

    def _return_to_charging(self):
        """Navigate back to charging station."""
        if self.site:
            goal = self.site.charging_station_location
            # Would navigate to charging station
            self._log_event('charging', "Returning to charging station", {
                'location': goal
            })

    def _log_event(self, event_type: str, description: str, data: Dict):
        """Log deployment event."""
        log = DeploymentLog(
            timestamp=datetime.now(),
            event_type=event_type,
            description=description,
            data=data,
            success=True
        )
        self.deployment_logs.append(log)

    def get_deployment_report(self) -> Dict:
        """Generate deployment report."""
        return {
            'site': self.site.name if self.site else None,
            'deployed': self.is_deployed,
            'logs': [
                {
                    'timestamp': log.timestamp.isoformat(),
                    'type': log.event_type,
                    'description': log.description,
                    'data': log.data
                }
                for log in self.deployment_logs
            ]
        }


class RealWorldTestRunner:
    """
    Run tests in real-world environment.
    """

    def __init__(self, deployment_manager: PhysicalDeploymentManager):
        """Initialize test runner."""
        self.deployment = deployment_manager
        self.results: List[Dict] = []

    def run_real_world_tests(self) -> Dict:
        """Run comprehensive real-world tests."""
        results = []

        # Navigation tests
        results.append(self._test_navigation())
        results.append(self._test_obstacle_avoidance())

        # Manipulation tests
        results.append(self._test_grasp())
        results.append(self._test_place())

        # Integration tests
        results.append(self._test_voice_commands())
        results.append(self._test_multi_turn_dialogue())

        # Stress tests
        results.append(self._test_battery_usage())
        results.append(self._test_continuous_operation())

        return {
            'total_tests': len(results),
            'passed': sum(1 for r in results if r['passed']),
            'failed': sum(1 for r in results if not r['passed']),
            'results': results
        }

    def _test_navigation(self) -> Dict:
        """Test navigation in real environment."""
        return {'test': 'navigation', 'passed': True, 'note': 'Real-world test'}

    def _test_obstacle_avoidance(self) -> Dict:
        """Test obstacle avoidance."""
        return {'test': 'obstacle_avoidance', 'passed': True}

    def _test_grasp(self) -> Dict:
        """Test grasping in real environment."""
        return {'test': 'grasp', 'passed': True}

    def _test_place(self) -> Dict:
        """Test placing objects."""
        return {'test': 'place', 'passed': True}

    def _test_voice_commands(self) -> Dict:
        """Test voice command recognition."""
        return {'test': 'voice_commands', 'passed': True}

    def _test_multi_turn_dialogue(self) -> Dict:
        """Test multi-turn dialogue."""
        return {'test': 'multi_turn_dialogue', 'passed': True}

    def _test_battery_usage(self) -> Dict:
        """Test battery consumption."""
        return {'test': 'battery_usage', 'passed': True}

    def _test_continuous_operation(self) -> Dict:
        """Test continuous operation over time."""
        return {'test': 'continuous_operation', 'passed': True}
```

## Connection to Capstone

| Capstone Stage | How This Section Helps |
|----------------|------------------------|
| **Voice** | Real microphones require acoustic calibration for noise rejection |
| **Plan** | Physical constraints may require plan parameter adjustments |
| **Execute** | Hardware latency and motor characteristics differ from simulation |
| **Recover** | Real-world failures need robust recovery with safety guarantees |

:::tip Capstone Integration
Physical deployment is the ultimate validation of your humanoid system:
1. **Calibrate hardware** → match simulation expectations to real motors/sensors
2. **Configure site** → load environment map and obstacle locations
3. **Safety check** → verify emergency stop, battery, sensor health
4. **Deploy** → initialize navigation, speech, and manipulation systems
5. **Test** → run real-world test suite to validate sim-to-real transfer
:::

## Next Steps

With physical deployment complete, you can now assess the capstone performance using the assessment rubric. The next section provides evaluation criteria for measuring your achievement of the learning objectives.
