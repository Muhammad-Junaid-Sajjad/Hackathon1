---
id: m4-c3-s3
title: "Capstone Part 3: Navigate to Manipulate"
sidebar_position: 3
keywords: ['capstone', 'manipulation', 'navigation', 'pipeline']
---

# Capstone Part 3: Navigate to Manipulate

This capstone section focuses on integrating navigation with manipulation to enable complete task execution. We build upon the navigation system from Part 2 and add manipulation capabilities, allowing the robot to move to objects, pick them up, and perform actions with them.

For humanoid robots, the ability to navigate to locations and manipulate objects is fundamental to performing useful household and industrial tasks.

## Prerequisites

Before starting this section, you should have completed:
- M4-C3-S1 and S2 (Voice-to-Plan and Plan-to-Navigate) - prior capstone stages
- M2-C1 (Control) - manipulation control, grasping
- M3-C3 (Perception for Manipulation) - object detection, grasp point estimation
- Understanding of task sequencing and dependency management

## Learning Objectives

| Level | Objective |
|-------|-----------|
| **[Beginner]** | Describe how navigation and manipulation combine for complete tasks |
| **[Beginner]** | Identify the phases of a navigate-to-manipulate task |
| **[Intermediate]** | Implement integrated task execution with approach and retreat phases |
| **[Intermediate]** | Configure task coordinators for multi-step sequences |
| **[Advanced]** | Architect parallel task execution with dependency management |
| **[Advanced]** | Design robust pick-and-place pipelines with failure recovery |

## Key Concepts

| Term | Definition |
|------|------------|
| **Task Phase** | Stage of execution (planning, navigating, approaching, manipulating, retreating) |
| **Manipulation Target** | Object to be grasped with location and approach constraints |
| **Approach Direction** | Vector indicating how to approach an object for grasping |
| **Grasp Points** | Locations on an object suitable for robot grip |
| **Task Sequence** | Ordered list of steps with dependencies |
| **Task Coordinator** | System managing multi-step task execution with parallelism |
| **Retreat Phase** | Safe withdrawal after manipulation completes |

## Navigation to Manipulation Pipeline

### Integrated Task Execution

```python
# Navigate to Manipulate integration pipeline
import time
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum
from threading import Lock
import math


class TaskPhase(Enum):
    """Phases of a navigation-to-manipulation task."""
    PLANNING = "planning"
    NAVIGATING = "navigating"
    APPROACHING = "approaching"
    MANIPULATING = "manipulating"
    RETREATING = "retreating"
    COMPLETED = "completed"
    FAILED = "failed"


@dataclass
class ManipulationTarget:
    """Target object for manipulation."""
    object_id: str
    object_type: str
    location: Tuple[float, float, float]
    approach_direction: Tuple[float, float, float] = None
    grasp_points: List[Tuple] = None
    constraints: List[str] = field(default_factory=list)


@dataclass
class NavigateManipulateTask:
    """Complete task with navigation and manipulation."""
    task_id: str
    target: ManipulationTarget
    navigation_goal: Tuple[float, float, float]
    manipulation_action: str
    success_criteria: List[str] = field(default_factory=list)
    estimated_duration: float = 0.0
    max_retries: int = 2


@dataclass
class TaskStatus:
    """Status of navigate-manipulate task."""
    task_id: str
    phase: TaskPhase
    progress: float  # 0.0 to 1.0
    current_pose: Tuple[float, float, float]
    navigation_progress: float
    manipulation_progress: float
    failures: int = 0
    last_error: Optional[str] = None


class NavigateManipulatePipeline:
    """
    Pipeline for integrated navigation and manipulation tasks.
    Combines navigation execution with object manipulation.
    """

    def __init__(self, config: Dict = None):
        """Initialize the pipeline."""
        self.config = config or self._default_config()

        # Components (set during initialization)
        self.navigation_executor = None
        self.manipulation_controller = None
        self.localizer = None
        self.perception = None

        # State
        self.current_task: Optional[NavigateManipulateTask] = None
        self.current_phase = TaskPhase.PLANNING
        self.task_lock = Lock()

        # Statistics
        self.stats = {
            'total_tasks': 0,
            'successful_tasks': 0,
            'failed_tasks': 0,
            'avg_duration': 0.0
        }

    def _default_config(self) -> Dict:
        """Default configuration."""
        return {
            'approach_distance': 0.5,  # meters before manipulation
            'retreat_distance': 0.3,  # meters to retreat after manipulation
            'grasp_timeout': 10.0,  # seconds
            'verification_attempts': 3,
            'max_task_duration': 120.0,  # seconds
            'enable_approach_verification': True,
            'approach_speed': 0.2  # m/s during approach
        }

    def initialize(self, navigation_executor, manipulation_controller,
                   localizer, perception):
        """Initialize pipeline components."""
        self.navigation_executor = navigation_executor
        self.manipulation_controller = manipulation_controller
        self.localizer = localizer
        self.perception = perception
        print("Navigate-to-Manipulate pipeline initialized")

    def execute_task(self, task: NavigateManipulateTask) -> TaskStatus:
        """
        Execute a navigate-manipulate task.

        Args:
            task: NavigateManipulateTask to execute

        Returns:
            TaskStatus with final result
        """
        with self.task_lock:
            self.current_task = task
            self.current_phase = TaskPhase.PLANNING
            self.stats['total_tasks'] += 1

        start_time = time.time()
        task_status = None

        try:
            # Phase 1: Plan the approach
            self.current_phase = TaskPhase.PLANNING
            approach_plan = self._plan_approach(task)
            if not approach_plan['success']:
                return self._create_failed_status(task, approach_plan['reason'], start_time)

            # Phase 2: Navigate to goal position
            self.current_phase = TaskPhase.NAVIGATING
            nav_status = self._navigate_to_goal(task.navigation_goal)
            if not nav_status['success']:
                if task_failures < task.max_retries:
                    task_failures += 1
                    # Retry with offset
                    offset_goal = self._apply_navigation_offset(task.navigation_goal)
                    nav_status = self._navigate_to_goal(offset_goal)
                if not nav_status['success']:
                    return self._create_failed_status(task, nav_status['reason'], start_time)

            # Phase 3: Approach the target
            self.current_phase = TaskPhase.APPROACHING
            approach_status = self._approach_target(task, approach_plan)
            if not approach_status['success']:
                return self._create_failed_status(task, approach_status['reason'], start_time)

            # Phase 4: Perform manipulation
            self.current_phase = TaskPhase.MANIPULATING
            manip_status = self._perform_manipulation(task)
            if not manip_status['success']:
                # Try recovery
                recovery_status = self._attempt_recovery(task)
                if not recovery_status['success']:
                    return self._create_failed_status(task, manip_status['reason'], start_time)

            # Phase 5: Retreat
            self.current_phase = TaskPhase.RETREATING
            retreat_status = self._retreat_from_target(task)
            if not retreat_status['success']:
                # Retreat failure is not critical
                pass

            # Phase 6: Completed
            self.current_phase = TaskPhase.COMPLETED
            self.stats['successful_tasks'] += 1
            self._update_avg_duration(time.time() - start_time)

            return TaskStatus(
                task_id=task.task_id,
                phase=TaskPhase.COMPLETED,
                progress=1.0,
                current_pose=self.localizer.get_pose(),
                navigation_progress=1.0,
                manipulation_progress=1.0
            )

        except Exception as e:
            self.stats['failed_tasks'] += 1
            return self._create_failed_status(task, str(e), start_time)

    task_failures = 0  # Track retries

    def _plan_approach(self, task: NavigateManipulateTask) -> Dict:
        """Plan the approach to manipulation target."""
        target_pose = task.target.location

        # Get approach direction based on object type
        approach_direction = task.target.approach_direction
        if not approach_direction:
            approach_direction = self._compute_approach_direction(task)

        # Plan navigation goal (offset from target)
        offset_distance = self.config['approach_distance']
        goal = (
            target_pose[0] - approach_direction[0] * offset_distance,
            target_pose[1] - approach_direction[1] * offset_distance,
            target_pose[2] - approach_direction[2] * offset_distance
        )

        # Verify goal is reachable
        if not self._is_reachable(goal):
            # Try alternative approach
            for alt_direction in self._get_alternative_directions(approach_direction):
                alt_goal = (
                    target_pose[0] - alt_direction[0] * offset_distance,
                    target_pose[1] - alt_direction[1] * offset_distance,
                    target_pose[2] - alt_direction[2] * offset_distance
                )
                if self._is_reachable(alt_goal):
                    return {
                        'success': True,
                        'goal': alt_goal,
                        'approach_direction': alt_direction
                    }

            return {
                'success': False,
                'reason': 'Cannot find reachable approach position'
            }

        return {
            'success': True,
            'goal': goal,
            'approach_direction': approach_direction
        }

    def _compute_approach_direction(self, task: NavigateManipulateTask) -> Tuple:
        """Compute optimal approach direction for target."""
        # Default: approach from front (negative x direction)
        # In practice, would use object affordances and constraints
        return (-1.0, 0.0, 0.0)

    def _get_alternative_directions(self, primary: Tuple) -> List[Tuple]:
        """Get alternative approach directions."""
        return [
            (1.0, 0.0, 0.0),   # Opposite
            (0.0, -1.0, 0.0),  # Left
            (0.0, 1.0, 0.0),   # Right
            (-0.7, -0.7, 0.0), # Diagonal
            (-0.7, 0.7, 0.0)   # Diagonal
        ]

    def _is_reachable(self, pose: Tuple) -> bool:
        """Check if pose is reachable for navigation."""
        # Would check against map and obstacles
        return True

    def _navigate_to_goal(self, goal: Tuple) -> Dict:
        """Navigate to a goal position."""
        from dataclasses import replace

        # Create navigation plan
        from .s2 import NavigationPlan, Pose2D

        target_pose = Pose2D(x=goal[0], y=goal[1], theta=goal[2])
        plan = NavigationPlan(
            plan_id=f"nav_{int(time.time())}",
            target_pose=target_pose,
            target_label="manipulation_approach"
        )

        # Execute navigation
        status = self.navigation_executor.execute_plan(plan)

        if status.state.value in ['arrived']:
            return {'success': True}
        elif status.state.value == 'failed':
            return {'success': False, 'reason': status.last_error or 'Navigation failed'}
        else:
            return {'success': False, 'reason': f'Unexpected state: {status.state}'}

    def _apply_navigation_offset(self, original_goal: Tuple,
                                  offset: float = 0.3) -> Tuple:
        """Apply offset to navigation goal."""
        return (
            original_goal[0] + offset,
            original_goal[1] + offset,
            original_goal[2]
        )

    def _approach_target(self, task: NavigateManipulateTask,
                         approach_plan: Dict) -> Dict:
        """Approach the manipulation target."""
        if not self.config['enable_approach_verification']:
            return {'success': True}

        # Get current pose
        current_pose = self.localizer.get_pose()
        target_pose = task.target.location

        # Calculate distance to target
        distance = self._calculate_distance(current_pose, target_pose)

        # Approach slowly
        while distance > self.config['approach_distance']:
            # Get direction to target
            direction = self._get_direction(current_pose, target_pose)

            # Move toward target
            velocity = {
                'linear': self.config['approach_speed'],
                'angular': direction[2]
            }
            self._execute_velocity(velocity)

            # Update pose
            current_pose = self.localizer.get_pose()
            distance = self._calculate_distance(current_pose, target_pose)

            # Check timeout
            if distance > self.config['max_task_duration']:
                return {'success': False, 'reason': 'Approach timeout'}

        # Verify we can see/manipulate the target
        for attempt in range(self.config['verification_attempts']):
            perception_result = self.perception.detect_object(task.target.object_id)
            if perception_result['detected']:
                return {'success': True}
            time.sleep(0.2)

        return {'success': False, 'reason': 'Cannot verify target object'}

    def _perform_manipulation(self, task: NavigateManipulateTask) -> Dict:
        """Perform the manipulation action."""
        # Configure manipulation controller
        self.manipulation_controller.set_target(task.target.object_id)
        self.manipulation_controller.set_action(task.manipulation_action)

        # Execute manipulation with timeout
        start_time = time.time()
        while time.time() - start_time < self.config['grasp_timeout']:
            result = self.manipulation_controller.execute()

            if result['success']:
                return {'success': True}

            if result['retry']:
                continue

            return {'success': False, 'reason': result.get('error', 'Manipulation failed')}

        return {'success': False, 'reason': 'Manipulation timeout'}

    def _attempt_recovery(self, task: NavigateManipulateTask) -> Dict:
        """Attempt recovery from manipulation failure."""
        # Back up and retry
        retreat_result = self._retreat_from_target(task)
        if not retreat_result['success']:
            return {'success': False, 'reason': 'Recovery failed'}

        # Retry manipulation
        return self._perform_manipulation(task)

    def _retreat_from_target(self, task: NavigateManipulateTask) -> Dict:
        """Retreat from manipulation target."""
        current_pose = self.localizer.get_pose()
        target_pose = task.target.location

        # Calculate retreat direction (away from target)
        retreat_direction = self._get_direction(current_pose, target_pose)
        retreat_direction = (-retreat_direction[0], -retreat_direction[1], 0)

        # Move away
        retreat_distance = self.config['retreat_distance']
        retreat_pose = (
            current_pose[0] + retreat_direction[0] * retreat_distance,
            current_pose[1] + retreat_direction[1] * retreat_distance,
            current_pose[2]
        )

        return self._navigate_to_goal(retreat_pose)

    def _calculate_distance(self, pose1: Tuple, pose2: Tuple) -> float:
        """Calculate Euclidean distance between poses."""
        return math.sqrt(
            (pose1[0] - pose2[0])**2 +
            (pose1[1] - pose2[1])**2 +
            (pose1[2] - pose2[2])**2
        )

    def _get_direction(self, from_pose: Tuple, to_pose: Tuple) -> Tuple:
        """Get direction vector from one pose to another."""
        dx = to_pose[0] - from_pose[0]
        dy = to_pose[1] - from_pose[1]
        distance = math.sqrt(dx**2 + dy**2)

        if distance < 0.001:
            return (0, 0, 0)

        return (dx / distance, dy / distance, math.atan2(dy, dx))

    def _execute_velocity(self, velocity: Dict):
        """Execute velocity command."""
        # Would interface with motor controller
        pass

    def _create_failed_status(self, task: NavigateManipulateTask,
                              error: str, start_time: float) -> TaskStatus:
        """Create failed task status."""
        self.stats['failed_tasks'] += 1
        self.current_phase = TaskPhase.FAILED

        return TaskStatus(
            task_id=task.task_id,
            phase=TaskPhase.FAILED,
            progress=0.0,
            current_pose=self.localizer.get_pose(),
            navigation_progress=0.0,
            manipulation_progress=0.0,
            last_error=error
        )

    def _update_avg_duration(self, duration: float):
        """Update average task duration."""
        total = self.stats['successful_tasks']
        current = self.stats['avg_duration']
        self.stats['avg_duration'] = ((current * (total - 1)) + duration) / total

    def get_pipeline_status(self) -> Dict:
        """Get current pipeline status."""
        return {
            'current_phase': self.current_phase.value,
            'task_id': self.current_task.task_id if self.current_task else None,
            'statistics': {
                'total_tasks': self.stats['total_tasks'],
                'success_rate': (
                    self.stats['successful_tasks'] / self.stats['total_tasks']
                    if self.stats['total_tasks'] > 0 else 0.0
                ),
                'avg_duration': self.stats['avg_duration']
            }
        }
```

## Object Manipulation Actions

### Grasping and Placement

```python
# Object manipulation actions
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from enum import Enum
import numpy as np


class ManipulationType(Enum):
    """Types of manipulation actions."""
    GRASP = "grasp"
    PLACE = "place"
    PUSH = "push"
    PULL = "pull"
    ROTATE = "rotate"
    LIFT = "lift"
    LOWER = "lower"
    POUR = "pour"


@dataclass
class GraspPoint:
    """Point for grasping an object."""
    position: Tuple[float, float, float]
    normal: Tuple[float, float, float]
    quality: float  # 0.0 to 1.0
    approach_direction: Tuple[float, float, float]


@dataclass
class ManipulationAction:
    """Manipulation action specification."""
    action_type: ManipulationType
    target_object: str
    parameters: Dict = None
    force_limits: Dict = None
    speed: float = 0.5


class ManipulationController:
    """
    Controller for object manipulation actions.
    Handles grasping, placing, and other manipulation tasks.
    """

    def __init__(self, config: Dict = None):
        """Initialize manipulation controller."""
        self.config = config or {}

        # Arm controllers
        self.left_arm = None
        self.right_arm = None
        self.gripper = None

        # State
        self.current_object = None
        self.is_grasping = False
        self.grasp_quality = 0.0

        # Grasp database
        self.grasp_database: Dict[str, List[GraspPoint]] = {}

    def set_target(self, object_id: str):
        """Set the target object for manipulation."""
        self.current_object = object_id

    def set_action(self, action: str):
        """Set the manipulation action."""
        self.current_action = action

    def execute(self) -> Dict:
        """Execute the current manipulation action."""
        if not self.current_object:
            return {'success': False, 'error': 'No target object set'}

        action_map = {
            'pick': self._grasp,
            'pick_up': self._grasp,
            'grab': self._grasp,
            'put': self._place,
            'place': self._place,
            'put_down': self._place,
            'push': self._push,
            'pull': self._pull,
            'rotate': self._rotate,
            'lift': self._lift,
            'lower': self._lower,
        }

        action_func = action_map.get(self.current_action, self._grasp)
        return action_func()

    def _grasp(self) -> Dict:
        """Grasp the current object."""
        if not self.current_object:
            return {'success': False, 'error': 'No object to grasp'}

        # Get grasp points for object
        grasp_points = self._get_grasp_points(self.current_object)
        if not grasp_points:
            return {'success': False, 'error': 'No valid grasp points'}

        # Select best grasp point
        best_grasp = max(grasp_points, key=lambda g: g.quality)

        # Move arm to grasp position
        self._move_arm_to_grasp(best_grasp)

        # Close gripper
        gripper_result = self._close_gripper()
        if not gripper_result['success']:
            return {'success': False, 'error': gripper_result['error']}

        # Verify grasp
        if not self._verify_grasp():
            return {'success': False, 'error': 'Grasp verification failed', 'retry': True}

        self.is_grasping = True
        return {'success': True}

    def _place(self) -> Dict:
        """Place the current object."""
        if not self.is_grasping:
            return {'success': False, 'error': 'Not currently grasping'}

        # Move to place position (would be calculated based on task)
        place_position = self._get_place_position()

        # Move arm
        self._move_arm_to_position(place_position)

        # Open gripper
        gripper_result = self._open_gripper()
        if not gripper_result['success']:
            return {'success': False, 'error': gripper_result['error']}

        self.is_grasping = False
        return {'success': True}

    def _push(self) -> Dict:
        """Push an object."""
        # Would implement push trajectory
        return {'success': True}

    def _pull(self) -> Dict:
        """Pull an object."""
        # Would implement pull trajectory
        return {'success': True}

    def _rotate(self) -> Dict:
        """Rotate the grasped object."""
        if not self.is_grasping:
            return {'success': False, 'error': 'Not currently grasping'}

        # Would implement rotation
        return {'success': True}

    def _lift(self) -> Dict:
        """Lift the grasped object."""
        if not self.is_grasping:
            return {'success': False, 'error': 'Not currently grasping'}

        # Move arm upward
        lift_distance = self.config.get('lift_height', 0.1)
        self._move_arm_relative((0, 0, lift_distance))

        return {'success': True}

    def _lower(self) -> Dict:
        """Lower the grasped object."""
        if not self.is_grasping:
            return {'success': False, 'error': 'Not currently grasping'}

        # Move arm downward
        lower_distance = self.config.get('lower_height', 0.1)
        self._move_arm_relative((0, 0, -lower_distance))

        return {'success': True}

    def _get_grasp_points(self, object_id: str) -> List[GraspPoint]:
        """Get grasp points for an object."""
        if object_id in self.grasp_database:
            return self.grasp_database[object_id]

        # Would use perception to compute grasp points
        # Placeholder: return default grasp
        return [
            GraspPoint(
                position=(0.4, 0, 0.1),
                normal=(1, 0, 0),
                quality=0.8,
                approach_direction=(-1, 0, 0)
            )
        ]

    def _get_place_position(self) -> Tuple:
        """Get position for placing object."""
        # Would be calculated based on task and environment
        return (0.5, 0, 0.3)

    def _move_arm_to_grasp(self, grasp: GraspPoint):
        """Move arm to grasp position."""
        # Would interface with arm controller
        pass

    def _move_arm_to_position(self, position: Tuple):
        """Move arm to specific position."""
        # Would interface with arm controller
        pass

    def _move_arm_relative(self, delta: Tuple):
        """Move arm relatively."""
        # Would interface with arm controller
        pass

    def _close_gripper(self) -> Dict:
        """Close the gripper."""
        # Would interface with gripper controller
        return {'success': True}

    def _open_gripper(self) -> Dict:
        """Open the gripper."""
        # Would interface with gripper controller
        return {'success': True}

    def _verify_grasp(self) -> bool:
        """Verify that the grasp is successful."""
        # Would check gripper force/position feedback
        return True
```

## Task Coordination

### Multi-Step Task Execution

```python
# Task coordination for complex operations
from typing import Dict, List, Optional
from dataclasses import dataclass
from enum import Enum


class TaskStatus(Enum):
    """Status of a task step."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"


@dataclass
class TaskStep:
    """Single step in a task sequence."""
    step_id: str
    description: str
    action: str
    target: str
    prerequisites: List[str] = None
    status: TaskStatus = TaskStatus.PENDING
    result: Dict = None


@dataclass
class TaskSequence:
    """Complete task sequence."""
    sequence_id: str
    name: str
    steps: List[TaskStep] = None
    parallel_steps: List[List[TaskStep]] = None


class TaskCoordinator:
    """
    Coordinate multi-step tasks.
    Handles dependencies and parallel execution.
    """

    def __init__(self):
        """Initialize task coordinator."""
        self.active_sequences: Dict[str, TaskSequence] = {}
        self.step_results: Dict[str, Dict] = {}

    def execute_sequence(self, sequence: TaskSequence) -> Dict:
        """Execute a task sequence."""
        self.active_sequences[sequence.sequence_id] = sequence

        results = []

        # Execute steps (handling dependencies)
        if sequence.parallel_steps:
            # Execute parallel step groups
            for step_group in sequence.parallel_steps:
                group_results = self._execute_parallel_steps(step_group)
                results.extend(group_results)
        else:
            # Execute steps sequentially
            for step in sequence.steps:
                # Check prerequisites
                if not self._check_prerequisites(step):
                    step.status = TaskStatus.SKIPPED
                    results.append({
                        'step_id': step.step_id,
                        'status': 'skipped',
                        'reason': 'Prerequisites not met'
                    })
                    continue

                # Execute step
                step_result = self._execute_step(step)
                step.result = step_result
                self.step_results[step.step_id] = step_result
                results.append(step_result)

                if not step_result['success'] and not step_result.get('continue_on_failure'):
                    break

        return {
            'sequence_id': sequence.sequence_id,
            'results': results,
            'all_completed': all(r['status'] == 'completed' for r in results)
        }

    def _execute_parallel_steps(self, steps: List[TaskStep]) -> List[Dict]:
        """Execute steps in parallel."""
        import concurrent.futures

        def run_step(step: TaskStep) -> Dict:
            return self._execute_step(step)

        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures = [executor.submit(run_step, step) for step in steps]
            results = [f.result() for f in concurrent.futures.as_completed(futures)]

        return results

    def _execute_step(self, step: TaskStep) -> Dict:
        """Execute a single step."""
        step.status = TaskStatus.IN_PROGRESS

        # Execute based on action type
        action_handlers = {
            'navigate': self._execute_navigate,
            'grasp': self._execute_grasp,
            'place': self._execute_place,
            'observe': self._execute_observe,
            'wait': self._execute_wait,
        }

        handler = action_handlers.get(step.action, self._default_execute)
        result = handler(step)

        step.status = TaskStatus.COMPLETED if result['success'] else TaskStatus.FAILED
        return {
            'step_id': step.step_id,
            'action': step.action,
            'target': step.target,
            'status': 'completed' if result['success'] else 'failed',
            'success': result['success'],
            'result': result
        }

    def _check_prerequisites(self, step: TaskStep) -> bool:
        """Check if prerequisites are met."""
        if not step.prerequisites:
            return True

        for prereq in step.prerequisites:
            if prereq not in self.step_results:
                return False
            if not self.step_results[prereq].get('success', False):
                return False

        return True

    def _execute_navigate(self, step: TaskStep) -> Dict:
        """Execute navigation step."""
        # Would interface with navigation system
        return {'success': True}

    def _execute_grasp(self, step: TaskStep) -> Dict:
        """Execute grasp step."""
        # Would interface with manipulation system
        return {'success': True}

    def _execute_place(self, step: TaskStep) -> Dict:
        """Execute place step."""
        # Would interface with manipulation system
        return {'success': True}

    def _execute_observe(self, step: TaskStep) -> Dict:
        """Execute observe step."""
        # Would interface with perception system
        return {'success': True}

    def _execute_wait(self, step: TaskStep) -> Dict:
        """Execute wait step."""
        import time
        duration = step.parameters.get('duration', 1.0)
        time.sleep(duration)
        return {'success': True}

    def _default_execute(self, step: TaskStep) -> Dict:
        """Default step execution."""
        return {'success': True}
```

## Connection to Capstone

| Capstone Stage | How This Section Helps |
|----------------|------------------------|
| **Voice** | "Pick up the cup from the kitchen" becomes a navigate-manipulate task |
| **Plan** | Task coordinator breaks high-level goals into nav+manip sequences |
| **Execute** | This IS the core execution loop combining movement and object interaction |
| **Recover** | Failed grasps trigger re-approach or replanning |

:::tip Capstone Integration
Your humanoid's full task execution combines previous stages:
1. **Receive plan** → "fetch cup" from LLM planner
2. **Navigate** → move to kitchen using S2 navigation
3. **Approach** → fine positioning near the cup
4. **Manipulate** → grasp the cup using M2 control
5. **Retreat** → safely move away from obstacles
6. **Return** → navigate back with held object
:::

## Next Steps

With the Navigate-to-Manipulate pipeline complete, you can now execute complex tasks combining navigation and manipulation. The next section explores simulation testing to validate the integrated system before physical deployment.
