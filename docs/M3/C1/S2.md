---
id: m3-c1-s2
title: USD Format and Scene Composition
sidebar_position: 2
keywords: ['usd', 'scene', 'composition', 'format', 'prims', 'schemas']
---

# USD Format and Scene Composition

## Prerequisites

Before diving into this section, ensure you have:

- **Basic Python programming skills** - Familiarity with classes, functions, and object-oriented concepts
- **Understanding of 3D coordinate systems** - Knowledge of translation, rotation, and scale transformations in 3D space
- **Familiarity with scene graphs** - Basic understanding of hierarchical data structures and parent-child relationships
- **Isaac Sim installation complete** - A working Isaac Sim environment with Python API access (covered in Section 1)
- **Basic knowledge of file formats** - Understanding of structured data formats like JSON, XML, or YAML

## Learning Objectives

By the end of this section, you will be able to:

| Level | Objective |
|-------|-----------|
| **Beginner** | Define USD layers, prims, and attributes and identify their roles in scene composition |
| **Beginner** | Identify the differences between references and payloads in USD file organization |
| **Intermediate** | Implement USD stage creation and manipulation using the Python API (pxr library) |
| **Intermediate** | Configure USD schemas for physics, materials, and joint properties in robotics contexts |
| **Advanced** | Architect multi-layer scene compositions with proper naming conventions and spatial organization |
| **Advanced** | Optimize stage loading strategies for large-scale robotics simulations with level-of-detail management |

## Key Concepts

| Term | Definition |
|------|------------|
| **USD (Universal Scene Description)** | An open, extensible format developed by Pixar for representing, composing, and exchanging 3D content |
| **Stage** | The composed result of all active USD layers; the runtime representation of a scene |
| **Layer** | A file or in-memory container for USD scene data that can be composed with other layers |
| **Prim (Primitive)** | The fundamental unit of USD scene description; represents an object with attributes in the scene graph |
| **Schema** | A type definition that provides domain-specific functionality and typed attribute sets for prims |
| **Reference** | A composition mechanism that includes content from another USD file immediately |
| **Payload** | A composition mechanism similar to reference but with deferred loading for memory optimization |
| **Variant Set** | A mechanism for defining alternative representations of the same content (e.g., different robot configurations) |

---

The Universal Scene Description (USD) format serves as the foundational data representation for NVIDIA Omniverse and Isaac Sim. Originally developed by Pixar, USD has evolved into an open, extensible standard for representing, composing, and exchanging 3D content. Understanding USD is essential for working with Isaac Sim, as it defines how scenes are structured, how assets are referenced, and how animation and physics properties are stored. This section provides a comprehensive exploration of USD concepts, syntax, and best practices for robotics simulation workflows.

USD's design philosophy emphasizes non-destructive composition, allowing multiple layers of descriptions to be combined into a final scene. This capability is particularly valuable for robotics development, where different teams might work on robot design, environment construction, and simulation configuration independently, with the final scene composed from these contributions. The composable nature of USD enables version control of scene elements, easy iteration on designs, and streamlined collaboration across distributed teams.

## USD Architectural Foundation

### The USD Layer System

USD organizes scene descriptions into a hierarchical system of layers, where each layer contributes information to a composed stage. The layer system operates on a stack-based principle, with stronger layers overriding weaker ones when they describe the same scene element. This design enables powerful workflows where base robot designs can be established in reference layers, with customization applied in stronger layers without modifying the original assets.

A USD stage is the composed result of all active layers. When you open a stage file, USD loads the root layer and resolves all references, payloads, and sub-layers to create the final composed scene. The composition happens in real-time as you navigate the stage, allowing for efficient handling of large scenes without loading all data into memory simultaneously.

```python
# Understanding USD layer composition
from pxr import Usd, UsdGeom, UsdPhysics, Sdf, Gf
import omni.usd

# Create a new stage with explicit layer management
stage = Usd.Stage.CreateNew("humanoid_scene.usd")

# Create a root layer and set it as the target
root_layer = stage.GetRootLayer()
print(f"Root layer: {root_layer.GetIdentifier()}")

# Create a sub-layer for robot definitions
robot_layer = Sdf.Layer.CreateNew("robot_definitions.usd")
stage.GetSubLayerPaths().append("robot_definitions.usd")

# Create another sub-layer for environment
env_layer = Sdf.Layer.CreateNew("environment.usd")
stage.GetSubLayerPaths().append("environment.usd")

# Set edit target to work on a specific layer
stage.SetEditTarget(robot_layer)

# Now all changes go to the robot definitions layer
robot_prim = UsdGeom.Xform.Define(stage, "/Robot")
print(f"Editing on layer: {stage.GetEditTarget().GetLayer().GetIdentifier()}")

# Save all layers
stage.Save()
robot_layer.Save()
env_layer.Save()

# Print layer stack to verify composition
print("Active sub-layers:", stage.GetSubLayerPaths())
```

The layer system supports several composition mechanisms beyond simple sub-layering. References allow one layer to include all or part of another layer's content, while payloads provide the same capability with explicit loading control. Variants enable alternative representations of the same content, such as different robot configurations or environment lighting setups. These mechanisms can be combined to create sophisticated scene organization strategies.

### Prims and Attributes

The fundamental unit of USD scene description is the Prim (short for "primitive"). A prim represents an object in the scene and contains attributes that describe its properties. Prims form a tree structure that mirrors the scene graph, with parent-child relationships defining spatial and organizational hierarchies. Every prim has a type that determines what schemas (property sets) it supports and how it behaves in the scene.

USD defines several built-in prim types that cover common 3D concepts. Xform prims represent transformable objects and serve as the primary containers for other prims. Mesh prims store polygonal geometry with vertex positions, normals, and texture coordinates. Scope prims provide organizational grouping without spatial meaning. Points, BasisCurves, and other types handle specialized geometry representations. Additionally, custom prim types can be defined for application-specific needs.

```python
# Working with prims and attributes in USD
from pxr import Usd, UsdGeom, UsdPhysics, Gf, Sdf

# Open or create a stage
stage = Usd.Stage.CreateNew("robot_prims.usd")

# Create a hierarchy for humanoid robot
# Pelvis - the root of the robot hierarchy
pelvis = UsdGeom.Xform.Define(stage, "/Robot/Pelvis")
pelvis.GetXformOpOrderAttr().Set(["translate", "rotateXYZ", "scale"])

# Set transform attributes on the pelvis
pelvis.AddTranslateOp().Set(Gf.Vec3d(0, 1.0, 0))
pelvis.AddRotateXYZOp().Set(Gf.Vec3d(0, 0, 0))
pelvis.AddScaleOp().Set(Gf.Vec3d(1, 1, 1))

# Add physics attributes to the pelvis
UsdPhysics.RigidBodyAPI.Apply(pelvis.GetPrim())
UsdPhysics.MassAPI.Apply(pelvis.GetPrim())

# Set mass attribute
mass_api = UsdPhysics.MassAPI.Get(stage, "/Robot/Pelvis")
mass_api.GetMassAttr().Set(15.0)  # 15 kg pelvis mass

# Create child prims for major body segments
torso = UsdGeom.Xform.Define(stage, "/Robot/Pelvis/Torso")
head = UsdGeom.Xform.Define(stage, "/Robot/Pelvis/Torso/Head")
left_upper_arm = UsdGeom.Xform.Define(stage, "/Robot/Pelvis/Torso/LeftUpperArm")
right_upper_arm = UsdGeom.Xform.Define(stage, "/Robot/Pelvis/Torso/RightUpperArm")
left_thigh = UsdGeom.Xform.Define(stage, "/Robot/Pelvis/LeftThigh")
right_thigh = UsdGeom.Xform.Define(stage, "/Robot/Pelvis/RightThigh")

# Define mesh geometry for the torso
torso_mesh = UsdGeom.Mesh.Define(stage, "/Robot/Pelvis/Torso/Mesh")

# Set mesh vertex positions (box geometry)
points = [
    Gf.Vec3f(-0.15, 0.0, 0.08),   # front-top-left
    Gf.Vec3f(0.15, 0.0, 0.08),    # front-top-right
    Gf.Vec3f(0.15, 0.0, -0.08),   # front-bottom-right
    Gf.Vec3f(-0.15, 0.0, -0.08),  # front-bottom-left
    Gf.Vec3f(-0.15, 0.5, 0.08),   # back-top-left
    Gf.Vec3f(0.15, 0.5, 0.08),    # back-top-right
    Gf.Vec3f(0.15, 0.5, -0.08),   # back-bottom-right
    Gf.Vec3f(-0.15, 0.5, -0.08),  # back-bottom-left
]
torso_mesh.GetPointsAttr().Set(points)

# Set mesh face vertex indices (quads as two triangles each)
face_vertex_counts = [4, 4, 4, 4, 4, 4]  # 6 faces, each with 4 vertices
torso_mesh.GetFaceVertexCountsAttr().Set(face_vertex_counts)

face_vertex_indices = [
    0, 1, 5, 4,  # front face
    1, 2, 6, 5,  # right face
    2, 3, 7, 6,  # back face
    3, 0, 4, 7,  # left face
    4, 5, 6, 7,  # top face
    0, 3, 2, 1,  # bottom face (reversed for consistency)
]
torso_mesh.GetFaceVertexIndicesAttr().Set(face_vertex_indices)

# Access and modify attributes
def get_prim_attributes(prim_path):
    """Print all attributes of a prim."""
    prim = stage.GetPrimAtPath(prim_path)
    if not prim:
        print(f"Prim not found: {prim_path}")
        return

    print(f"\nAttributes for {prim_path}:")
    print(f"  Prim type: {prim.GetTypeName()}")

    for attr in prim.GetAttributes():
        print(f"  {attr.GetName()}: {attr.Get()}")
        print(f"    Type: {attr.GetTypeName()}")
        print(f"    Settled: {attr.IsSettled()}")


# Query prim attributes
get_prim_attributes("/Robot/Pelvis")
get_prim_attributes("/Robot/Pelvis/Torso/Mesh")

# Save the stage
stage.Save()
print("\nStage saved to robot_prims.usd")
```

Attributes in USD carry type information and can represent simple values (integers, floats, strings) or complex data (arrays, matrices, quaternion transformations). Each attribute has an owner (the prim it belongs to), a name, and a type. Attributes can be interpolated between keyframes, making USD an animation-capable format. The USD schema system extends prims with domain-specific APIs that add typed attribute sets for common use cases.

### USD Schemas and Type System

USD schemas provide domain-specific functionality through a type hierarchy and associated attribute sets. The schema system is extensible, allowing applications to define custom schemas that add specialized behavior to prims. Isaac Sim uses extensively modified schemas to represent robots, sensors, and simulation properties.

The USD schema system includes built-in schemas for geometry, shading, animation, and physics. Geometry schemas define properties for mesh vertices, normals, and UV coordinates. Shading schemas describe material assignments and rendering properties. Animation schemas manage time-sampled attributes for keyframe animation. Physics schemas, added through the USD Physics extension, describe rigid body dynamics, collision shapes, and joint constraints.

```python
# USD schema usage for robotics
from pxr import Usd, UsdGeom, UsdPhysics, UsdShade, Gf, Sdf

stage = Usd.Stage.CreateNew("robot_schemas.usd")

# Apply schemas to create a robot joint
joint_path = "/Robot/Pelvis/HipJoint"
joint = UsdPhysics.Joint.Define(stage, joint_path)

# Configure joint properties
joint.GetBody0Rel().SetTargets(["/Robot/Pelvis"])
joint.GetBody1Rel().SetTargets(["/Robot/Pelvis/LeftThigh"])

# Set joint frame transforms (local to each body)
local_pos0 = Gf.Vec3f(0, -0.075, 0)  # Hip pivot point
local_pos1 = Gf.Vec3f(0, 0.075, 0)   # Thigh connection point

joint.CreateLocalPos0Attr(local_pos0)
joint.CreateLocalPos1Attr(local_pos1)

# Create a revolute (hinge) joint
joint.CreateTypeAttr(UsdPhysics.Joint.TypeRevolute)

# Add joint limits
limits_api = UsdPhysics.LimitAPI.Apply(joint.GetPrim())
limits_api.CreateLowerLimitAttr(-1.2)  # -~69 degrees
limits_api.CreateUpperLimitAttr(0.5)   # ~29 degrees

# Add drive properties for motor control
drive_api = UsdPhysics.DriveAPI.Apply(joint.GetPrim())
drive_api.CreateTypeAttr(UsdPhysics.DriveAPI.DriveVelocity)
drive_api.CreateMaxForceAttr(50.0)
drive_api.CreateTargetVelocityAttr(0.0)

# Material schema for robot appearance
material_path = "/Looks/RobotMaterial"
material = UsdShade.Material.Define(stage, material_path)

# Create a PBR shader
pbr_shader = UsdShade.Shader.Define(stage, f"{material_path}/PBRShader")
pbr_shader.CreateIdAttr("UsdPreviewSurface")
pbr_shader.CreateInput("diffuseColor", Sdf.ValueTypeNames.Color3f).Set(Gf.Vec3f(0.3, 0.3, 0.35))
pbr_shader.CreateInput("roughness", Sdf.ValueTypeNames.Float).Set(0.4)
pbr_shader.CreateInput("metallic", Sdf.ValueTypeNames.Float).Set(0.8)

# Connect shader to material
material.CreateSurfaceOutput().ConnectToSource(pbr_shader.ConnectableAPI(), "surface")

# Apply material to robot prim
UsdShade.MaterialBindingAPI.Apply(stage.GetPrimAtPath("/Robot/Pelvis")).Bind(material)

print("Schema examples created successfully")
stage.Save()
```

## Scene Composition Patterns

### References and Payload Management

References and payloads are the primary mechanisms for composing scenes from multiple USD files. Both mechanisms include content from one layer into another, but with important operational differences. References include content immediately, while payloads defer loading until explicitly requested. This distinction affects performance and memory usage in large scenes.

References are ideal for including completed assets that don't need modification in the composed scene. When a robot model is finalized, it can be referenced into simulation scenes without risk of accidental modification. The reference mechanism preserves the identity of the referenced prim, allowing the original asset to be updated independently of the scenes that reference it.

```python
# USD reference and payload patterns
from pxd import Usd, UsdGeom, UsdReferences, UsdPayloads, Sdf, Gf

stage = Usd.Stage.CreateNew("composition.usd")

# Create a reference to a pre-built robot asset
robot_ref_path = "/Robot"
robot_prim = UsdGeom.Xform.Define(stage, robot_ref_path)

# Add reference to external USD file
references_api = UsdReferences.Get(stage, robot_ref_path)
references_api.AddReference(
    assetPath="assets/humanoid_v2.usd",
    primPath="/Robot"  # Path in the referenced file
)

# Use payloads for deferred loading (large assets)
payload_api = UsdPayloads.Get(stage, "/Environment/DetailedFactory")
payload_api.AddPayload(
    assetPath="environments/factory_detailed.usd",
    primPath="/Factory"
)

# Override specific attributes on referenced prims
# The reference must be opened with "over" edit target
stage.SetEditTarget(stage.GetRootLayer())

# Create override prim that modifies the reference
override_prim = stage.DefinePrim("/Robot/Override")
over = UsdGeom.Xform.Get(stage, "/Robot")

# Modify properties through the override
# Changes here will override values from the referenced file
if over.GetPrim().GetAttribute("xformOp:translate").IsAuthored():
    print("Can modify: translate operation exists in reference")

# Variant sets for configuration management
# A variant set allows switching between different configurations
vset_path = "/Robot/Geometry"
robot_prim = UsdGeom.Xform.Get(stage, "/Robot")

# Create variant set for robot configuration
vset = robot_prim.GetPrim().GetVariantSets().AddVariantSet("configuration")

# Add different configuration options
vset.AddVariant("standard")
vset.AddVariant("heavy_duty")
vset.AddVariant("lightweight")

# Set default configuration
vset.SetVariantSelection("standard")

# Author different content for each variant
for config in ["standard", "heavy_duty", "lightweight"]:
    vset.SetVariantSelection(config)
    with Usd.EditContext(stage, vset.GetVariantEditContext()):
        if config == "heavy_duty":
            # Add armor plating
            armor = UsdGeom.Mesh.Define(stage, "/Robot/ArmorPlate")
            armor.GetPointsAttr().Set([
                Gf.Vec3f(-0.2, 0, 0.1),
                Gf.Vec3f(0.2, 0, 0.1),
                Gf.Vec3f(0.2, 0.5, 0.1),
                Gf.Vec3f(-0.2, 0.5, 0.1),
            ])
        elif config == "lightweight":
            # Remove non-essential elements
            if stage.GetPrimAtPath("/Robot/OptionalParts"):
                stage.RemovePrim("/Robot/OptionalParts")

print("Composition patterns applied")
stage.Save()
```

Payloads are particularly useful for large environments or detailed assets that may not be needed immediately. When working with a robotics simulation, you might want to load the robot immediately but defer loading the factory environment until it's within view distance. Payloads can be selectively loaded and unloaded through the USD API, enabling level-of-detail systems and memory optimization strategies.

### Spatial Organization and Naming Conventions

Consistent spatial organization and naming conventions are essential for maintainable robotics projects. A well-organized scene hierarchy makes it easy to locate and modify elements, reduces naming conflicts, and improves script readability. The following conventions have proven effective for humanoid robot development.

The root of the scene should contain major divisions: the robot, the environment, and any special elements like lighting or camera setups. Each division should be prefixed with a category indicator (Robot, Env, Light, Camera) for easy identification. Within the robot hierarchy, body segments follow the anatomical structure, with descriptive names indicating the body part and side.

```python
# Recommended naming conventions and spatial organization
from pxr import Usd, UsdGeom, Gf

def create_robot_hierarchy(stage, robot_name="Humanoid"):
    """Create a properly organized robot hierarchy."""
    root = UsdGeom.Xform.Define(stage, f"/{robot_name}")

    # Major divisions at root level
    divisions = {
        "Pelvis": "Central body mass",
        "Torso": "Upper body structure",
        "Head": "Sensory and computation housing",
        "LeftArm": "Left upper extremity",
        "RightArm": "Right upper extremity",
        "LeftLeg": "Left lower extremity",
        "RightLeg": "Right lower extremity",
    }

    # Create body segment prims
    for segment_name, description in divisions.items():
        prim_path = f"/{robot_name}/{segment_name}"
        prim = UsdGeom.Xform.Define(stage, prim_path)
        print(f"Created {description}: {prim_path}")

    # Create detailed sub-hierarchy for left arm
    arm_segments = ["UpperArm", "Forearm", "Hand"]
    for segment in arm_segments:
        segment_path = f"/{robot_name}/LeftArm/{segment}"
        UsdGeom.Xform.Define(stage, segment_path)

        # Add end effector indicator for hands
        if segment == "Hand":
            end_effector_path = f"{segment_path}/EndEffector"
            UsdGeom.Xform.Define(stage, end_effector_path)
            UsdGeom.Xform.Define(stage, f"{end_effector_path}/Gripper")

    # Create joint hierarchy
    joint_parent_map = {
        "/Robot/LeftHip": "/Robot/Pelvis",
        "/Robot/LeftThigh": "/Robot/LeftHip",
        "/Robot/LeftShin": "/Robot/LeftThigh",
        "/Robot/LeftFoot": "/Robot/LeftShin",
        "/Robot/RightHip": "/Robot/Pelvis",
        "/Robot/RightThigh": "/Robot/RightHip",
        "/Robot/RightShin": "/Robot/RightThigh",
        "/Robot/RightFoot": "/Robot/RightShin",
        "/Robot/LeftShoulder": "/Robot/Torso",
        "/Robot/LeftUpperArm": "/Robot/LeftShoulder",
        "/Robot/LeftForearm": "/Robot/LeftUpperArm",
        "/Robot/RightShoulder": "/Robot/Torso",
        "/Robot/RightUpperArm": "/Robot/RightShoulder",
        "/Robot/RightForearm": "/Robot/RightUpperArm",
    }

    # Create joint prims
    for joint_path, parent_path in joint_parent_map.items():
        joint = UsdGeom.Xform.Define(stage, joint_path)
        # Store parent reference as metadata
        joint.GetPrim().SetInfo(UsdGeom.Tokens.apiName, parent_path)

    # Environment organization
    env_prims = [
        "/Env/Ground",
        "/Env/Lighting",
        "/Env/Obstacles",
        "/Env/Sensors",
    ]

    for env_path in env_prims:
        UsdGeom.Xform.Define(stage, env_path)

    print("\nRecommended scene structure:")
    print("  /Robot/")
    print("    /Pelvis")
    print("    /Torso")
    print("      /Head")
    print("      /LeftShoulder/")
    print("        /LeftUpperArm/")
    print("          /LeftForearm/")
    print("            /LeftHand/")
    print("              /EndEffector/")
    print("      /RightShoulder/ (similar structure)")
    print("    /LeftHip/")
    print("      /LeftThigh/")
    print("        /LeftShin/")
    print("          /LeftFoot/")
    print("    /RightHip/ (similar structure)")
    print("  /Env/")
    print("    /Ground")
    print("    /Lighting")
    print("    /Obstacles")
    print("    /Sensors")

    return root


# Create organized hierarchy
stage = Usd.Stage.CreateNew("organized_scene.usd")
create_robot_hierarchy(stage)
stage.Save()
```

## USD for Robot Description

### Converting URDF to USD

Many robotics applications use URDF (Unified Robot Description Format) as the standard robot description format. Isaac Sim provides utilities to convert URDF files to USD format, enabling existing robot descriptions to be used within the Omniverse ecosystem. Understanding this conversion process is important for integrating established robot models.

The conversion process maps URDF's link and joint structures to USD prims with appropriate schemas. Links become Xform prims with Mesh geometry for visual representation and Collision shapes for physics. Joints become USD Physics Joint prims with the appropriate joint type (revolute, prismatic, continuous, fixed). The conversion also handles material assignments, inertial properties, and transmission definitions.

```python
# URDF to USD conversion patterns
from pxr import Usd, UsdGeom, UsdPhysics, UsdShade, Gf, Sdf
import omni.isaac.core.utils.nucleus as nucleus_utils

def convert_urdf_to_usd(urdf_path, output_path, config=None):
    """
    Convert a URDF file to USD format.

    Args:
        urdf_path: Path to the input URDF file
        output_path: Path for the output USD file
        config: Optional configuration dictionary
    """
    stage = Usd.Stage.CreateNew(output_path)

    # URDF parsing would typically use an external library
    # This example shows the USD structure that results

    # Create robot root
    robot_root = UsdGeom.Xform.Define(stage, "/Robot")

    # Parse URDF links
    # Each link becomes a Xform with potentially multiple geometry types

    # Example: Pelvis link
    pelvis_path = "/Robot/Pelvis"
    pelvis = UsdGeom.Xform.Define(stage, pelvis_path)

    # Inertial properties (from URDF inertial element)
    UsdPhysics.RigidBodyAPI.Apply(pelvis.GetPrim())
    mass_api = UsdPhysics.MassAPI.Apply(pelvis.GetPrim())
    mass_api.GetMassAttr().Set(15.0)

    # Center of mass from URDF
    com_api = UsdPhysics.CenterOfMassAPI.Apply(pelvis.GetPrim())
    com_api.GetCenterOfMassAttr().Set(Gf.Vec3f(0, 0.05, 0))

    # Inertia tensor from URDF
    inertia_api = UsdPhysics.InertiaAPI.Apply(pelvis.GetPrim())
    inertia_api.GetDiagonalInertiaAttr().Set(Gf.Vec3f(0.1, 0.1, 0.15))
    inertia_api.GetPrincipalAxesAttr().Set(Gf.Quatf(1, 0, 0, 0))

    # Visual geometry (from URDF visual element)
    visual_mesh = UsdGeom.Mesh.Define(stage, f"{pelvis_path}/Visual")
    # Mesh data would be populated from URDF geometry

    # Collision geometry (from URDF collision element)
    collision_mesh = UsdGeom.Mesh.Define(stage, f"{pelvis_path}/Collision")
    # Collision mesh might be simplified

    # Apply collision API to collision geometry
    UsdPhysics.CollisionAPI.Apply(collision_mesh.GetPrim())

    # Process joints
    def process_joint(urdf_joint, stage, parent_link, child_link):
        """Convert a URDF joint to USD Physics Joint."""
        joint_path = f"{parent_link}/{urdf_joint.name}"

        joint = UsdPhysics.Joint.Define(stage, joint_path)

        # Set joint bodies
        joint.GetBody0Rel().SetTargets([Sdf.Path(parent_link)])
        joint.GetBody1Rel().SetTargets([Sdf.Path(child_link)])

        # Set joint frames
        joint.CreateLocalPos0Attr(Gf.Vec3f(*urdf_joint.origin.translation))
        joint.CreateLocalPos1Attr(Gf.Vec3f(0, 0, 0))

        # Convert joint type
        joint_type_map = {
            'revolute': UsdPhysics.Joint.TypeRevolute,
            'continuous': UsdPhysics.Joint.TypeRevolute,  # No limits
            'prismatic': UsdPhysics.Joint.TypePrismatic,
            'fixed': UsdPhysics.Joint.TypeFixed,
            'floating': UsdPhysics.Joint.TypeSpatial,
            'planar': UsdPhysics.Joint.TypePlanar,
        }

        joint.CreateTypeAttr(joint_type_map.get(urdf_joint.type, UsdPhysics.Joint.TypeUnknown))

        # Set axis
        if hasattr(urdf_joint, 'axis'):
            axis = urdf_joint.axis
            joint.CreateLocalAxisAttr(Gf.Vec3f(*axis))

        # Set limits if revolute or prismatic
        if urdf_joint.type in ['revolute', 'prismatic']:
            limit_api = UsdPhysics.LimitAPI.Apply(joint.GetPrim())
            if urdf_joint.limit.lower != 'unbounded':
                limit_api.CreateLowerLimitAttr(urdf_joint.limit.lower)
            if urdf_joint.limit.upper != 'unbounded':
                limit_api.CreateUpperLimitAttr(urdf_joint.limit.upper)

        return joint

    # Apply materials from URDF
    def apply_material(prim, material_name, color):
        """Apply a material to a prim."""
        mat_path = f"/Looks/{material_name}"
        material = UsdShade.Material.Define(stage, mat_path)

        pbr = UsdShade.Shader.Define(stage, f"{mat_path}/PBR")
        pbr.CreateIdAttr("UsdPreviewSurface")
        pbr.CreateInput("diffuseColor", Sdf.ValueTypeNames.Color3f).Set(Gf.Vec3f(*color))
        pbr.CreateInput("roughness", Sdf.ValueTypeNames.Float).Set(0.5)

        material.CreateSurfaceOutput().ConnectToSource(pbr.ConnectableAPI(), "surface")
        UsdShade.MaterialBindingAPI.Apply(prim).Bind(material)

    return stage


# Example usage
# stage = convert_urdf_to_usd(
#     urdf_path="robots/humanoid.urdf",
#     output_path="robots/humanoid.usd",
#     config={'convert_collision': True, 'merge_fixed_links': False}
# )
# stage.Save()
```

### Custom USD Schemas for Robotics

While USD's built-in schemas cover many robotics needs, custom schemas can add specialized functionality. Custom schemas define new prim types with associated attributes, providing type safety and semantic meaning. Isaac Sim extends USD with robotics-specific schemas through its articulation and sensor frameworks.

Creating custom schemas requires defining schema interfaces that extend USD base classes. The schema defines what attributes a prim of that type can have, providing type hints and default values. Custom schemas are registered with USD's schema registry and can be used in Python and C++ code.

```python
# Custom schema patterns for robotics
from pxr import Usd, UsdGeom, Gf, Sdf
from pxr.Usd import SchemaBase, RegisterAffects

# Define custom schema class for humanoid robot joints
class HumanoidJointSchema(UsdGeom.Xform):
    """
    Custom schema for humanoid robot joints with extended properties.
    Extends Xform to inherit transform capabilities.
    """

    @staticmethod
    def Apply(prim):
        """Apply this schema to a prim."""
        return Apply(prim)

    @classmethod
    def _GetSchemaAttributeNames(cls):
        """Return attribute names for this schema."""
        return [
            "maxTorque",
            "velocityLimit",
            "controlMode",
            "stiffness",
            "damping",
            "jointLimits",
            "safetyMargin",
        ]

    # Control mode constants
    CONTROL_POSITION = "position"
    CONTROL_VELOCITY = "velocity"
    CONTROL_TORQUE = "torque"
    CONTROL_IMPEDANCE = "impedance"

    def GetMaxTorqueAttr(self):
        """Get the maximum torque attribute."""
        return self.GetPrim().GetAttribute("maxTorque")

    def SetMaxTorque(self, torque):
        """Set the maximum torque."""
        return self.GetPrim().GetAttribute("maxTorque").Set(torque)

    def GetVelocityLimitAttr(self):
        """Get the velocity limit attribute."""
        return self.GetPrim().GetAttribute("velocityLimit")

    def SetVelocityLimit(self, velocity):
        """Set the velocity limit."""
        return self.GetPrim().GetAttribute("velocityLimit").Set(velocity)

    def GetControlModeAttr(self):
        """Get the control mode attribute."""
        return self.GetPrim().GetAttribute("controlMode")

    def SetControlMode(self, mode):
        """Set the control mode."""
        return self.GetPrim().GetAttribute("controlMode").Set(mode)

    def GetStiffnessAttr(self):
        """Get the stiffness (for impedance control)."""
        return self.GetPrim().GetAttribute("stiffness")

    def SetStiffness(self, stiffness):
        """Set the stiffness value."""
        return self.GetPrim().GetAttribute("stiffness").Set(stiffness)

    def GetDampingAttr(self):
        """Get the damping (for impedance control)."""
        return self.GetPrim().GetAttribute("damping")

    def SetDamping(self, damping):
        """Set the damping value."""
        return self.GetPrim().GetAttribute("damping").Set(damping)

    def GetJointLimitsAttr(self):
        """Get the joint limits [lower, upper]."""
        return self.GetPrim().GetAttribute("jointLimits")

    def SetJointLimits(self, lower, upper):
        """Set joint limits."""
        return self.GetPrim().GetAttribute("jointLimits").Set([lower, upper])


# Custom schema for robot sensors
class RobotSensorSchema(UsdGeom.Xform):
    """Base schema for robot sensors."""

    @classmethod
    def _GetSchemaAttributeNames(cls):
        return [
            "sensorType",
            "updateRate",
            "noiseModel",
            "rangeMin",
            "rangeMax",
            "fieldOfView",
            "resolution",
            "latency",
        ]

    # Sensor type constants
    SENSOR_CAMERA = "camera"
    SENSOR_LIDAR = "lidar"
    SENSOR_IMU = "imu"
    SENSOR_DEPTH = "depth"
    SENSOR_FORCE_TORQUE = "force_torque"

    def GetSensorTypeAttr(self):
        """Get the sensor type."""
        return self.GetPrim().GetAttribute("sensorType")

    def SetSensorType(self, sensor_type):
        """Set the sensor type."""
        return self.GetPrim().GetAttribute("sensorType").Set(sensor_type)

    def GetUpdateRateAttr(self):
        """Get the sensor update rate in Hz."""
        return self.GetPrim().GetAttribute("updateRate")

    def SetUpdateRate(self, rate_hz):
        """Set the sensor update rate."""
        return self.GetPrim().GetAttribute("updateRate").Set(rate_hz)

    def GetNoiseModelAttr(self):
        """Get the noise model parameters."""
        return self.GetPrim().GetAttribute("noiseModel")

    def SetNoiseModel(self, params):
        """Set the noise model parameters."""
        return self.GetPrim().GetAttribute("noiseModel").Set(params)


# Usage example
def create_sensor_with_schema(stage, path, sensor_type, update_rate=100):
    """Create a sensor using the custom schema."""
    sensor = RobotSensorSchema.Define(stage, path)
    sensor.SetSensorType(sensor_type)
    sensor.SetUpdateRate(update_rate)
    sensor.GetNoiseModelAttr().Set([0.01, 0.001, 0.0])  # Example params
    return sensor


# stage = Usd.Stage.CreateNew("custom_schema.usd")
# sensor = create_sensor_with_schema(
#     stage,
#     "/Robot/Head/Camera",
#     RobotSensorSchema.SENSOR_CAMERA,
#     update_rate=30
# )
```

## Stage Management and Optimization

### Efficient Stage Loading

Large USD stages benefit from careful organization to enable efficient loading and traversal. Understanding USD's composition mechanisms helps in designing scenes that load quickly and use memory efficiently. Key considerations include layer organization, reference usage, and streaming behavior.

USD stages are designed to stream content on demand, loading data only when needed. However, this streaming can cause frame drops if not managed properly. Pre-loading strategies, level-of-detail systems, and careful use of references help maintain smooth interactive performance. The USD API provides control over which layers and references are loaded at any time.

```python
# Stage loading and optimization patterns
from pxr import Usd, UsdGeom, Sdf
import omni.usd

class StageOptimizer:
    """Optimize USD stage loading and memory usage."""

    def __init__(self, stage):
        self.stage = stage

    def analyze_stage(self):
        """Analyze stage composition and report statistics."""
        stats = {
            'total_prims': 0,
            'by_type': {},
            'layer_stack': [],
            'references': [],
            'payloads': [],
        }

        # Count prims by type
        for prim in self.stage.Traverse():
            stats['total_prims'] += 1
            prim_type = prim.GetTypeName()
            stats['by_type'][prim_type] = stats['by_type'].get(prim_type, 0) + 1

        # Analyze layers
        root_layer = self.stage.GetRootLayer()
        stats['layer_stack'] = [root_layer.GetIdentifier()]
        stats['layer_stack'].extend(self.stage.GetSubLayerPaths())

        # Find all references and payloads
        for prim in self.stage.Traverse():
            # Check for references
            references = Usd.References.Get(self.stage, prim.GetPath())
            if references:
                for ref in references.GetReferences():
                    stats['references'].append({
                        'prim': str(prim.GetPath()),
                        'asset': ref.assetPath,
                    })

            # Check for payloads
            payloads = Usd.Payloads.Get(self.stage, prim.GetPath())
            if payloads:
                for payload in payloads.GetPayloads():
                    stats['payloads'].append({
                        'prim': str(prim.GetPath()),
                        'asset': payload.assetPath,
                    })

        return stats

    def optimize_references(self, unload_distant=True, distance_threshold=50.0):
        """
        Optimize references based on criteria.

        Args:
            unload_distant: Unload payloads for distant objects
            distance_threshold: Distance threshold in meters
        """
        root_path = Sdf.Path("/")

        # Get all payload references
        for prim in self.stage.Traverse():
            payloads = Usd.Payloads.Get(self.stage, prim.GetPath())
            if payloads:
                # Get prim position (simplified - would need full transform calculation)
                prim_pos = self._get_prim_position(prim.GetPath())

                # Calculate distance from origin
                distance = (prim_pos[0]**2 + prim_pos[1]**2 + prim_pos[2]**2)**0.5

                if unload_distant and distance > distance_threshold:
                    # Unload the payload
                    for payload in payloads.GetPayloads():
                        payloads.RemovePayloadByPath(payload.assetPath)
                    print(f"Unloaded: {prim.GetPath()} (distance: {distance:.1f}m)")

    def _get_prim_position(self, path):
        """Get the world position of a prim."""
        prim = self.stage.GetPrimAtPath(path)
        if not prim:
            return (0, 0, 0)

        xform = UsdGeom.Xformable(prim)
        if not xform:
            return (0, 0, 0)

        # Get world transform
        transform = xform.ComputeLocalToWorldTransform(Usd.TimeCode.Default())
        translation = transform.ExtractTranslation()
        return (translation[0], translation[1], translation[2])

    def create_level_of_detail(self, base_path, lod_configs):
        """
        Create level-of-detail structure for a model.

        Args:
            base_path: Path to the parent prim
            lod_configs: List of (lod_name, distance, usd_path) tuples
        """
        lod_variant_set = self.stage.GetPrimAtPath(base_path).GetVariantSets().AddVariantSet("lod")

        for lod_name, distance, _ in lod_configs:
            lod_variant_set.AddVariant(lod_name)

        # Create variant-specific content
        for lod_name, distance, usd_path in lod_configs:
            lod_variant_set.SetVariantSelection(lod_name)
            with Usd.EditContext(self.stage, lod_variant_set.GetVariantEditContext()):
                # Add appropriate LOD reference
                prim_path = f"{base_path}/LODGeometry"
                if self.stage.GetPrimAtPath(prim_path):
                    self.stage.RemovePrim(prim_path)

                # Create reference to LOD geometry
                lod_prim = UsdGeom.Xform.Define(self.stage, prim_path)
                references = Usd.References.Get(self.stage, prim_path)
                if not references:
                    references = Usd.References.Define(self.stage, prim_path)
                references.AddReference(usd_path)

        # Set default LOD
        lod_variant_set.SetVariantSelection("high")

        return lod_variant_set

    def report_memory_usage(self):
        """Report approximate memory usage by component."""
        from collections import defaultdict

        usage = defaultdict(int)
        mesh_prims = []

        for prim in self.stage.Traverse():
            prim_type = prim.GetTypeName()

            if prim_type == "Mesh":
                mesh = UsdGeom.Mesh(prim)
                points_attr = mesh.GetPointsAttr()
                if points_attr:
                    num_points = len(points_attr.Get())
                    usage['total_vertices'] += num_points
                    mesh_prims.append((str(prim.GetPath()), num_points))

        print("Memory Usage Report:")
        print(f"  Total Prims: {sum(usage.values())}")
        print(f"  Total Vertices: {usage['total_vertices']}")
        print("\nTop 5 Largest Meshes:")
        mesh_prims.sort(key=lambda x: x[1], reverse=True)
        for path, count in mesh_prims[:5]:
            print(f"    {path}: {count} vertices")


# Example usage
# stage = omni.usd.get_context().get_stage()
# optimizer = StageOptimizer(stage)
# stats = optimizer.analyze_stage()
# print(f"Stage has {stats['total_prims']} prims")
# optimizer.optimize_references()
```

### USD Pointers and Relationships

USD pointers and relationships provide mechanisms for connecting prims without creating parent-child hierarchies. Pointers are references to specific prims stored as attribute values, while relationships are named connections that can resolve to multiple targets. Both mechanisms are essential for building complex scene graphs with cross-references.

Relationships are particularly important for robotics applications, where a controller might need to reference multiple joints, a sensor might need to specify its parent link, or a configuration might need to reference multiple scene elements. Unlike pointers, relationships can have multiple targets, enabling one-to-many connections.

```python
# USD pointers and relationships for robotics
from pxr import Usd, UsdGeom, UsdPhysics, Gf, Sdf, Tf

class RobotSceneBuilder:
    """Build robot scenes using pointers and relationships."""

    def __init__(self, stage):
        self.stage = stage
        self._setup_robot_relationships()

    def _setup_robot_relationships(self):
        """Create relationship definitions for robot components."""
        # Define relationships at the robot root
        self.root_path = "/Robot"

        # Controller relationships
        self._create_relationship(
            f"{self.root_path}/Controller",
            "controlledJoints",
            "Targets joints that this controller affects"
        )

        self._create_relationship(
            f"{self.root_path}/Controller",
            "sensorInputs",
            "Targets sensors that provide input to this controller"
        )

        self._create_relationship(
            f"{self.root_path}/Controller",
            "actuatorOutputs",
            "Targets actuators that this controller commands"
        )

        # Sensor relationships
        self._create_relationship(
            f"{self.root_path}/Sensors",
            "parentLinks",
            "The links that sensors are attached to"
        )

    def _create_relationship(self, prim_path, rel_name, doc):
        """Create a named relationship."""
        prim = self.stage.GetPrimAtPath(prim_path)
        if not prim:
            prim = UsdGeom.Xform.Define(self.stage, prim_path).GetPrim()

        rel = prim.CreateRelationship(rel_name, doc=doc)
        return rel

    def set_controlled_joints(self, controller_path, joint_paths):
        """Set which joints a controller controls."""
        rel = self.stage.GetPrimAtPath(controller_path).GetRelationship("controlledJoints")
        targets = [Sdf.Path(p) for p in joint_paths]
        rel.SetTargets(targets)

    def set_sensor_parent(self, sensor_path, link_path):
        """Set the parent link for a sensor."""
        # Using pointer attribute
        prim = self.stage.GetPrimAtPath(sensor_path)
        parent_link_attr = prim.CreateAttribute(
            "parentLink",
            Sdf.ValueTypeNames.SdfPath
        )
        parent_link_attr.Set(Sdf.Path(link_path))

        # Also using relationship
        sensors_rel = self.stage.GetPrimAtPath("/Robot/Sensors").GetRelationship("parentLinks")
        current_targets = list(sensors_rel.GetTargets())
        current_targets.append(Sdf.Path(link_path))
        sensors_rel.SetTargets(current_targets)

    def create_articulation_relationship(self, robot_path, articulation_path):
        """Create a relationship to define articulation structure."""
        prim = self.stage.GetPrimAtPath(robot_path)
        rel = prim.CreateRelationship("articulationRoot")
        rel.SetTargets([Sdf.Path(articulation_path)])

        # Create articulation API
        art_api = UsdPhysics.ArticulationRootAPI.Apply(
            self.stage.GetPrimAtPath(articulation_path)
        )

    def get_controller_inputs(self, controller_path):
        """Get all sensor inputs for a controller."""
        prim = self.stage.GetPrimAtPath(controller_path)
        rel = prim.GetRelationship("sensorInputs")
        if rel:
            return rel.GetTargets()
        return []

    def get_controller_outputs(self, controller_path):
        """Get all actuators controlled by a controller."""
        prim = self.stage.GetPrimAtPath(controller_path)
        rel = prim.GetRelationship("actuatorOutputs")
        if rel:
            return rel.GetTargets()
        return []


# Usage example
stage = Usd.Stage.CreateNew("relationships.usd")

# Create robot structure
builder = RobotSceneBuilder(stage)

# Define joints
joint_paths = [
    "/Robot/Pelvis/LeftHip",
    "/Robot/Pelvis/LeftThigh",
    "/Robot/Pelvis/LeftShin",
    "/Robot/Pelvis/RightHip",
    "/Robot/Pelvis/RightThigh",
    "/Robot/Pelvis/RightShin",
]

for path in joint_paths:
    UsdGeom.Xform.Define(stage, path)
    UsdPhysics.Joint.Define(stage, f"{path}/Joint")

# Set up controller relationships
controller_path = "/Robot/Controller"
builder.set_controlled_joints(controller_path, joint_paths)

# Define sensors
sensor_paths = [
    "/Robot/Head/Camera/Left",
    "/Robot/Head/Camera/Right",
    "/Robot/Torso/IMU",
]

for path in sensor_paths:
    UsdGeom.Xform.Define(stage, path)
    builder.set_sensor_parent(path, "/Robot/Pelvis")

# Get relationship targets
inputs = builder.get_controller_inputs(controller_path)
outputs = builder.get_controller_outputs(controller_path)

print("Controller relationships configured:")
print(f"  Inputs: {[str(p) for p in inputs]}")
print(f"  Outputs: {[str(p) for p in outputs]}")

stage.Save()
```

## Export and Interoperability

### USD Export Best Practices

Exporting USD files for use in other applications requires attention to compatibility and data preservation. Different applications support different USD schemas and features, so understanding the target application's capabilities is important. The following patterns ensure broad compatibility while preserving essential robotics information.

When exporting for Omniverse applications, use the built-in schemas (UsdGeom, UsdPhysics, UsdShade) for maximum compatibility. Custom schemas require the target application to have the same schema definitions registered. Geometry should use standard mesh representations, avoiding application-specific extensions where possible.

```python
# USD export patterns for interoperability
from pxr import Usd, UsdGeom, UsdPhysics, UsdShade, Gf, Sdf
import omni.usd

class USDExporter:
    """Export USD files with maximum interoperability."""

    def __init__(self, stage):
        self.stage = stage

    def export_for_omniverse(self, output_path, options=None):
        """
        Export stage optimized for Omniverse applications.

        Args:
            output_path: Path for the output USD file
            options: Export options dictionary
        """
        options = options or {}

        # Ensure proper schema application
        self._ensure_omniverse_schemas()

        # Set up standard units
        self._configure_units()

        # Export animation if present
        if options.get('export_animation', True):
            self._export_animation()

        # Export materials
        self._export_materials()

        # Save to file
        self.stage.GetRootLayer().Export(output_path)
        print(f"Exported to {output_path}")

    def _ensure_omniverse_schemas(self):
        """Ensure all prims have appropriate Omniverse schemas."""
        for prim in self.stage.Traverse():
            prim_type = prim.GetTypeName()

            # Apply physics schemas to mesh prims in physics scenes
            if prim_type in ["Mesh", "Cube", "Sphere", "Cylinder"]:
                # Check if this should be a rigid body
                if prim.GetAttribute("physics:rigidBody"):
                    if not UsdPhysics.RigidBodyAPI.Get(self.stage, prim.GetPath()):
                        UsdPhysics.RigidBodyAPI.Apply(prim)

                    if not UsdPhysics.CollisionAPI.Get(self.stage, prim.GetPath()):
                        UsdPhysics.CollisionAPI.Apply(prim)

    def _configure_units(self):
        """Configure stage units for consistency."""
        # USD uses centimeters as the default unit
        # Explicitly set up linear units
        self.stage.SetMetadata(
            UsdGeom.Tokens.metersPerUnit,
            Sdf.Value(0.01)  # 1 USD unit = 1 cm = 0.01 meters
        )

        # Set up time units (frames per second)
        self.stage.SetMetadata(
            UsdGeom.Tokens.timeCodesPerSecond,
            Sdf.Value(60.0)  # 60 FPS
        )

    def _export_animation(self):
        """Export keyframe animation data."""
        for prim in self.stage.Traverse():
            # Check for animated transforms
            xform = UsdGeom.Xformable(prim)
            if xform:
                for op in xform.GetOrderedXformOps():
                    if op.GetAttr().GetNumTimeSamples() > 0:
                        # This op has animation
                        pass  # Animation is preserved automatically

    def _export_materials(self):
        """Ensure all materials use standard USD Preview Surface."""
        for prim in self.stage.Traverse():
            # Check for material binding
            material_binding = UsdShade.MaterialBindingAPI(prim)
            bound_material = material_binding.GetDirectBinding().GetMaterial()

            if bound_material:
                # Verify material uses UsdPreviewSurface
                shader_prims = [
                    p for p in bound_material.GetChildren()
                    if p.GetTypeName() == "Shader"
                ]

                for shader in shader_prims:
                    shader_id = shader.GetAttribute("info:id").Get()
                    if shader_id not in ["UsdPreviewSurface", "ND_Principled_BSDF"]:
                        # Convert to UsdPreviewSurface
                        self._convert_to_preview_surface(shader)

    def _convert_to_preview_surface(self, shader):
        """Convert a shader to UsdPreviewSurface."""
        # This would implement shader conversion logic
        pass

    def export_subset(self, root_path, output_path):
        """Export only a subset of the stage."""
        # Create a new stage for the subset
        subset_stage = Usd.Stage.CreateNew(output_path)

        # Copy the root prim and its descendants
        root_prim = self.stage.GetPrimAtPath(root_path)
        if root_prim:
            Usd.CopyLayerContent(
                self.stage.GetRootLayer(),
                subset_stage.GetRootLayer(),
                root_path
            )

        subset_stage.Save()
        print(f"Exported subset {root_path} to {output_path}")

    def export_with_inlined_references(self, output_path):
        """
        Export with all references inlined into a single file.
        Useful for sharing scenes without external dependencies.
        """
        # This would require loading all references and copying them
        # into the output file
        pass

    def validate_for_omniverse(self):
        """Validate stage for Omniverse compatibility."""
        issues = []

        for prim in self.stage.Traverse():
            # Check for unsupported features
            prim_type = prim.GetTypeName()

            # Check for unsupported prim types
            unsupported = ["Points", "BasisCurves", "NurbsCurves"]
            if prim_type in unsupported:
                issues.append(f"Unsupported prim type: {prim_type} at {prim.GetPath()}")

            # Check for missing schemas
            if prim_type in ["Mesh", "Cube", "Sphere", "Cylinder"]:
                if not prim.GetAttribute("xformOp:translate"):
                    issues.append(f"Missing transform: {prim.GetPath()}")

        return issues


# Export workflow example
def export_robot_scene(stage, robot_name, export_config):
    """Complete export workflow for a robot scene."""
    exporter = USDExporter(stage)

    # Validate before export
    issues = exporter.validate_for_omniverse()
    if issues:
        print("Validation issues found:")
        for issue in issues:
            print(f"  - {issue}")

    # Configure export
    output_path = f"exports/{robot_name}.usd"

    exporter.export_for_omniverse(
        output_path,
        options={
            'export_animation': export_config.get('animate', True),
            'include_materials': export_config.get('materials', True),
        }
    )

    return output_path
```

### Integration with ROS and Other Frameworks

USD files can integrate with ROS (Robot Operating System) through various mechanisms. Isaac Sim provides ROS bridges that enable communication between USD-based simulations and ROS nodes. Understanding these integration patterns is essential for developing systems that combine simulation with existing ROS-based control stacks.

```python
# ROS integration patterns via USD
from pxr import Usd, UsdGeom, Gf, Sdf
import omni.isaac.core.utils.ros as ros_utils

class ROSUSDIntegration:
    """Integrate USD stages with ROS frameworks."""

    def __init__(self, stage, namespace=""):
        self.stage = stage
        self.namespace = namespace

    def setup_ros_transforms(self):
        """Set up transform frame hierarchy for ROS."""
        # Create standard ROS frames
        frames = {
            "/tf": "Root transform frame",
            "/map": "Map/world frame",
            "/odom": "Odometry frame",
            "/base_link": "Robot base frame",
        }

        for frame_path, description in frames.items():
            frame = UsdGeom.Xform.Define(self.stage, frame_path)
            print(f"Created {description}: {frame_path}")

        # Set up frame relationships
        self._create_frame_connection("/base_link", "/odom")
        self._create_frame_connection("/odom", "/map")

    def _create_frame_connection(self, child_frame, parent_frame):
        """Create a parent-child relationship between frames."""
        child_prim = self.stage.GetPrimAtPath(child_frame)
        parent_prim = self.stage.GetPrimAtPath(parent_frame)

        if child_prim and parent_prim:
            # Create transform relationship
            rel = child_prim.CreateRelationship("parent_frame")
            rel.SetTargets([Sdf.Path(parent_frame)])

    def export_urdf_from_usd(self, output_path):
        """
        Export URDF representation from USD stage.

        Note: This creates a simplified URDF that captures
        the kinematic structure but not all USD features.
        """
        urdf_content = '<?xml version="1.0"?>\n<robot name="robot">\n'

        # Process links
        for prim in self.stage.Traverse():
            if prim.GetTypeName() == "Xform":
                link_name = str(prim.GetPath()).split("/")[-1]

                # Get inertial properties if available
                mass = 0.0
                com = Gf.Vec3f(0, 0, 0)
                inertia = Gf.Vec3f(0, 0, 0)

                # Try to get physics properties
                rb = UsdPhysics.RigidBodyAPI.Get(self.stage, prim.GetPath())
                if rb:
                    # Mass would be extracted here
                    pass

                urdf_content += f'  <link name="{link_name}">\n'
                urdf_content += f'    <inertial>\n'
                urdf_content += f'      <mass value="{mass}"/>\n'
                urdf_content += f'      <origin xyz="{com[0]} {com[1]} {com[2]}"/>\n'
                urdf_content += '    </inertial>\n'
                urdf_content += '  </link>\n'

        # Process joints
        for prim in self.stage.Traverse():
            joint = UsdPhysics.Joint.Get(self.stage, prim.GetPath())
            if joint:
                joint_name = str(prim.GetPath()).split("/")[-1]

                # Get joint properties
                joint_type = "fixed"  # Default
                parent = ""
                child = ""

                # Extract joint information
                bodies = joint.GetBody0Rel().GetTargets()
                if bodies:
                    parent = str(bodies[0]).split("/")[-1]

                bodies = joint.GetBody1Rel().GetTargets()
                if bodies:
                    child = str(bodies[0]).split("/")[-1]

                urdf_content += f'  <joint name="{joint_name}" type="{joint_type}">\n'
                urdf_content += f'    <parent link="{parent}"/>\n'
                urdf_content += f'    <child link="{child}"/>\n'
                urdf_content += '  </joint>\n'

        urdf_content += '</robot>\n'

        with open(output_path, 'w') as f:
            f.write(urdf_content)

        print(f"URDF exported to {output_path}")
        return output_path

    def setup_ros_topics(self):
        """Document ROS topic structure for the scene."""
        topics = [
            ("/joint_states", "sensor_msgs/JointState", "Joint positions, velocities, efforts"),
            ("/imu/data", "sensor_msgs/Imu", "IMU readings"),
            ("/cmd_vel", "geometry_msgs/Twist", "Velocity commands"),
        ]

        print("ROS Topic Configuration:")
        for topic, msg_type, description in topics:
            print(f"  {topic} ({msg_type})")
            print(f"    {description}")

        return topics
```

---

## Connection to Capstone

The USD format and scene composition skills you have developed in this section are foundational to the **Voice-to-Plan-to-Navigate-to-Vision-to-Manipulate** pipeline that powers the capstone project. Here is how each capability connects:

### Voice Stage
When voice commands are interpreted (e.g., "Pick up the red cube from the table"), the system must identify objects in the USD scene graph. The prim hierarchy and naming conventions you learned enable efficient object lookup by semantic name, and USD relationships allow the system to understand spatial context (e.g., which objects are "on" the table).

### Plan Stage
Motion planning requires accurate scene representation including collision geometry, joint limits, and articulation structure. The USD physics schemas (RigidBodyAPI, CollisionAPI, Joint) provide the planner with necessary constraint information. The layer system allows planners to overlay temporary planning state without modifying the base scene.

### Navigate Stage
Navigation systems rely on the spatial organization of the scene. The USD coordinate system, transform hierarchies, and reference frames you configured enable accurate robot localization within the simulation environment. ROS integration patterns allow navigation stacks to receive transform updates from the USD stage.

### Vision Stage
Camera sensors defined in USD provide the visual input pipeline. The sensor schemas, update rates, and parent-link relationships ensure cameras move with the robot and capture images at the correct frequency. USD materials and lighting affect synthetic image generation for perception training.

### Manipulate Stage
Manipulation requires precise knowledge of end-effector frames, gripper geometry, and object properties. The custom schemas for joints (stiffness, damping, control modes) directly configure the manipulation controllers. USD relationships connect controllers to their target joints, and the scene composition patterns allow swapping end-effectors or target objects without restructuring the entire scene.

By mastering USD scene composition, you have built the representational foundation that unifies all stages of the humanoid robotics pipeline.

---

## Next Steps

With a solid understanding of USD format and scene composition, you are prepared to create and manage complex robotics simulations in Isaac Sim. The next section will introduce Isaac Sim's simulation loop and API, showing how to programmatically control simulations, step physics, and collect observations. You will learn to combine USD scene descriptions with dynamic simulation control to create interactive robotics applications.
