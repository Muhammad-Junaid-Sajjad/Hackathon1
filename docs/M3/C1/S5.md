---
id: m3-c1-s5
title: PhysX 5 Integration
sidebar_position: 5
keywords: ['physx', 'physics', 'joints', 'rigid-bodies', 'collisions']
---

## Prerequisites

Before diving into PhysX 5 integration, ensure you have the following foundational knowledge:

- **Basic Physics Concepts**: Understanding of rigid body dynamics, forces, torques, and rotational motion
- **USD Scene Graph Fundamentals**: Familiarity with Universal Scene Description (USD) prim hierarchy and APIs (covered in M3-C1-S2)
- **Python Programming**: Proficiency in Python including object-oriented programming and class design
- **Isaac Sim Environment**: Completed Isaac Sim installation and basic scene creation (covered in M3-C1-S1)
- **Robot Kinematics**: Understanding of robot link-joint structure, degrees of freedom, and URDF format

## Learning Objectives

By the end of this section, you will be able to:

**[Beginner]**
- Define rigid body, collision shape, and joint in the context of PhysX 5 simulation
- Identify the different joint types (revolute, prismatic, spherical, fixed) and their use cases
- Describe the role of mass, inertia, and damping in physics simulation

**[Intermediate]**
- Implement rigid body creation and configuration using the UsdPhysics API
- Configure collision shapes (box, capsule, mesh) with appropriate friction properties
- Create and configure joints with limits, drives, and damping parameters

**[Advanced]**
- Architect a complete articulated robot physics model from URDF specification
- Optimize collision detection using convex hull approximations and collision filtering
- Design joint drive controllers for position, velocity, and force control modes

## Key Concepts

| Term | Definition |
|------|------------|
| **Rigid Body** | A physics object that maintains its shape under forces, characterized by mass, inertia tensor, and damping properties |
| **Articulation** | A chain of rigid bodies connected by joints, optimized in PhysX for stable simulation of complex mechanisms like robots |
| **Collision Shape** | Simplified geometry used for physics interaction detection, including primitives (box, sphere, capsule) and meshes |
| **Convex Hull** | A simplified mesh representation that wraps the original geometry, enabling faster collision detection |
| **Joint Drive** | A motor or actuator model that applies forces/torques to achieve target positions, velocities, or efforts |
| **Joint Limits** | Constraints on the minimum and maximum position or rotation a joint can achieve |
| **Inertia Tensor** | A 3x3 matrix describing how mass is distributed in a rigid body, affecting rotational dynamics |
| **Damping** | Energy dissipation parameter that reduces oscillations in linear and angular motion |

# PhysX 5 Integration

PhysX 5 represents NVIDIA's latest generation of physics simulation technology, bringing significant advances in fidelity, performance, and capabilities to Isaac Sim. This section provides an in-depth exploration of PhysX 5 integration for humanoid robotics simulation, covering rigid body dynamics, joint systems, collision handling, and advanced features like soft body simulation and cloth dynamics.

PhysX 5 introduces several key improvements over previous versions including GPU-accelerated fluid simulation, enhanced soft body dynamics, and improved constraint solving. For humanoid robotics, the most relevant improvements are in rigid body simulation accuracy, contact modeling, and the unified physics API that simplifies integration with existing robotics frameworks.

## Rigid Body Dynamics

### Creating and Configuring Rigid Bodies

Rigid bodies form the foundation of physics simulation, representing objects that maintain their shape under physical forces. In humanoid robotics, each link of the robot is typically modeled as a rigid body with specific mass, inertia, and damping properties.

```python
# Rigid body creation and configuration
from pxr import Usd, UsdGeom, UsdPhysics, UsdShade, Gf, Sdf
import omni.usd
import omni.physx as _physx

class PhysXRigidBodyManager:
    """
    Manager for creating and configuring rigid bodies in PhysX 5.
    """

    def __init__(self, stage=None):
        self.stage = stage or omni.usd.get_context().get_stage()
        self.physx_interface = _physx.get_physx_interface()

        # Configure default physics scene
        self._setup_physics_scene()

    def _setup_physics_scene(self):
        """Set up the physics scene with PhysX 5 settings."""
        # Create or get physics scene
        scene_path = "/World/PhysicsScene"
        if not self.stage.GetPrimAtPath(scene_path):
            scene = UsdPhysics.Scene.Define(self.stage, scene_path)

            # Set gravity
            scene.CreateGravityDirectionAttr(Gf.Vec3f(0, -1, 0))
            scene.CreateGravityMagnitudeAttr(9.81)

            # Enable GPU dynamics
            self.physx_interface.enable_gpu_dynamics(True)

    def create_rigid_body(self, path, mass, position=None, orientation=None):
        """
        Create a rigid body at the specified path.

        Args:
            path: USD path for the rigid body
            mass: Mass in kg
            position: Initial position (x, y, z)
            orientation: Initial orientation as quaternion (w, x, y, z)

        Returns:
            The created rigid body prim
        """
        # Create Xform at path
        xform = UsdGeom.Xform.Define(self.stage, path)

        # Set transform if provided
        if position:
            xform.AddTranslateOp().Set(Gf.Vec3f(*position))
        if orientation:
            xform.AddOrientOp().Set(Gf.Quatf(*orientation))

        # Apply Rigid Body API
        rb = UsdPhysics.RigidBodyAPI.Apply(xform.GetPrim())

        # Set mass
        mass_api = UsdPhysics.MassAPI.Apply(xform.GetPrim())
        mass_api.GetMassAttr().Set(mass)

        return xform

    def create_articulated_body(self, robot_path, urdf_path):
        """
        Create a fully articulated humanoid body from URDF.

        Args:
            robot_path: USD path for the robot root
            urdf_path: Path to URDF file

        Returns:
            Articulation root prim
        """
        # Import URDF to USD (Isaac Sim built-in)
        from omni.isaac.core.utils.robot_utils import load_robot

        robot_prim = load_robot(
            usd_context=omni.usd.get_context(),
            robot_usd_path=urdf_path,
            prim_path=robot_path
        )

        # Apply Articulation Root API
        art_api = UsdPhysics.ArticulationRootAPI.Apply(
            self.stage.GetPrimAtPath(robot_path)
        )

        return robot_prim

    def configure_link_properties(self, link_path, mass, com=None, inertia=None):
        """
        Configure physical properties for a robot link.

        Args:
            link_path: USD path to the link
            mass: Mass in kg
            com: Center of mass offset (x, y, z)
            inertia: Diagonal inertia tensor (Ixx, Iyy, Izz)
        """
        link_prim = self.stage.GetPrimAtPath(link_path)
        if not link_prim:
            raise ValueError(f"Link not found: {link_path}")

        # Apply physics APIs
        mass_api = UsdPhysics.MassAPI.Apply(link_prim)
        mass_api.GetMassAttr().Set(mass)

        # Center of mass
        if com is not None:
            com_api = UsdPhysics.CenterOfMassAPI.Apply(link_prim)
            com_api.GetCenterOfMassAttr().Set(Gf.Vec3f(*com))

        # Inertia tensor
        if inertia is not None:
            inertia_api = UsdPhysics.InertiaAPI.Apply(link_prim)
            inertia_api.GetDiagonalInertiaAttr().Set(Gf.Vec3f(*inertia))

    def set_damping(self, path, linear_damping=0.0, angular_damping=0.5):
        """
        Set damping parameters for a rigid body.

        Args:
            path: USD path to the rigid body
            linear_damping: Linear velocity damping coefficient
            angular_damping: Angular velocity damping coefficient
        """
        rb = UsdPhysics.RigidBodyAPI.Get(self.stage, path)
        if rb:
            rb.GetLinearDampingAttr().Set(linear_damping)
            rb.GetAngularDampingAttr().Set(angular_damping)

    def set_kinematic(self, path, is_kinematic=True):
        """
        Configure a body as kinematic (motion controlled by script).

        Args:
            path: USD path to the rigid body
            is_kinematic: Whether to make it kinematic
        """
        rb = UsdPhysics.RigidBodyAPI.Get(self.stage, path)
        if rb:
            rb.GetKinematicEnabledAttr().Set(is_kinematic)
```

### Collision Shapes and Mesh Representation

Collision shapes determine how objects interact physically. Isaac Sim supports multiple collision shape types including boxes, spheres, capsules, meshes, and convex hulls. For humanoid robots, the choice of collision representation affects both simulation accuracy and performance.

```python
# Collision shape management
from pxr import UsdGeom, UsdPhysics, Gf

class CollisionShapeManager:
    """
    Manager for creating and configuring collision shapes.
    """

    def __init__(self, stage=None):
        self.stage = stage or omni.usd.get_context().get_stage()

    def add_box_collision(self, path, size, offset=None):
        """
        Add a box collision shape.

        Args:
            path: Parent prim path
            size: Box dimensions (width, height, depth)
            offset: Local offset from parent
        """
        # Create collision mesh
        collision_path = f"{path}/Collision"
        box = UsdGeom.Cube.Define(self.stage, collision_path)
        box.GetSizeAttr().Set(min(size))  # Cube uses single size

        # Set size via xform
        scale = Gf.Vec3f(size[0]/2, size[1]/2, size[2]/2)
        box.AddScaleOp().Set(scale)

        # Set offset if provided
        if offset:
            box.AddTranslateOp().Set(Gf.Vec3f(*offset))

        # Apply collision API
        UsdPhysics.CollisionAPI.Apply(box.GetPrim())

        return box

    def add_capsule_collision(self, path, radius, height, offset=None):
        """
        Add a capsule collision shape.

        Args:
            path: Parent prim path
            radius: Capsule radius
            height: Cylindrical portion height (excluding hemispheres)
            offset: Local offset from parent
        """
        capsule_path = f"{path}/CapsuleCollision"

        # USD doesn't have native capsule, use cylinder approximation
        cylinder = UsdGeom.Cylinder.Define(self.stage, capsule_path)
        cylinder.GetRadiusAttr().Set(radius)
        cylinder.GetHeightAttr().Set(height + 2 * radius)

        # Apply offset
        if offset:
            cylinder.AddTranslateOp().Set(Gf.Vec3f(*offset))

        # Apply collision
        UsdPhysics.CollisionAPI.Apply(cylinder.GetPrim())

        return cylinder

    def add_mesh_collision(self, path, mesh_path, convex=True):
        """
        Add a mesh collision shape.

        Args:
            path: Parent prim path
            mesh_path: Path to source mesh geometry
            convex: Use convex hull approximation
        """
        # Get source mesh
        source_mesh = self.stage.GetPrimAtPath(mesh_path)
        if not source_mesh:
            raise ValueError(f"Mesh not found: {mesh_path}")

        # Create collision mesh reference
        collision_path = f"{path}/CollisionMesh"

        if convex:
            # Create convex hull
            collision = UsdGeom.Mesh.Define(self.stage, collision_path)
            # Would need to compute convex hull from source mesh
        else:
            # Use source mesh directly
            collision = UsdGeom.Mesh.Define(self.stage, collision_path)

            # Copy points from source
            source_geom = UsdGeom.Mesh(source_mesh)
            points = source_geom.GetPointsAttr().Get()
            if points:
                collision.GetPointsAttr().Set(points)
                collision.GetFaceVertexCountsAttr().Set(
                    source_geom.GetFaceVertexCountsAttr().Get()
                )
                collision.GetFaceVertexIndicesAttr().Set(
                    source_geom.GetFaceVertexIndicesAttr().Get()
                )

        # Apply collision API
        UsdPhysics.CollisionAPI.Apply(collision.GetPrim())

        return collision

    def configure_friction(self, path, static_friction=0.7, dynamic_friction=0.5):
        """
        Configure friction properties for a collision shape.

        Args:
            path: Collision prim path
            static_friction: Static friction coefficient
            dynamic_friction: Dynamic friction coefficient
        """
        # Get material assigned to this collision
        material_path = f"/Looks/FrictionMaterial_{path.replace('/', '_')}"

        # Create or get material
        if not self.stage.GetPrimAtPath(material_path):
            material = UsdShade.Material.Define(self.stage, material_path)
            shader = UsdShade.Shader.Define(self.stage, f"{material_path}/Shader")
            shader.CreateIdAttr("UsdPreviewSurface")

            # Set friction properties
            shader.CreateInput("roughness", Sdf.ValueTypeNames.Float).Set(0.9)

            material.CreateSurfaceOutput().ConnectToSource(
                shader.ConnectableAPI(), "surface"
            )

        # Bind material
        prim = self.stage.GetPrimAtPath(path)
        if prim:
            binding_api = UsdShade.MaterialBindingAPI(prim)
            material_prim = self.stage.GetPrimAtPath(material_path)
            if material_prim:
                binding_api.Bind(
                    UsdShade.Material(material_prim),
                    UsdShade.Tokens.weakerThanDescendants
                )

    def set_collision_filter(self, path, group, mask):
        """
        Set collision filtering for a rigid body.

        Args:
            path: Rigid body path
            group: Collision group number
            mask: Groups this body collides with
        """
        # PhysX collision filtering is done through extension settings
        # This is typically configured at the scene level
        import omni.kit.settings
        settings = omni.kit.settings.get_settings()

        # Set collision group settings
        settings.set_int(f"/physics/collision/group/{path}", group)
        settings.set_int(f"/physics/collision/mask/{path}", mask)
```

## Joint System

### Creating and Configuring Joints

Joints constrain the relative motion between rigid bodies, defining how robot links connect and move relative to each other. PhysX 5 supports multiple joint types including revolute (hinge), prismatic, spherical, fixed, and distance joints.

```python
# Joint creation and configuration
from pxr import UsdPhysics, Gf, Sdf

class JointManager:
    """
    Manager for creating and configuring physics joints.
    """

    def __init__(self, stage=None):
        self.stage = stage or omni.usd.get_context().get_stage()

    def create_revolute_joint(self, path, body0, body1, anchor, axis,
                                limit_lower=-1e6, limit_upper=1e6,
                                max_effort=1e6, max_velocity=1e6):
        """
        Create a revolute (hinge) joint.

        Args:
            path: USD path for the joint
            body0: Path to parent body
            body1: Path to child body
            anchor: Anchor point in parent body frame
            axis: Rotation axis (x, y, or z)
            limit_lower: Lower joint limit (radians)
            limit_upper: Upper joint limit (radians)
            max_effort: Maximum joint effort
            max_velocity: Maximum joint velocity
        """
        joint = UsdPhysics.Joint.Define(self.stage, path)

        # Set bodies
        joint.GetBody0Rel().SetTargets([Sdf.Path(body0)])
        joint.GetBody1Rel().SetTargets([Sdf.Path(body1)])

        # Set joint type
        joint.CreateTypeAttr(UsdPhysics.Joint.TypeRevolute)

        # Set local frames
        joint.CreateLocalPos0Attr(Gf.Vec3f(*anchor))
        joint.CreateLocalPos1Attr(Gf.Vec3f(0, 0, 0))

        # Set axis
        axis_map = {'x': Gf.Vec3f(1, 0, 0),
                    'y': Gf.Vec3f(0, 1, 0),
                    'z': Gf.Vec3f(0, 0, 1)}
        joint.CreateLocalAxisAttr(axis_map.get(axis, axis_map['z']))

        # Add limits
        limit_api = UsdPhysics.LimitAPI.Apply(joint.GetPrim())
        limit_api.CreateLowerLimitAttr(limit_lower)
        limit_api.CreateUpperLimitAttr(limit_upper)

        # Add drive
        drive_api = UsdPhysics.DriveAPI.Apply(joint.GetPrim())
        drive_api.CreateTypeAttr(UsdPhysics.DriveAPI.DriveForce)
        drive_api.CreateMaxForceAttr(max_effort)
        drive_api.CreateTargetPositionAttr(0.0)

        return joint

    def create_prismatic_joint(self, path, body0, body1, anchor, axis,
                                limit_lower=-1e6, limit_upper=1e6,
                                max_effort=1e6, max_velocity=1e6):
        """
        Create a prismatic (sliding) joint.

        Args:
            path: USD path for the joint
            body0: Path to parent body
            body1: Path to child body
            anchor: Anchor point
            axis: Translation axis
            limit_lower: Lower position limit
            limit_upper: Upper position limit
            max_effort: Maximum force
            max_velocity: Maximum velocity
        """
        joint = UsdPhysics.Joint.Define(self.stage, path)

        # Set bodies
        joint.GetBody0Rel().SetTargets([Sdf.Path(body0)])
        joint.GetBody1Rel().SetTargets([Sdf.Path(body1)])

        # Set joint type
        joint.CreateTypeAttr(UsdPhysics.Joint.TypePrismatic)

        # Set local frames
        joint.CreateLocalPos0Attr(Gf.Vec3f(*anchor))
        joint.CreateLocalPos1Attr(Gf.Vec3f(0, 0, 0))

        # Set axis
        axis_map = {'x': Gf.Vec3f(1, 0, 0),
                    'y': Gf.Vec3f(0, 1, 0),
                    'z': Gf.Vec3f(0, 0, 1)}
        joint.CreateLocalAxisAttr(axis_map.get(axis, axis_map['z']))

        # Add limits
        limit_api = UsdPhysics.LimitAPI.Apply(joint.GetPrim())
        limit_api.CreateLowerLimitAttr(limit_lower)
        limit_api.CreateUpperLimitAttr(limit_upper)

        # Add drive
        drive_api = UsdPhysics.DriveAPI.Apply(joint.GetPrim())
        drive_api.CreateTypeAttr(UsdPhysics.DriveAPI.DriveForce)
        drive_api.CreateMaxForceAttr(max_effort)
        drive_api.CreateTargetPositionAttr(0.0)

        return joint

    def create_fixed_joint(self, path, body0, body1, offset0=None, offset1=None):
        """
        Create a fixed joint (bodies move together).

        Args:
            path: USD path for the joint
            body0: Path to parent body
            body1: Path to child body
            offset0: Offset from parent body origin
            offset1: Offset from child body origin
        """
        joint = UsdPhysics.Joint.Define(self.stage, path)

        # Set bodies
        joint.GetBody0Rel().SetTargets([Sdf.Path(body0)])
        joint.GetBody1Rel().SetTargets([Sdf.Path(body1)])

        # Set joint type
        joint.CreateTypeAttr(UsdPhysics.Joint.TypeFixed)

        # Set local frames
        joint.CreateLocalPos0Attr(Gf.Vec3f(*(offset0 or [0, 0, 0])))
        joint.CreateLocalPos1Attr(Gf.Vec3f(*(offset1 or [0, 0, 0])))

        return joint

    def create_spherical_joint(self, path, body0, body1, anchor,
                                 limit_angle=3.14159):
        """
        Create a spherical (ball) joint with angular limits.

        Args:
            path: USD path for the joint
            body0: Path to parent body
            body1: Path to child body
            anchor: Anchor point
            limit_angle: Maximum rotation angle in radians
        """
        joint = UsdPhysics.Joint.Define(self.stage, path)

        # Set bodies
        joint.GetBody0Rel().SetTargets([Sdf.Path(body0)])
        joint.GetBody1Rel().SetTargets([Sdf.Path(body1)])

        # Set joint type
        joint.CreateTypeAttr(UsdPhysics.Joint.TypeSpherical)

        # Set local frames
        joint.CreateLocalPos0Attr(Gf.Vec3f(*anchor))
        joint.CreateLocalPos1Attr(Gf.Vec3f(0, 0, 0))

        # Add angular limit
        limit_api = UsdPhysics.LimitAPI.Apply(joint.GetPrim())
        limit_api.CreateLowerLimitAttr(-limit_angle)
        limit_api.CreateUpperLimitAttr(limit_angle)

        return joint

    def configure_joint_drive(self, path, drive_type='position',
                               stiffness=0.0, damping=0.0,
                               max_force=1e6):
        """
        Configure joint drive properties.

        Args:
            path: Joint path
            drive_type: 'position', 'velocity', or 'force'
            stiffness: Drive stiffness (for position drive)
            damping: Drive damping
            max_force: Maximum drive force
        """
        drive_api = UsdPhysics.DriveAPI.Get(self.stage, path)
        if not drive_api:
            drive_api = UsdPhysics.DriveAPI.Apply(
                self.stage.GetPrimAtPath(path)
            )

        # Set drive type
        if drive_type == 'position':
            drive_api.CreateTypeAttr(UsdPhysics.DriveAPI.DrivePosition)
        elif drive_type == 'velocity':
            drive_api.CreateTypeAttr(UsdPhysics.DriveAPI.DriveVelocity)
        else:
            drive_api.CreateTypeAttr(UsdPhysics.DriveAPI.DriveForce)

        # Set parameters
        drive_api.CreateStiffnessAttr(stiffness)
        drive_api.CreateDampingAttr(damping)
        drive_api.CreateMaxForceAttr(max_force)

    def get_joint_state(self, path):
        """
        Get current state of a joint.

        Args:
            path: Joint path

        Returns:
            Dict with position, velocity, and effort
        """
        # This requires accessing PhysX interface
        # Simplified version returns USD attributes
        joint = self.stage.GetPrimAtPath(path)
        if not joint:
            return None

        # Get joint attributes
        state = {}

        # Position (would require time-sampled query)
        # Velocity (would require PhysX query)
        # Effort (would require PhysX query)

        return state

    def apply_joint_effort(self, path, effort):
        """
        Apply effort to a joint.

        Args:
            path: Joint path
            effort: Effort value to apply
        """
        joint_prim = self.stage.GetPrimAtPath(path)
        if not joint_prim:
            return

        drive_api = UsdPhysics.DriveAPI.Get(joint_prim)
        if drive_api:
            drive_api.GetTargetPositionAttr(effort)
```

## Advanced Physics Features

### Soft Body and Cloth Simulation

PhysX 5 supports soft body and cloth simulation for deformable objects. While humanoid robots are primarily rigid bodies, soft body simulation is useful for environments, clothing, and other deformable elements.

```python
# Soft body and cloth simulation setup
class SoftBodyManager:
    """
    Manager for soft body and cloth simulation.
    """

    def __init__(self, stage=None):
        self.stage = stage or omni.usd.get_context().get_stage()

    def create_soft_body(self, path, mesh_path, stiffness=0.0,
                          damping=0.0, mass=1.0):
        """
        Create a soft body from a mesh.

        Args:
            path: USD path for the soft body
            mesh_path: Source mesh path
            stiffness: Material stiffness
            damping: Damping coefficient
            mass: Total mass
        """
        # PhysX soft bodies require special setup
        # This is a simplified representation

        mesh_prim = self.stage.GetPrimAtPath(mesh_path)
        if not mesh_prim:
            raise ValueError(f"Mesh not found: {mesh_path}")

        # Apply soft body physics
        # PhysX specific APIs would be used here

        return mesh_prim

    def create_cloth(self, path, mesh_path, pinned_vertices=None):
        """
        Create a cloth simulation.

        Args:
            path: USD path for the cloth
            mesh_path: Source mesh path (should be a grid)
            pinned_vertices: List of vertex indices to pin
        """
        # Cloth setup in PhysX 5
        # Would use PhysX cloth APIs

        return self.stage.GetPrimAtPath(path)
```

## Connection to Capstone

PhysX 5 integration is essential for the **Voice-to-Action Humanoid Control Pipeline** (Voice -> Plan -> Navigate -> Vision -> Manipulate):

- **Navigate Stage**: Physics simulation provides the foundation for realistic locomotion. The rigid body dynamics and joint systems you learned here enable accurate foot-ground contact modeling, balance control, and whole-body motion planning. When your humanoid navigates to a target location, PhysX calculates ground reaction forces, friction interactions, and momentum transfer.

- **Manipulate Stage**: Object manipulation requires precise physics modeling. The collision shapes and joint drives covered in this section are critical for grasping, pushing, and carrying objects. Your capstone robot will use joint position/velocity/force control modes to execute manipulation tasks while PhysX simulates contact dynamics and object responses.

- **Pipeline Integration**: The articulated body APIs (ArticulationRootAPI) provide the interface between high-level motion planners and low-level physics simulation. Voice commands translated into motion plans are ultimately executed through the joint drive system, with PhysX ensuring physically realistic behavior.

- **Sim-to-Real Transfer**: Accurate physics parameters (mass, inertia, friction, damping) learned here directly impact how well your simulated policies transfer to real hardware. The humanoid's ability to respond to voice commands in the real world depends on simulation fidelity established through proper PhysX configuration.

## Next Steps

With PhysX 5 integration covered, you now understand how to create realistic physics simulations for humanoid robots. The next section will explore sensor simulation in Isaac Sim, teaching you how to create realistic camera, lidar, and IMU sensors for perception research.
