---
id: m3-c2-s6
title: Occupancy Mapping
sidebar_position: 6
keywords: ['occupancy', 'mapping', 'costmap', 'grid']
---

# Occupancy Mapping

## Prerequisites

Before diving into occupancy mapping, you should be familiar with:

- **Probability theory fundamentals** - Understanding of Bayes' theorem, conditional probabilities, and log-odds representations
- **2D/3D coordinate systems** - Familiarity with world frames, grid coordinates, and coordinate transformations
- **Sensor data processing** - Basic knowledge of LiDAR/depth sensor range measurements and ray casting concepts
- **Data structures** - Understanding of arrays, grids, and tree-based structures (particularly octrees)
- **ROS 2 fundamentals** - Experience with ROS 2 nodes, publishers, subscribers, and message types (for the integration section)

## Learning Objectives

By the end of this section, you will be able to:

- **[Beginner]** Define what occupancy grids are and identify their key components (resolution, probability thresholds, log-odds)
- **[Beginner]** Describe the difference between 2D occupancy grids and 3D voxel maps
- **[Intermediate]** Implement a binary Bayes filter for grid cell updates using log-odds representation
- **[Intermediate]** Configure costmap generation with inflation and caution zones for safe navigation
- **[Intermediate]** Integrate occupancy maps with ROS 2 Nav2 for humanoid robot navigation
- **[Advanced]** Optimize memory usage with octree-based volumetric mapping for large-scale environments
- **[Advanced]** Architect multi-session mapping systems with loop closure detection and map merging

## Key Concepts

| Term | Definition |
|------|------------|
| **Occupancy Grid** | A discretized 2D representation of the environment where each cell stores the probability of being occupied by an obstacle |
| **Log-Odds** | A numerical representation of probability as log(p/(1-p)), enabling efficient multiplicative updates through addition |
| **Binary Bayes Filter** | A probabilistic algorithm that updates cell occupancy beliefs based on sensor measurements using Bayes' rule |
| **Voxel** | A 3D volumetric pixel representing a unit cube in space, used for 3D environment representation |
| **Octree** | A tree data structure where each node has exactly eight children, used for memory-efficient 3D spatial indexing |
| **Costmap** | A navigation map where cell values represent traversal costs, incorporating obstacle inflation and safety margins |
| **Inflation Radius** | The distance around obstacles where costs are elevated to ensure the robot maintains safe clearance |
| **Ray Casting** | The process of tracing a line from sensor origin through measured points to update cells along the ray |

Occupancy mapping creates grid-based representations of the environment for robot navigation. This section covers various mapping techniques including 2D occupancy grids, 3D voxel maps, and costmap generation for humanoid robot navigation.

For humanoid robots navigating human environments, occupancy maps provide the spatial awareness needed for safe navigation around furniture, obstacles, and people.

## 2D Occupancy Grid Mapping

### Binary Bayes Filter for Grid Updates

```python
# 2D occupancy grid mapping
import numpy as np
from typing import Tuple, List, Dict, Optional
from dataclasses import dataclass
from scipy.ndimage import distance_transform_edt
import cv2

@dataclass
class GridConfig:
    """Occupancy grid configuration."""
    # Grid parameters
    resolution: float = 0.05  # meters/cell
    width: float = 50.0  # meters
    height: float = 50.0  # meters

    # Mapping parameters
    prior: float = 0.5  # Prior probability
    prob_hit: float = 0.7  # Probability of hit
    prob_miss: float = 0.3  # Probability of miss
    max_range: float = 10.0  # Maximum sensor range

    # Occupancy thresholds
    occupied_threshold: float = 0.7
    free_threshold: float = 0.3

class OccupancyGrid:
    """
    2D occupancy grid using binary Bayes filter.
    Maintains log-odds representation for efficient updates.
    """

    def __init__(self, config: GridConfig = None):
        """
        Initialize occupancy grid.

        Args:
            config: Grid configuration
        """
        self.config = config or GridConfig()

        # Compute grid dimensions
        self.width_cells = int(self.config.width / self.config.resolution)
        self.height_cells = int(self.config.height / self.config.resolution)

        # Initialize log-odds grid (0 = unknown)
        self.log_odds = np.zeros((self.height_cells, self.width_cells), dtype=np.float32)

        # Occupancy probability thresholds
        self.log_occ = np.log(self.config.occupied_threshold /
                              (1 - self.config.occupied_threshold))
        self.log_free = np.log(self.config.free_threshold /
                               (1 - self.config.free_threshold))

        # Prior log-odds
        self.log_prior = np.log(self.config.prior / (1 - self.config.prior))

    def world_to_grid(self, x: float, y: float) -> Tuple[int, int]:
        """Convert world coordinates to grid indices."""
        cx = int(x / self.config.resolution) + self.width_cells // 2
        cy = int(y / self.config.resolution) + self.height_cells // 2
        return (cx, cy)

    def grid_to_world(self, cx: int, cy: int) -> Tuple[float, float]:
        """Convert grid indices to world coordinates."""
        x = (cx - self.width_cells // 2) * self.config.resolution
        y = (cy - self.height_cells // 2) * self.config.resolution
        return (x, y)

    def update(self, sensor_x: float, sensor_y: float, sensor_theta: float,
               measurements: np.ndarray, angles: np.ndarray) -> None:
        """
        Update grid with new sensor measurements.

        Args:
            sensor_x: Sensor X position
            sensor_y: Sensor Y position
            sensor_theta: Sensor orientation
            measurements: Range measurements
            angles: Angles corresponding to measurements
        """
        sensor_cx, sensor_cy = self.world_to_grid(sensor_x, sensor_y)

        for i, (range_val, angle) in enumerate(zip(measurements, angles)):
            if range_val >= self.config.max_range or range_val < 0:
                continue

            # Compute world angle
            world_angle = sensor_theta + angle

            # Ray cast
            self._ray_update(sensor_cx, sensor_cy, world_angle, range_val)

    def _ray_update(self, cx: int, cy: int, angle: float, range_val: float) -> None:
        """
        Update grid cells along a ray.

        Args:
            cx: Starting cell X
            cy: Starting cell Y
            angle: Ray angle
            range_val: Measured range
        """
        # End point in grid coordinates
        end_x = cx + range_val / self.config.resolution * np.cos(angle)
        end_y = cy + range_val / self.config.resolution * np.sin(angle)

        # Get cells along ray
        cells = self._bresenham_line(cx, cy, end_x, end_y)

        if not cells:
            return

        # Mark end point as occupied
        end_cx, end_cy = cells[-1]
        if self._is_valid(end_cx, end_cy):
            self.log_odds[end_cy, end_cx] += np.log(self.config.prob_hit /
                                                    (1 - self.config.prob_hit))

        # Mark intermediate cells as free
        for c_x, c_y in cells[:-1]:
            if self._is_valid(c_x, c_y):
                self.log_odds[c_y, c_x] += np.log(self.config.prob_miss /
                                                  (1 - self.config.prob_miss))

    def _bresenham_line(self, x0: int, y0: int, x1: float, y1: float) -> List[Tuple]:
        """Bresenham's line algorithm for ray casting."""
        cells = []

        dx = abs(int(x1) - x0)
        dy = abs(int(y1) - y0)

        x, y = x0, y0

        sx = 1 if x0 < int(x1) else -1
        sy = 1 if y0 < int(y1) else -1

        if dx > dy:
            err = dx / 2.0
            while x != int(x1):
                cells.append((x, y))
                err -= dy
                if err < 0:
                    y += sy
                    err += dx
                x += sx
        else:
            err = dy / 2.0
            while y != int(y1):
                cells.append((x, y))
                err -= dx
                if err < 0:
                    x += sx
                    err += dy
                y += sy

        cells.append((x, y))
        return cells

    def _is_valid(self, cx: int, cy: int) -> bool:
        """Check if cell is within grid bounds."""
        return (0 <= cx < self.width_cells and
                0 <= cy < self.height_cells)

    def get_occupancy(self) -> np.ndarray:
        """
        Get occupancy probability grid.

        Returns:
            Grid of occupancy probabilities (0-1)
        """
        return 1 / (1 + np.exp(-self.log_odds))

    def get_binary_map(self, occupied_above: float = 0.7) -> np.ndarray:
        """
        Get binary occupancy map.

        Args:
            occupied_above: Threshold for occupied cells

        Returns:
            Binary grid (1=occupied, 0=free, 0.5=unknown)
        """
        occupancy = self.get_occupancy()
        binary = np.ones_like(occupancy) * 0.5  # Unknown

        binary[occupancy >= occupied_above] = 1.0  # Occupied
        binary[occupancy < (1 - occupied_above)] = 0.0  # Free

        return binary

    def inflate_obstacles(self, inflation_radius: float = 0.5) -> np.ndarray:
        """
        Inflate obstacles for safety margin.

        Args:
            inflation_radius: Inflation radius in meters

        Returns:
            Inflated binary map
        """
        binary = self.get_binary_map()

        # Binary obstacle map
        obstacles = (binary == 1.0).astype(np.uint8)

        # Compute inflation radius in cells
        radius_cells = int(inflation_radius / self.config.resolution)

        if radius_cells > 0:
            # Distance transform
            dist = distance_transform_edt(1 - obstacles)

            # Create inflation mask
            inflated = np.zeros_like(binary)
            inflated[dist <= radius_cells] = 1.0

            # Update original obstacles
            inflated[obstacles == 1] = 1.0

            return inflated

        return binary

    def reset(self) -> None:
        """Reset grid to prior state."""
        self.log_odds.fill(0)


class MultiSessionMapper:
    """
    Multi-session occupancy mapping.
    Supports loop closure and map merging.
    """

    def __init__(self, config: GridConfig = None):
        """Initialize multi-session mapper."""
        self.config = config or GridConfig()

        self.main_grid = OccupancyGrid(self.config)
        self.session_maps: Dict[str, OccupancyGrid] = {}

        # Loop closure detection
        self.place_recognition_db = {}

        # Map transformation registry
        self.transforms: Dict[str, np.ndarray] = {}

    def add_session(self, session_id: str, initial_pose: Tuple[float, float, float]) -> None:
        """Add a new mapping session."""
        if session_id not in self.session_maps:
            self.session_maps[session_id] = OccupancyGrid(self.config)

            # Compute transform from session to main map
            transform = self._compute_transform(initial_pose)
            self.transforms[session_id] = transform

    def merge_session(self, session_id: str) -> None:
        """Merge session map into main map."""
        if session_id not in self.session_maps:
            return

        session_grid = self.session_maps[session_id]
        transform = self.transforms[session_id]

        # Transform and merge
        for cy in range(session_grid.height_cells):
            for cx in range(session_grid.width_cells):
                if session_grid.log_odds[cy, cx] == 0:
                    continue

                # Transform coordinates
                wx, wy = session_grid.grid_to_world(cx, cy)
                main_cx, main_cy = self.main_grid.world_to_grid(wx, wy)

                if self.main_grid._is_valid(main_cx, main_cy):
                    self.main_grid.log_odds[main_cy, main_cx] += \
                        session_grid.log_odds[cy, cx]

    def _compute_transform(self, initial_pose: Tuple[float, float, float]) -> np.ndarray:
        """Compute transform from pose."""
        transform = np.eye(3)
        transform[0, 2] = initial_pose[0]
        transform[1, 2] = initial_pose[1]

        cos_theta = np.cos(initial_pose[2])
        sin_theta = np.sin(initial_pose[2])

        transform[0, 0] = cos_theta
        transform[0, 1] = -sin_theta
        transform[1, 0] = sin_theta
        transform[1, 1] = cos_theta

        return transform

    def detect_loop_closure(self, current_scan: np.ndarray,
                            current_pose: Tuple[float, float, float]) -> Optional[str]:
        """
        Detect loop closure with previous sessions.

        Args:
            current_scan: Current sensor scan descriptor
            current_pose: Current robot pose

        Returns:
            Session ID if loop closure detected
        """
        # Simple place recognition (would use more sophisticated methods)
        for session_id, descriptor in self.place_recognition_db.items():
            similarity = self._compute_similarity(current_scan, descriptor)

            if similarity > 0.8:  # Threshold
                return session_id

        # Store current scan
        self.place_recognition_db[current_pose[0]] = current_scan

        return None

    def _compute_similarity(self, scan1: np.ndarray, scan2: np.ndarray) -> float:
        """Compute similarity between scans."""
        return 1.0 - np.linalg.norm(scan1 - scan2) / (np.linalg.norm(scan1) + 1e-6)
```

## 3D Voxel Mapping

### Octree-Based Volumetric Mapping

```python
# 3D voxel mapping with octrees
import numpy as np
from typing import Tuple, List, Dict, Optional
from dataclasses import dataclass
from collections import deque

@dataclass
class VoxelConfig:
    """Voxel mapping configuration."""
    voxel_size: float = 0.1  # meters
    map_size: float = 50.0  # meters
    prob_hit: float = 0.9
    prob_miss: float = 0.1
    clamping_thres_min: float = 0.1
    clamping_thres_max: float = 0.9

class Voxel:
    """Single voxel with log-odds."""
    def __init__(self, prob: float = 0.5):
        self.log_odds = np.log(prob / (1 - prob))
        self.last_update = 0

class OctreeNode:
    """Octree node for voxel storage."""
    def __init__(self, center: Tuple[float, float, float], size: float, depth: int = 0):
        self.center = center
        self.size = size
        self.depth = depth

        self.voxel: Optional[Voxel] = None
        self.children: Optional[List['OctreeNode']] = None

    def is_leaf(self) -> bool:
        """Check if node is a leaf."""
        return self.children is None

    def subdivide(self) -> None:
        """Subdivide node into 8 children."""
        half = self.size / 2
        quarter = half / 2

        offsets = [
            (-1, -1, -1), (-1, -1, 1), (-1, 1, -1), (-1, 1, 1),
            (1, -1, -1), (1, -1, 1), (1, 1, -1), (1, 1, 1)
        ]

        self.children = []
        for dx, dy, dz in offsets:
            child_center = (
                self.center[0] + dx * quarter,
                self.center[1] + dy * quarter,
                self.center[2] + dz * quarter
            )
            self.children.append(OctreeNode(child_center, half, self.depth + 1))

class OctreeMap:
    """
    Octree-based 3D voxel map.
    Memory-efficient for large-scale environments.
    """

    def __init__(self, config: VoxelConfig = None):
        """Initialize octree map."""
        self.config = config or VoxelConfig()

        # Calculate tree depth
        self.max_size = self.config.map_size
        self.min_voxel_size = self.config.voxel_size
        self.max_depth = int(np.log2(self.max_size / self.min_voxel_size))

        # Root node
        center = (0, 0, self.config.map_size / 2)
        self.root = OctreeNode(center, self.max_size)

        # Statistics
        self.num_voxels = 0
        self.num_nodes = 1

    def update(self, origin: Tuple[float, float, float],
               direction: Tuple[float, float, float],
               range_val: float, hit: bool) -> None:
        """
        Update voxel with ray casting.

        Args:
            origin: Sensor origin
            direction: Ray direction
            range_val: Measured range
            hit: Whether ray hit an obstacle
        """
        # Step size for ray casting
        step_size = self.config.voxel_size / 2

        # Ray cast
        t = 0
        while t < range_val:
            # Current point
            point = (
                origin[0] + direction[0] * t,
                origin[1] + direction[1] * t,
                origin[2] + direction[2] * t
            )

            # Update voxel
            self._update_voxel(point, hit=False)

            t += step_size

        # Hit point
        if hit and range_val > 0:
            hit_point = (
                origin[0] + direction[0] * range_val,
                origin[1] + direction[1] * range_val,
                origin[2] + direction[2] * range_val
            )
            self._update_voxel(hit_point, hit=True)

    def _update_voxel(self, point: Tuple[float, float, float], hit: bool) -> None:
        """Update single voxel."""
        # Find containing node
        node = self.root
        while not node.is_leaf() and node.depth < self.max_depth:
            # Navigate to child
            child_idx = self._get_child_index(point, node.center)
            if node.children[child_idx] is None:
                return  # Point outside map
            node = node.children[child_idx]

        # Ensure leaf has voxel
        if node.voxel is None:
            node.voxel = Voxel()
            self.num_voxels += 1

        # Update log-odds
        if hit:
            node.voxel.log_odds += np.log(self.config.prob_hit /
                                          (1 - self.config.prob_hit))
        else:
            node.voxel.log_odds += np.log(self.config.prob_miss /
                                          (1 - self.config.prob_miss))

        # Clamp
        node.voxel.log_odds = np.clip(
            node.voxel.log_odds,
            np.log(self.config.clamping_thres_min /
                   (1 - self.config.clamping_thres_min)),
            np.log(self.config.clamping_thres_max /
                   (1 - self.config.clamping_thres_max))
        )

    def _get_child_index(self, point: Tuple, center: Tuple) -> int:
        """Get octant index for point relative to center."""
        index = 0
        if point[0] >= center[0]:
            index |= 4
        if point[1] >= center[1]:
            index |= 2
        if point[2] >= center[2]:
            index |= 1
        return index

    def get_occupancy(self, point: Tuple[float, float, float]) -> float:
        """Get occupancy probability at point."""
        node = self.root

        while node is not None:
            if node.voxel is not None:
                prob = 1 / (1 + np.exp(-node.voxel.log_odds))
                return prob

            if node.is_leaf():
                return 0.5  # Unknown

            child_idx = self._get_child_index(point, node.center)
            if node.children and node.children[child_idx]:
                node = node.children[child_idx]
            else:
                return 0.5  # Unknown

        return 0.5

    def get_point_cloud(self, threshold: float = 0.7) -> np.ndarray:
        """
        Get occupied points as point cloud.

        Args:
            threshold: Occupancy threshold

        Returns:
            Nx3 array of points
        """
        points = []
        self._collect_points(self.root, threshold, points)
        return np.array(points)

    def _collect_points(self, node: OctreeNode, threshold: float,
                        points: List) -> None:
        """Recursively collect occupied points."""
        if node.voxel is not None:
            prob = 1 / (1 + np.exp(-node.voxel.log_odds))
            if prob >= threshold:
                points.append(node.center)
                return

        if node.children:
            for child in node.children:
                if child:
                    self._collect_points(child, threshold, points)
```

## Costmap Generation

### 2D and 3D Costmaps for Navigation

```python
# Costmap generation for navigation
import numpy as np
from typing import Tuple, Dict
from scipy.ndimage import gaussian_filter

class CostmapGenerator:
    """
    Generate navigation costmaps from occupancy grids.
    Provides smooth cost functions for path planning.
    """

    def __init__(self, config: Dict = None):
        """
        Initialize costmap generator.

        Args:
            config: Configuration dictionary
        """
        self.config = config or self._default_config()

        # Cost values
        self.FREE_SPACE = 0
        self.INFLATION_ZONE = 1
        self.CAUTION_ZONE = 2
        self.OBSTACLE = 254
        self.UNKNOWN = 255

    def _default_config(self) -> Dict:
        """Default configuration."""
        return {
            'inflation_radius': 0.5,  # meters
            'caution_radius': 1.0,  # meters
            'footprint': [(0.3, 0.2), (0.3, -0.2), (-0.3, -0.2), (-0.3, 0.2)],
            'cost_smoothing': True,
            'min_cost_threshold': 1,
            'max_cost_radius': 3.0,
        }

    def generate_costmap(self, occupancy_grid: np.ndarray,
                         resolution: float) -> np.ndarray:
        """
        Generate costmap from occupancy grid.

        Args:
            occupancy_grid: 2D occupancy probabilities
            resolution: Grid resolution (meters/cell)

        Returns:
            Costmap (uint8, 0-255)
        """
        # Binary obstacle map
        binary = (occupancy_grid > 0.7).astype(np.float32)

        # Initialize costmap
        costmap = np.ones_like(occupancy_grid, dtype=np.uint8) * self.UNKNOWN

        # Mark free space
        costmap[occupancy_grid < 0.3] = self.FREE_SPACE
        costmap[occupancy_grid >= 0.7] = self.OBSTACLE

        # Add inflation zones
        costmap = self._add_inflation(costmap, binary, resolution)

        # Add caution zones
        costmap = self._add_caution_zones(costmap, binary, resolution)

        # Apply smoothing
        if self.config['cost_smoothing']:
            costmap = self._smooth_costmap(costmap)

        return costmap

    def _add_inflation(self, costmap: np.ndarray, obstacles: np.ndarray,
                       resolution: float) -> np.ndarray:
        """Add inflation around obstacles."""
        inflation_cells = int(self.config['inflation_radius'] / resolution)

        if inflation_cells <= 0:
            return costmap

        # Create distance map from obstacles
        from scipy.ndimage import distance_transform_edt

        free_space = 1 - obstacles
        dist = distance_transform_edt(free_space)

        # Convert distance to cost
        max_dist = self.config['inflation_radius'] / resolution

        # Create inflated costmap
        for i in range(costmap.shape[0]):
            for j in range(costmap.shape[1]):
                if costmap[i, j] != self.FREE_SPACE:
                    continue

                d = dist[i, j]
                if d <= max_dist:
                    # Linear falloff
                    cost = int(self.INFLATION_ZONE +
                              (self.CAUTION_ZONE - self.INFLATION_ZONE) *
                              (1 - d / max_dist))
                    costmap[i, j] = cost

        return costmap

    def _add_caution_zones(self, costmap: np.ndarray, obstacles: np.ndarray,
                           resolution: float) -> np.ndarray:
        """Add caution zones around inflated obstacles."""
        caution_cells = int(self.config['caution_radius'] / resolution)

        if caution_cells <= 0:
            return costmap

        from scipy.ndimage import distance_transform_edt

        # Start from inflation zone boundary
        non_obstacle = (costmap != self.OBSTACLE).astype(np.float32)
        dist = distance_transform_edt(non_obstacle)

        max_dist = self.config['caution_radius'] / resolution

        for i in range(costmap.shape[0]):
            for j in range(costmap.shape[1]):
                if costmap[i, j] != self.FREE_SPACE:
                    continue

                d = dist[i, j]
                if 0 < d <= max_dist:
                    costmap[i, j] = self.CAUTION_ZONE

        return costmap

    def _smooth_costmap(self, costmap: np.ndarray) -> np.ndarray:
        """Apply Gaussian smoothing to costmap."""
        # Only smooth non-obstacle cells
        mask = costmap != self.OBSTACLE

        if np.sum(mask) == 0:
            return costmap

        smoothed = gaussian_filter(
            costmap.astype(float) * mask,
            sigma=1.0
        )

        # Apply mask
        result = costmap.copy()
        result[mask] = smoothed[mask].astype(np.uint8)

        return result

    def compute_footprint_costs(self, costmap: np.ndarray,
                                robot_pose: Tuple[float, float, float],
                                resolution: float) -> float:
        """
        Compute maximum cost under robot footprint.

        Args:
            costmap: Navigation costmap
            robot_pose: (x, y, theta) in world coordinates
            resolution: Map resolution

        Returns:
            Maximum cost under footprint
        """
        footprint = self.config['footprint']
        if not footprint:
            return 0

        # Transform footprint to map coordinates
        cos_t = np.cos(robot_pose[2])
        sin_t = np.sin(robot_pose[2])

        # Get map origin (center of grid)
        origin_x = costmap.shape[1] * resolution / 2
        origin_y = costmap.shape[0] * resolution / 2

        max_cost = 0

        for fx, fy in footprint:
            # Transform
            mx = int((robot_pose[0] + fx * cos_t - fy * sin_t - origin_x) / resolution)
            my = int((robot_pose[1] + fx * sin_t + fy * cos_t - origin_y) / resolution)

            # Check bounds
            if 0 <= mx < costmap.shape[1] and 0 <= my < costmap.shape[0]:
                max_cost = max(max_cost, costmap[my, mx])

        return max_cost

    def get_layered_costmap(self, static_layer: np.ndarray,
                            obstacle_layer: np.ndarray) -> np.ndarray:
        """
        Combine costmap layers.

        Args:
            static_layer: Static costmap (walls, furniture)
            obstacle_layer: Dynamic costmap (people, moving objects)

        Returns:
            Combined costmap
        """
        # Start with static layer
        combined = static_layer.copy()

        # Overlay dynamic obstacles (override static)
        mask = obstacle_layer == self.OBSTACLE
        combined[mask] = self.OBSTACLE

        # Add inflation for dynamic obstacles
        if np.any(mask):
            from scipy.ndimage import distance_transform_edt

            dist = distance_transform_edt(1 - mask.astype(float))
            inflation_cells = int(self.config['inflation_radius'] /
                                  (1.0 / combined.shape[0]))  # Assume unit resolution

            for i in range(combined.shape[0]):
                for j in range(combined.shape[1]):
                    if dist[i, j] <= inflation_cells and combined[i, j] != self.OBSTACLE:
                        combined[i, j] = max(combined[i, j], self.INFLATION_ZONE)

        return combined
```

## ROS 2 Costmap Integration

### Costmap2DROS Wrapper

```python
# Costmap ROS 2 integration
import rclpy
from rclpy.node import Node
from nav2_msgs.msg import Costmap
from nav_msgs.msg import OccupancyGrid
from geometry_msgs.msg import Pose, Quaternion, TransformStamped
from std_msgs.msg import Header
from tf2_ros import TransformBroadcaster
import numpy as np
from typing import Optional

class HumanoidCostmapNode(Node):
    """
    Costmap node for humanoid robot navigation.
    Provides layered costmaps for Nav2 integration.
    """

    def __init__(self, config: Dict = None):
        """Initialize costmap node."""
        super().__init__('humanoid_costmap')

        self.config = config or self._default_config()

        # Layers
        self.static_layer: Optional[np.ndarray] = None
        self.obstacle_layer: Optional[np.ndarray] = None
        self.combined_layer: Optional[np.ndarray] = None

        # Metadata
        self.resolution = 0.05
        self.origin = (0.0, 0.0)
        self.width = 0
        self.height = 0

        # Generator
        self.costmap_gen = CostmapGenerator()

        # Initialize
        self._init_publishers()
        self._init_subscribers()
        self._init_timer()

        self.get_logger().info('Humanoid costmap initialized')

    def _default_config(self) -> Dict:
        """Default configuration."""
        return {
            'costmap_topic': '/humanoid_costmap',
            'static_map_topic': '/map',
            'obstacle_topic': '/obstacles',
            'update_rate': 10.0,
            'resolution': 0.05,
            'width': 50.0,
            'height': 50.0,
        }

    def _init_publishers(self):
        """Initialize ROS publishers."""
        self.costmap_pub = self.create_publisher(
            OccupancyGrid,
            self.config['costmap_topic'],
            1
        )

        # For Nav2 compatibility
        self.raw_costmap_pub = self.create_publisher(
            Costmap,
            '/costmap_raw',
            1
        )

    def _init_subscribers(self):
        """Initialize ROS subscribers."""
        self.static_sub = self.create_subscription(
            OccupancyGrid,
            self.config['static_map_topic'],
            self._static_map_callback,
            1
        )

        self.obstacle_sub = self.create_subscription(
            OccupancyGrid,
            self.config['obstacle_topic'],
            self._obstacle_callback,
            1
        )

    def _init_timer(self):
        """Initialize update timer."""
        self.create_timer(
            1.0 / self.config['update_rate'],
            self._update_callback
        )

    def _static_map_callback(self, msg: OccupancyGrid):
        """Process static map."""
        self.width = msg.info.width
        self.height = msg.info.height
        self.resolution = msg.info.resolution
        self.origin = (msg.info.origin.position.x, msg.info.origin.position.y)

        # Convert to probability grid
        self.static_layer = np.array(msg.data, dtype=np.float32)
        self.static_layer = self.static_layer.reshape(msg.info.height, msg.info.width)
        self.static_layer = self.static_layer / 100.0  # 0-1 range

        self._update_combined()

    def _obstacle_callback(self, msg: OccupancyGrid):
        """Process obstacle layer."""
        if self.width == 0:
            return

        # Resize if necessary
        if (msg.info.width != self.width or
            msg.info.height != self.height or
            abs(msg.info.resolution - self.resolution) > 1e-6):
            self._resize_obstacle_layer(msg)

        # Update obstacle layer
        self.obstacle_layer = np.array(msg.data, dtype=np.float32)
        self.obstacle_layer = self.obstacle_layer.reshape(msg.info.height, msg.info.width)
        self.obstacle_layer = self.obstacle_layer / 100.0

        self._update_combined()

    def _resize_obstacle_layer(self, msg: OccupancyGrid):
        """Resize obstacle layer to match static map."""
        self.obstacle_layer = np.zeros((self.height, self.width), dtype=np.float32)

    def _update_combined(self):
        """Update combined costmap layer."""
        if self.static_layer is None:
            return

        # Initialize if needed
        if self.combined_layer is None:
            self.combined_layer = np.zeros_like(self.static_layer)

        # Generate costmap
        self.combined_layer = self.costmap_gen.generate_costmap(
            self.static_layer,
            self.resolution
        )

        # Publish
        self._publish_costmap()

    def _publish_costmap(self):
        """Publish costmap as OccupancyGrid."""
        if self.combined_layer is None:
            return

        msg = OccupancyGrid()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = 'map'

        msg.info.width = self.width
        msg.info.height = self.height
        msg.info.resolution = self.resolution

        msg.info.origin.position.x = self.origin[0]
        msg.info.origin.position.y = self.origin[1]
        msg.info.origin.position.z = 0

        # Convert to ROS format
        data = (self.combined_layer.flatten() * 100).astype(np.int8)
        data = np.clip(data, -128, 127)
        msg.data = data.tolist()

        self.costmap_pub.publish(msg)

    def _update_callback(self):
        """Periodic update."""
        # Can be used for time-based updates
        pass

    def get_costmap(self) -> Optional[np.ndarray]:
        """Get current costmap."""
        return self.combined_layer

    def world_to_costmap(self, x: float, y: float) -> Tuple[int, int]:
        """Convert world coordinates to costmap indices."""
        cx = int((x - self.origin[0]) / self.resolution)
        cy = int((y - self.origin[1]) / self.resolution)
        return (cx, cy)
```

## Connection to Capstone

Occupancy mapping serves as the foundational spatial representation layer in the **Voice-to-Plan-to-Navigate-to-Vision-to-Manipulate** capstone pipeline:

**Navigate Stage Integration:**
- The occupancy grid provides the environmental map that path planners use to compute collision-free trajectories from voice-commanded goals
- Costmaps with inflation zones ensure the humanoid robot maintains safe clearance from obstacles while executing navigation plans
- Real-time costmap updates enable dynamic obstacle avoidance as the robot moves through the environment

**Vision Stage Support:**
- 3D voxel maps provide spatial context for vision systems, helping to localize detected objects within the environment
- The octree structure enables efficient spatial queries when vision detects objects that need to be incorporated into the map
- Multi-session mapping supports persistent environment understanding across multiple robot deployments

**Manipulate Stage Foundation:**
- Precise occupancy information around target objects enables safe approach planning for manipulation tasks
- The costmap footprint checking ensures the robot can safely position itself for grasping operations
- Height-aware 3D mapping distinguishes between floor-level obstacles and table-top objects relevant to manipulation

**End-to-End Pipeline Flow:**
When a user issues a voice command like "bring me the cup from the kitchen," the occupancy map enables the **Navigate** stage to plan a path to the kitchen, the **Vision** stage to localize the cup within the mapped environment, and the **Manipulate** stage to approach the cup safely for grasping.

## Next Steps

With Occupancy Mapping covered, you can now create environment representations for humanoid robot navigation. The next section explores Semantic Scene Understanding, covering high-level scene interpretation and reasoning for intelligent robot behavior.
