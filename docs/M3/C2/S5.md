---
id: m3-c2-s5
title: Nav2 Integration for Path Planning
sidebar_position: 5
keywords: ['nav2', 'path-planning', 'navigation', 'autonomous']
---

# Nav2 Integration for Path Planning

## Prerequisites

Before diving into Nav2 integration, ensure you have:

- **ROS 2 fundamentals**: Comfortable with nodes, topics, services, and actions in ROS 2 (covered in M2-C1)
- **Basic path planning knowledge**: Understanding of graph search algorithms (A*, Dijkstra) and their application to robotics
- **Python proficiency**: Ability to write and understand Python classes, dataclasses, and type hints
- **Occupancy grid concepts**: Familiarity with grid-based environment representations and coordinate transformations
- **Isaac Sim basics**: Experience running simulations and interfacing with ROS 2 bridge (covered in M3-C1)

## Learning Objectives

By the end of this section, you will be able to:

- **[Beginner]** Define the roles of global and local planners in autonomous navigation
- **[Beginner]** Identify the key components of the Nav2 navigation stack
- **[Intermediate]** Implement a Hybrid A* planner with non-holonomic constraints for humanoid robots
- **[Intermediate]** Configure and integrate the Dynamic Window Approach (DWA) local planner
- **[Intermediate]** Create a ROS 2 node that interfaces with Nav2 action servers
- **[Advanced]** Architect recovery behavior strategies for handling navigation failures
- **[Advanced]** Optimize planner parameters for simulation-to-real transfer scenarios

## Key Concepts

| Term | Definition |
|------|------------|
| **Nav2** | The standard ROS 2 navigation stack providing autonomous navigation capabilities including planning, control, and recovery |
| **Global Planner** | Algorithm that computes a collision-free path from start to goal using a map of the environment |
| **Local Planner** | Real-time controller that adjusts the global path to avoid dynamic obstacles while respecting robot dynamics |
| **Hybrid A*** | Path planning algorithm that combines grid-based A* with continuous state space to handle non-holonomic constraints |
| **Dynamic Window Approach (DWA)** | Local planning method that samples admissible velocities and selects the optimal trajectory based on multiple objectives |
| **Costmap** | Grid representation where each cell contains the cost of traversal, used by planners to avoid obstacles |
| **Recovery Behavior** | Fallback actions (rotate, back up, wait) executed when the robot becomes stuck or navigation fails |
| **Non-holonomic Constraints** | Kinematic restrictions that limit robot motion (e.g., a car cannot move sideways directly) |

:::danger Latency Trap Warning
**Nav2 planners MUST run locally with sensor data.** Remote path planning introduces unacceptable delays for obstacle avoidance:
- Run Nav2 stack on Jetson with direct sensor access
- Local costmap updates require sub-100ms latency
- Never stream lidar/depth data over WiFi during active navigation
:::

Nav2 is the standard navigation stack for ROS 2, providing autonomous navigation capabilities for mobile robots including humanoid robots. This section covers Nav2 integration with Isaac Sim for simulation-to-real transfer, including global and local path planning, obstacle avoidance, and recovery behaviors.

For humanoid robots, navigation extends beyond simple point-to-point movement. The robot must consider its bipedal nature, maintain balance during movement, and navigate complex environments designed for humans.

## Global Planning

### A* and Hybrid A* Algorithms

Global planning computes collision-free paths through the environment. For humanoid robots, we use Hybrid A* that considers vehicle kinematics.

```python
# Global planning with Hybrid A*
import numpy as np
from typing import Tuple, List, Dict, Optional
from dataclasses import dataclass
import heapq

@dataclass
class PathPoint:
    """Point on a path with heading."""
    x: float
    y: float
    heading: float  # radians
    cost: float

@dataclass
class PlanningConfig:
    """Planning configuration."""
    # Grid parameters
    grid_resolution: float = 0.1  # meters
    heading_resolution: float = np.pi / 12  # 15 degrees

    # Vehicle parameters
    min_turning_radius: float = 0.5  # meters
    max_steering_angle: float = np.pi / 4  # 45 degrees

    # Planning parameters
    max_iterations: int = 10000
    timeout_seconds: float = 5.0

class HybridAStarPlanner:
    """
    Hybrid A* planner for humanoid robot navigation.
    Considers non-holonomic constraints while planning in continuous space.
    """

    def __init__(self, config: PlanningConfig = None):
        """
        Initialize planner.

        Args:
            config: Planning configuration
        """
        self.config = config or PlanningConfig()

        # State space bounds
        self.x_range = (0, 100)  # meters
        self.y_range = (0, 100)  # meters
        self.heading_range = (-np.pi, np.pi)

        # Cost weights
        self.forward_cost = 1.0
        self.reverse_cost = 2.0
        self.turn_cost = 0.5
        self.obstacle_penalty = 1000.0

        # Motion primitives
        self._init_motion_primitives()

    def _init_motion_primitives(self):
        """Initialize motion primitives for planning."""
        # Steering angles to explore
        num_angles = 7
        self.steering_angles = np.linspace(
            -self.config.max_steering_angle,
            self.config.max_steering_angle,
            num_angles
        )

        # Step sizes
        self.step_size = self.config.grid_resolution * 2

    def plan(self, start: Tuple[float, float, float],
             goal: Tuple[float, float, float],
             occupancy_grid: np.ndarray,
             origin: Tuple[float, float],
             resolution: float) -> List[PathPoint]:
        """
        Plan path from start to goal.

        Args:
            start: (x, y, heading) in world coordinates
            goal: (x, y, heading) in world coordinates
            occupancy_grid: Binary grid (0=free, 1=occupied)
            origin: (x, y) of grid origin in world coords
            resolution: Grid resolution (meters/cell)

        Returns:
            List of path points
        """
        # Convert to grid coordinates
        start_state = self._world_to_state(start, occupancy_grid, origin, resolution)
        goal_state = self._world_to_state(goal, occupancy_grid, origin, resolution)

        # Check start and goal validity
        if not self._is_valid_state(start_state, occupancy_grid):
            return []
        if not self._is_valid_state(goal_state, occupancy_grid):
            return []

        # A* search
        open_set = [(0, start_state)]
        came_from = {}
        cost_so_far = {start_state: 0}

        iterations = 0

        while open_set and iterations < self.config.max_iterations:
            iterations += 1

            # Get lowest cost state
            _, current = heapq.heappop(open_set)

            # Check goal
            if self._is_goal(current, goal_state):
                return self._reconstruct_path(came_from, current, origin, resolution)

            # Expand neighbors
            for steering in self.steering_angles:
                next_state = self._expand(current, steering)

                if not self._is_valid_state(next_state, occupancy_grid):
                    continue

                new_cost = cost_so_far[current] + self._transition_cost(current, next_state)

                if next_state not in cost_so_far or new_cost < cost_so_far[next_state]:
                    cost_so_far[next_state] = new_cost
                    priority = new_cost + self._heuristic(next_state, goal_state)
                    heapq.heappush(open_set, (priority, next_state))
                    came_from[next_state] = current

        # No path found
        return []

    def _world_to_state(self, world_pos: Tuple[float, float, float],
                        grid: np.ndarray, origin: Tuple[float, float],
                        resolution: float) -> Tuple:
        """Convert world position to state tuple."""
        x = int((world_pos[0] - origin[0]) / resolution)
        y = int((world_pos[1] - origin[1]) / resolution)
        heading = world_pos[2]

        # Normalize heading
        while heading > np.pi:
            heading -= 2 * np.pi
        while heading < -np.pi:
            heading += 2 * np.pi

        return (x, y, heading)

    def _state_to_world(self, state: Tuple, origin: Tuple[float, float],
                        resolution: float) -> Tuple[float, float, float]:
        """Convert state to world position."""
        return (
            state[0] * resolution + origin[0],
            state[1] * resolution + origin[1],
            state[2]
        )

    def _expand(self, state: Tuple, steering: float) -> Tuple:
        """Generate next state from motion primitive."""
        x, y, heading = state

        # Non-holonomic motion
        if abs(steering) < 1e-6:
            # Straight motion
            new_x = x + self.step_size * np.cos(heading)
            new_y = y + self.step_size * np.sin(heading)
            new_heading = heading
        else:
            # Curved motion
            radius = self.config.min_turning_radius / max(abs(steering), 1e-6)
            angle = self.step_size / radius

            # Center of rotation
            cx = x - radius * np.sin(heading)
            cy = y + radius * np.cos(heading)

            new_heading = heading + angle * np.sign(steering)
            new_x = cx + radius * np.sin(new_heading)
            new_y = cy - radius * np.cos(new_heading)

        # Normalize heading
        new_heading = (new_heading + np.pi) % (2 * np.pi) - np.pi

        return (new_x, new_y, new_heading)

    def _is_valid_state(self, state: Tuple, grid: np.ndarray) -> bool:
        """Check if state is valid (within bounds and not in obstacle)."""
        x, y, _ = state

        # Check bounds
        if x < 0 or x >= grid.shape[1]:
            return False
        if y < 0 or y >= grid.shape[0]:
            return False

        # Check obstacle
        if grid[int(y), int(x)] > 0:
            return False

        return True

    def _is_goal(self, state: Tuple, goal: Tuple) -> bool:
        """Check if state is at goal."""
        x, y, heading = state
        gx, gy, gheading = goal

        # Position tolerance
        pos_tolerance = 3  # cells
        if abs(x - gx) > pos_tolerance or abs(y - gy) > pos_tolerance:
            return False

        # Heading tolerance
        heading_diff = abs(heading - gheading)
        heading_diff = min(heading_diff, 2 * np.pi - heading_diff)

        return heading_diff < self.config.heading_resolution

    def _transition_cost(self, from_state: Tuple, to_state: Tuple) -> float:
        """Compute transition cost between states."""
        x1, y1, h1 = from_state
        x2, y2, h2 = to_state

        # Distance cost
        dist = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)

        # Direction change cost
        heading_change = abs(h2 - h1)
        heading_change = min(heading_change, 2 * np.pi - heading_change)

        # Reverse penalty
        direction = np.cos(h2 - h1)
        if direction < 0:
            dist *= self.reverse_cost

        return dist + heading_change * self.turn_cost

    def _heuristic(self, state: Tuple, goal: Tuple) -> float:
        """Heuristic function (Euclidean distance)."""
        return np.sqrt((state[0] - goal[0])**2 + (state[1] - goal[1])**2)

    def _reconstruct_path(self, came_from: Dict, current: Tuple,
                          origin: Tuple[float, float],
                          resolution: float) -> List[PathPoint]:
        """Reconstruct path from goal to start."""
        path = []

        while current in came_from:
            world_pos = self._state_to_world(current, origin, resolution)
            path.append(PathPoint(
                x=world_pos[0],
                y=world_pos[1],
                heading=world_pos[2],
                cost=0
            ))
            current = came_from[current]

        # Add start
        world_pos = self._state_to_world(current, origin, resolution)
        path.append(PathPoint(
            x=world_pos[0],
            y=world_pos[1],
            heading=world_pos[2],
            cost=0
        ))

        return list(reversed(path))
```

## Local Planning

### DWA and TEB Local Planners

Local planning adjusts the global path in real-time to avoid obstacles and follow the robot's dynamics constraints.

```python
# Dynamic Window Approach local planner
import numpy as np
from typing import Tuple, List, Dict
import math

class DWALocalPlanner:
    """
    Dynamic Window Approach for local trajectory planning.
    Considers robot dynamics and obstacle positions.
    """

    def __init__(self, config: Dict = None):
        """
        Initialize DWA planner.

        Args:
            config: Planner configuration
        """
        self.config = config or self._default_config()

        # Robot parameters
        self.max_linear_vel = self.config.get('max_linear_vel', 0.5)
        self.max_angular_vel = self.config.get('max_angular_vel', 1.0)
        self.max_linear_accel = self.config.get('max_linear_accel', 0.5)
        self.max_angular_accel = self.config.get('max_angular_accel', 1.0)

        # Velocity resolution
        self.dv = self.config.get('velocity_resolution', 0.01)
        self.dw = self.config.get('angular_resolution', 0.01)

        # Prediction time
        self.predict_time = self.config.get('predict_time', 3.0)

        # Cost weights
        self.weight_heading = self.config.get('weight_heading', 0.2)
        self.weight_distance = self.config.get('weight_distance', 0.6)
        self.weight_velocity = self.config.get('weight_velocity', 0.2)

    def _default_config(self) -> Dict:
        """Default configuration."""
        return {
            'max_linear_vel': 0.5,
            'max_angular_vel': 1.0,
            'max_linear_accel': 0.5,
            'max_angular_accel': 1.0,
            'velocity_resolution': 0.01,
            'angular_resolution': 0.01,
            'predict_time': 3.0,
            'weight_heading': 0.2,
            'weight_distance': 0.6,
            'weight_velocity': 0.2,
        }

    def plan(self, current_pose: Tuple[float, float, float],
             goal_pose: Tuple[float, float, float],
             current_velocity: Tuple[float, float],
             obstacles: List[Tuple[float, float, float]]) -> Tuple[float, float]:
        """
        Compute optimal velocity command.

        Args:
            current_pose: (x, y, theta) current pose
            goal_pose: (x, y, theta) goal pose
            current_velocity: (v, w) current velocity
            obstacles: List of (x, y, radius) obstacles

        Returns:
            Optimal (linear, angular) velocity
        """
        # Get admissible velocities
        admissible_velocities = self._get_admissible_velocities(
            current_pose, current_velocity, obstacles
        )

        if not admissible_velocities:
            # No safe velocities - stop
            return (0.0, 0.0)

        best_velocity = None
        best_score = -float('inf')

        for v, w in admissible_velocities:
            # Simulate trajectory
            trajectory = self._simulate_trajectory(
                current_pose, v, w, current_velocity
            )

            # Compute score
            score = self._evaluate_trajectory(
                trajectory, goal_pose, obstacles
            )

            if score > best_score:
                best_score = score
                best_velocity = (v, w)

        return best_velocity or (0.0, 0.0)

    def _get_admissible_velocities(self, pose: Tuple[float, float, float],
                                   velocity: Tuple[float, float],
                                   obstacles: List[Tuple]) -> List[Tuple]:
        """Get velocities that avoid obstacles."""
        admissible = []

        # Current velocity bounds
        v_min = max(-self.max_linear_vel,
                   velocity[0] - self.max_linear_accel * self.predict_time)
        v_max = min(self.max_linear_vel,
                   velocity[0] + self.max_linear_accel * self.predict_time)

        w_min = max(-self.max_angular_vel,
                   velocity[1] - self.max_angular_accel * self.predict_time)
        w_max = min(self.max_angular_vel,
                   velocity[1] + self.max_angular_accel * self.predict_time)

        # Sample velocities
        for v in np.arange(v_min, v_max + self.dv, self.dv):
            for w in np.arange(w_min, w_max + self.dw, self.dw):
                if self._is_safe_velocity(pose, v, w, obstacles):
                    admissible.append((v, w))

        return admissible

    def _is_safe_velocity(self, pose: Tuple[float, float, float],
                          v: float, w: float,
                          obstacles: List[Tuple]) -> bool:
        """Check if velocity is safe from obstacles."""
        x, y, theta = pose

        # Simulate forward
        time_step = 0.1
        total_time = self.predict_time

        for t in np.arange(0, total_time, time_step):
            # Simple motion model
            x += v * np.cos(theta) * time_step
            y += v * np.sin(theta) * time_step
            theta += w * time_step

            # Check collision
            for ox, oy, radius in obstacles:
                dist = np.sqrt((x - ox)**2 + (y - oy)**2)
                if dist < radius + 0.1:  # Robot radius + margin
                    return False

        return True

    def _simulate_trajectory(self, pose: Tuple[float, float, float],
                              v: float, w: float,
                              initial_velocity: Tuple[float, float]) -> List[Tuple]:
        """Simulate robot trajectory."""
        trajectory = []
        x, y, theta = pose

        time_step = 0.1
        total_time = self.predict_time

        for t in np.arange(0, total_time, time_step):
            trajectory.append((x, y, theta))

            # Update state
            x += v * np.cos(theta) * time_step
            y += v * np.sin(theta) * time_step
            theta += w * time_step

            # Decay velocity
            v = v * 0.95
            w = w * 0.95

        return trajectory

    def _evaluate_trajectory(self, trajectory: List[Tuple],
                             goal: Tuple[float, float, float],
                             obstacles: List[Tuple]) -> float:
        """Evaluate trajectory with multiple objectives."""
        if not trajectory:
            return -float('inf')

        # Heading score (alignment with goal)
        final_x, final_y, final_theta = trajectory[-1]
        goal_heading = np.arctan2(
            goal[1] - final_y,
            goal[0] - final_x
        )
        heading_diff = abs(final_theta - goal_heading)
        heading_diff = min(heading_diff, 2 * np.pi - heading_diff)
        heading_score = 1.0 - heading_diff / np.pi

        # Distance score (proximity to goal)
        dist_to_goal = np.sqrt(
            (final_x - goal[0])**2 + (final_y - goal[1])**2
        )
        max_dist = 10.0  # Maximum relevant distance
        distance_score = max(0, 1.0 - dist_to_goal / max_dist)

        # Velocity score
        avg_velocity = len(trajectory) / self.predict_time  # Placeholder

        # Obstacle clearance score
        clearance_score = self._min_obstacle_clearance(trajectory, obstacles)

        # Combine scores
        total_score = (
            self.weight_heading * heading_score +
            self.weight_distance * distance_score +
            self.weight_velocity * avg_velocity +
            clearance_score
        )

        return total_score

    def _min_obstacle_clearance(self, trajectory: List[Tuple],
                                obstacles: List[Tuple]) -> float:
        """Compute minimum clearance from obstacles."""
        min_clearance = float('inf')

        for x, y, _ in trajectory:
            for ox, oy, radius in obstacles:
                dist = np.sqrt((x - ox)**2 + (y - oy)**2)
                clearance = dist - radius
                min_clearance = min(min_clearance, clearance)

        if min_clearance < 0:
            return -10.0  # Collision penalty
        elif min_clearance < 0.5:
            return min_clearance * 2  # Reduced score for close obstacles
        else:
            return 0.5  # Bonus for safe distance
```

## Nav2 Integration

### Nav2 Node Implementation

```python
# Nav2 integration for humanoid robots
import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from nav2_msgs.action import NavigateToPose
from geometry_msgs.msg import PoseStamped, Twist
from nav_msgs.msg import Odometry, OccupancyGrid
from std_msgs.msg import String
from std_srvs.srv import SetBool
from typing import Optional, Callable
import asyncio

class HumanoidNav2(Node):
    """
    Nav2 navigation node for humanoid robots.
    Integrates with Isaac Sim and provides high-level navigation commands.
    """

    def __init__(self, config: Dict = None):
        """Initialize Nav2 navigation node."""
        super().__init__('humanoid_nav2')

        self.config = config or self._default_config()

        # Navigation state
        self.current_pose: Optional[Tuple[float, float, float]] = None
        self.goal_pose: Optional[Tuple[float, float, float]] = None
        self.is_navigating = False
        self.nav_result = None

        # Initialize components
        self._init_parameters()
        self._init_publishers()
        self._init_subscribers()
        self._init_action_client()
        self._init_services()

        self.get_logger().info('Humanoid Nav2 initialized')

    def _default_config(self) -> Dict:
        """Default configuration."""
        return {
            'planner': 'hybrid_astar',
            'controller': 'dwa',
            'global_costmap_topic': '/global_costmap/costmap_raw',
            'local_costmap_topic': '/local_costmap/costmap_raw',
            'cmd_vel_topic': '/cmd_vel',
            'odom_topic': '/odom',
            'use_sim_time': True,
        }

    def _init_parameters(self):
        """Declare and get parameters."""
        self.declare_parameter('planner', 'hybrid_astar')
        self.declare_parameter('controller', 'dwa')
        self.declare_parameter('use_sim_time', True)

    def _init_publishers(self):
        """Initialize ROS publishers."""
        # Velocity command publisher
        self.cmd_vel_pub = self.create_publisher(
            Twist,
            self.config['cmd_vel_topic'],
            10
        )

        # Goal pose publisher (for visualization)
        self.goal_pub = self.create_publisher(
            PoseStamped,
            '/humanoid_nav2/goal',
            10
        )

        # Navigation status publisher
        self.status_pub = self.create_publisher(
            String,
            '/humanoid_nav2/status',
            10
        )

    def _init_subscribers(self):
        """Initialize ROS subscribers."""
        # Odometry subscriber
        self.odom_sub = self.create_subscription(
            Odometry,
            self.config['odom_topic'],
            self._odom_callback,
            10
        )

        # Global costmap subscriber
        self.global_costmap_sub = self.create_subscription(
            OccupancyGrid,
            self.config['global_costmap_topic'],
            self._global_costmap_callback,
            10
        )

    def _init_action_client(self):
        """Initialize Nav2 action client."""
        self.nav_client = ActionClient(
            self,
            NavigateToPose,
            '/navigate_to_pose'
        )

    def _init_services(self):
        """Initialize ROS services."""
        # Navigation service
        self.nav_service = self.create_service(
            SetBool,
            '/humanoid_nav2/navigate',
            self._nav_service_callback
        )

    def _odom_callback(self, msg: Odometry):
        """Process odometry data."""
        # Extract pose
        pose = msg.pose.pose
        self.current_pose = (
            pose.position.x,
            pose.position.y,
            self._get_yaw(pose.orientation)
        )

    def _get_yaw(self, quaternion) -> float:
        """Extract yaw from quaternion."""
        import tf_transformations as tft

        euler = tft.euler_from_quaternion([
            quaternion.x,
            quaternion.y,
            quaternion.z,
            quaternion.w
        ])
        return euler[2]

    def _global_costmap_callback(self, msg: OccupancyGrid):
        """Process global costmap."""
        self.global_costmap = msg

    def navigate_to(self, x: float, y: float, theta: float = 0.0) -> bool:
        """
        Navigate to a pose.

        Args:
            x: X position (meters)
            y: Y position (meters)
            theta: Target orientation (radians)

        Returns:
            True if navigation started successfully
        """
        if self.is_navigating:
            self.get_logger().warn('Already navigating')
            return False

        # Create goal pose
        goal_pose = PoseStamped()
        goal_pose.header.frame_id = 'map'
        goal_pose.header.stamp = self.get_clock().now().to_msg()
        goal_pose.pose.position.x = x
        goal_pose.pose.position.y = y

        # Set orientation
        import tf_transformations as tft
        q = tft.quaternion_from_euler(0, 0, theta)
        goal_pose.pose.orientation.x = q[0]
        goal_pose.pose.orientation.y = q[1]
        goal_pose.pose.orientation.z = q[2]
        goal_pose.pose.orientation.w = q[3]

        # Send goal
        self.goal_pose = (x, y, theta)

        # Wait for action server
        if not self.nav_client.wait_for_server(timeout_sec=5.0):
            self.get_logger().error('Nav2 action server not available')
            return False

        # Send goal
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose = goal_pose

        self.get_logger().info(f'Navigating to ({x:.2f}, {y:.2f})')

        # Send goal asynchronously
        self.nav_future = self.nav_client.send_goal_async(
            goal_msg,
            feedback_callback=self._nav_feedback_callback
        )
        self.nav_future.add_done_callback(self._nav_done_callback)

        self.is_navigating = True
        return True

    def _nav_feedback_callback(self, feedback):
        """Process navigation feedback."""
        # Can be used for progress tracking
        pass

    def _nav_done_callback(self, future):
        """Handle navigation completion."""
        goal_handle = future.result()

        if not goal_handle.accepted:
            self.get_logger().error('Goal rejected by Nav2')
            self.is_navigating = False
            return

        self.get_logger().info('Goal accepted by Nav2')

        # Wait for result
        self.result_future = goal_handle.get_result_async()
        self.result_future.add_done_callback(self._nav_result_callback)

    def _nav_result_callback(self, future):
        """Process navigation result."""
        result = future.result()
        self.nav_result = result

        if result.status == 4:  # SUCCEEDED
            self.get_logger().info('Navigation succeeded')
        elif result.status == 6:  # CANCELED
            self.get_logger().info('Navigation canceled')
        else:
            self.get_logger().error(f'Navigation failed with status {result.status}')

        self.is_navigating = False
        self.goal_pose = None

    def _nav_service_callback(self, request, response):
        """Handle service call for navigation."""
        # Toggle navigation state
        if request.data:
            # Start navigation service mode
            response.success = True
            response.message = 'Navigation service enabled'
        else:
            # Stop current navigation
            if self.is_navigating:
                self.cancel_navigation()
            response.success = True
            response.message = 'Navigation stopped'

        return response

    def cancel_navigation(self):
        """Cancel current navigation."""
        if self.nav_future and not self.nav_future.done():
            self.nav_future.cancel()

        if self.result_future and not self.result_future.done():
            self.result_future.cancel()

        self.is_navigating = False
        self.goal_pose = None
        self.get_logger().info('Navigation canceled')

    def get_status(self) -> Dict:
        """Get navigation status."""
        return {
            'is_navigating': self.is_navigating,
            'current_pose': self.current_pose,
            'goal_pose': self.goal_pose,
            'last_result': self.nav_result.status if self.nav_result else None,
        }

    def shutdown(self):
        """Shutdown navigation node."""
        self.cancel_navigation()
        self.destroy_node()
```

## Recovery Behaviors

### Fallback and Recovery Strategies

```python
# Recovery behavior implementation
from enum import Enum
from typing import Callable, List
import time

class RecoveryState(Enum):
    """Recovery behavior states."""
    IDLE = 'idle'
    ROTATING = 'rotating'
    BACKING = 'backing'
    WAITING = 'waiting'

class RecoveryManager:
    """
    Manage recovery behaviors for navigation failures.
    Implements escalating recovery strategies.
    """

    def __init__(self, config: Dict = None):
        """
        Initialize recovery manager.

        Args:
            config: Recovery configuration
        """
        self.config = config or self._default_config()

        self.current_state = RecoveryState.IDLE
        self.recovery_count = 0
        self.last_recovery_time = 0

        # Recovery behavior registry
        self.behaviors: List[Callable] = []

        # State callbacks
        self.state_callbacks: Dict[RecoveryState, Callable] = {}

    def _default_config(self) -> Dict:
        """Default configuration."""
        return {
            'max_recovery_attempts': 3,
            'rotation_angle': np.pi,  # 180 degrees
            'back_distance': 0.5,  # meters
            'wait_time': 2.0,  # seconds
            'recovery_cooldown': 10.0,  # seconds
        }

    def add_behavior(self, name: str, behavior: Callable):
        """
        Add a recovery behavior.

        Args:
            name: Behavior name
            behavior: Callable that executes behavior
        """
        self.behaviors.append(behavior)

    def get_recovery_behavior(self) -> Optional[Callable]:
        """
        Get next recovery behavior to execute.

        Returns:
            Recovery behavior or None if max attempts reached
        """
        if self.recovery_count >= self.config['max_recovery_attempts']:
            return None

        behavior_index = self.recovery_count % len(self.behaviors)
        return self.behaviors[behavior_index]

    def execute_recovery(self, cmd_vel_pub: Callable,
                         get_stuck_state: Callable) -> bool:
        """
        Execute recovery behavior.

        Args:
            cmd_vel_pub: Function to publish velocity commands
            get_stuck_state: Function to check if robot is stuck

        Returns:
            True if recovery successful
        """
        # Check cooldown
        if time.time() - self.last_recovery_time < self.config['recovery_cooldown']:
            return False

        # Check if still stuck
        if not get_stuck_state():
            self.recovery_count = 0
            return True

        # Get recovery behavior
        behavior = self.get_recovery_behavior()
        if behavior is None:
            self.get_logger().error('Max recovery attempts reached')
            return False

        # Execute behavior
        self.current_state = RecoveryState.ROTATING
        behavior(cmd_vel_pub)

        self.recovery_count += 1
        self.last_recovery_time = time.time()

        return True

    def reset(self):
        """Reset recovery state."""
        self.recovery_count = 0
        self.current_state = RecoveryState.IDLE

    def rotate_recovery(self, cmd_vel_pub: Callable):
        """Execute rotation recovery."""
        from geometry_msgs.msg import Twist

        cmd = Twist()
        cmd.angular.z = 0.5  # Rotate at 0.5 rad/s

        # Rotate for half rotation
        duration = self.config['rotation_angle'] / abs(cmd.angular.z)
        start_time = time.time()

        while time.time() - start_time < duration and rclpy.ok():
            cmd_vel_pub(cmd)
            time.sleep(0.1)

        # Stop
        cmd = Twist()
        cmd_vel_pub(cmd)

    def back_up_recovery(self, cmd_vel_pub: Callable):
        """Execute back up recovery."""
        from geometry_msgs.msg import Twist

        cmd = Twist()
        cmd.linear.x = -0.2  # Back up at 0.2 m/s

        duration = self.config['back_distance'] / abs(cmd.linear.x)
        start_time = time.time()

        while time.time() - start_time < duration and rclpy.ok():
            cmd_vel_pub(cmd)
            time.sleep(0.1)

        # Stop
        cmd = Twist()
        cmd_vel_pub(cmd)

    def wait_recovery(self, cmd_vel_pub: Callable):
        """Execute wait recovery (for dynamic obstacles)."""
        from geometry_msgs.msg import Twist

        cmd = Twist()  # Zero velocity

        duration = self.config['wait_time']
        start_time = time.time()

        while time.time() - start_time < duration and rclpy.ok():
            cmd_vel_pub(cmd)
            time.sleep(0.1)
```

## Connection to Capstone

Nav2 integration is a critical component in the **Voice-to-Plan-to-Navigate-to-Vision-to-Manipulate** pipeline that powers the capstone humanoid assistant:

- **Voice-to-Plan**: When the user issues a voice command like "Go to the kitchen and fetch the cup," natural language processing extracts the navigation goal. Nav2 receives this goal as a target pose.

- **Plan-to-Navigate**: The global planner (Hybrid A*) computes an optimal path through the environment, while the local planner (DWA) handles real-time obstacle avoidance. This section provides the complete navigation layer that translates high-level goals into safe robot motion.

- **Navigate-to-Vision**: As the robot approaches the target location, the navigation stack coordinates with the perception system. Nav2 feedback (current pose, remaining distance) triggers when to activate object detection and localization modules.

- **Vision-to-Manipulate**: Once Nav2 reports successful arrival at the goal pose, control transfers to the manipulation pipeline. The recovery behaviors you learned here ensure the robot can reliably reach positions suitable for grasping tasks.

The `HumanoidNav2` class serves as the integration point between your conversational AI planner and the physical robot execution. By mastering Nav2 integration, you enable your humanoid to autonomously traverse human environments - the essential bridge between understanding a task and physically accomplishing it.

## Next Steps

With Nav2 Integration covered, you can now implement autonomous navigation for humanoid robots. The next section explores Occupancy Mapping, covering grid-based environment representation for robot navigation.
