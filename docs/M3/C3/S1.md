---
id: m3-c3-s1
title: Bipedal Locomotion Fundamentals
sidebar_position: 1
keywords: ['bipedal', 'locomotion', 'walking', 'gait']
---

## Prerequisites

Before diving into bipedal locomotion fundamentals, you should be familiar with:

- **Rigid body dynamics** - Understanding of mass, inertia tensors, and Newton-Euler equations for multi-body systems
- **Control theory basics** - Familiarity with PD/PID controllers, state-space representations, and feedback control concepts
- **Linear algebra** - Matrix operations, eigenvalues, and coordinate transformations (rotation matrices, homogeneous transforms)
- **Python programming** - Proficiency with NumPy for numerical computations and dataclasses for structured data
- **Humanoid robot kinematics** - Knowledge of joint configurations, forward/inverse kinematics for leg chains (covered in Module 2)

## Learning Objectives

By the end of this section, you will be able to:

| Level | Objective |
|-------|-----------|
| **Beginner** | Define the Zero Moment Point (ZMP) and explain its role in maintaining bipedal stability |
| **Beginner** | Identify the phases of a walking gait cycle (single support, double support, swing) |
| **Intermediate** | Implement a Linear Inverted Pendulum Model (LIPM) for CoM trajectory planning |
| **Intermediate** | Configure gait parameters (step length, step height, timing) for different walking scenarios |
| **Intermediate** | Implement reactive balance strategies (ankle, hip, stepping) based on stability margins |
| **Advanced** | Optimize preview control gains for smooth ZMP tracking across varying terrain |
| **Advanced** | Architect a complete locomotion pipeline integrating gait generation, balance control, and trajectory execution |

## Key Concepts

| Term | Definition |
|------|------------|
| **Zero Moment Point (ZMP)** | The point on the ground where the sum of all moments due to gravity and inertia equals zero; must remain within the support polygon for static stability |
| **Center of Mass (CoM)** | The average position of all mass in the robot, weighted by mass; its trajectory is controlled to maintain balance |
| **Support Polygon** | The convex hull of all ground contact points; defines the region where ZMP must remain for stability |
| **Linear Inverted Pendulum Model (LIPM)** | A simplified dynamics model treating the robot as a point mass on a massless leg, enabling analytical trajectory planning |
| **Gait Cycle** | One complete sequence of leg movements, consisting of stance phase (foot on ground) and swing phase (foot in air) for each leg |
| **Preview Control** | A control strategy that uses future reference trajectory information to compute optimal current control inputs |
| **Ankle Strategy** | A balance recovery method using ankle torques to shift CoM, effective for small perturbations |
| **Hip Strategy** | A balance recovery method using hip motion to counteract larger disturbances when ankle strategy is insufficient |

:::danger Latency Trap Warning
**Balance control loops MUST run at 500-1000 Hz locally.** A falling robot cannot wait for cloud-based computation:
- Run ZMP calculation and balance control on Jetson at 1kHz
- Pre-deploy trained locomotion policies (no network inference during walking)
- Use direct IMU and force sensor connections (no WiFi in the loop)
:::

# Bipedal Locomotion Fundamentals

Bipedal locomotion is one of the most challenging problems in humanoid robotics, requiring the coordination of many degrees of freedom while maintaining balance. This section covers the fundamentals of bipedal walking, including gait mechanics, balance control, and trajectory generation.

For humanoid robots, bipedal locomotion enables navigation in human-designed environments with stairs, narrow passages, and varying terrain.

## Walking Dynamics

### Center of Mass and Zero Moment Point

The Zero Moment Point (ZMP) is fundamental to stable bipedal walking. It's the point on the ground where the net moment of all forces equals zero.

```python
# Bipedal locomotion dynamics
import numpy as np
from typing import Tuple, List, Dict, Optional
from dataclasses import dataclass
from enum import Enum

class GaitType(Enum):
    """Types of bipedal gaits."""
    WALK = 'walk'
    RUN = 'run'
    STAIR_CLIMB = 'stair_climb'
    TERRAIN = 'terrain'
    QUICK_TURN = 'quick_turn'


@dataclass
class WalkingConfig:
    """Configuration for walking controller."""
    # Walking parameters
    step_length: float = 0.25  # meters
    step_height: float = 0.08  # meters
    step_duration: float = 0.4  # seconds
    double_support_ratio: float = 0.2  # fraction of step in double support

    # Velocity limits
    max_forward_vel: float = 0.5  # m/s
    max_lateral_vel: float = 0.3  # m/s
    max_turn_rate: float = 0.5  # rad/s

    # Balance margins
    zmp_margin: float = 0.02  # meters from support polygon edge
    com_height: float = 0.85  # meters (approximate)

    # Force limits
    max_fz: float = 200.0  # Maximum vertical force per foot
    max_fxy: float = 100.0  # Maximum horizontal force per foot


class BipedalDynamics:
    """
    Bipedal robot dynamics for walking.
    Implements simplified linear inverted pendulum model.
    """

    def __init__(self, config: WalkingConfig = None):
        """
        Initialize dynamics model.

        Args:
            config: Walking configuration
        """
        self.config = config or WalkingConfig()

        # Robot parameters (typical humanoid)
        self.mass = 50.0  # kg
        self.inertia = np.diag([2.0, 2.0, 0.5])  # kg*m^2

        # CoM position (simplified)
        self.com_height = config.com_height if config else 0.85

    def compute_com_trajectory(self, footsteps: List[Dict],
                                time: float) -> Tuple[float, float, float]:
        """
        Compute CoM trajectory from footstep plan.

        Args:
            footsteps: List of footstep positions
            time: Current time

        Returns:
            (x, y, z) CoM position
        """
        if not footsteps:
            return (0, 0, self.com_height)

        # Find current phase
        step_time = self.config.step_duration
        phase = (time % step_time) / step_time

        # Current step index
        step_idx = int(time / step_time) % len(footsteps)
        next_step_idx = (step_idx + 1) % len(footsteps)

        current_step = footsteps[step_idx]
        next_step = footsteps[next_step_idx]

        # Linear interpolation for CoM
        t = min(phase, 1.0)

        # CoM follows midpoint between feet with vertical motion
        x = current_step['position'][0] * (1 - t) + next_step['position'][0] * t
        y = current_step['position'][1] * (1 - t) + next_step['position'][1] * t

        # Vertical oscillation
        z = self.com_height + self.config.step_height * np.sin(np.pi * phase)

        return (x, y, z)

    def compute_zmp(self, com_pos: Tuple[float, float, float],
                    com_acc: Tuple[float, float, float],
                    com_vel: Tuple[float, float, float] = (0, 0, 0)) -> Tuple[float, float]:
        """
        Compute Zero Moment Point using linear inverted pendulum.

        For LIPM: x_zmp = x_com - (z_com/g) * x_ddot_com
        Similarly for y.

        Args:
            com_pos: Center of mass position
            com_acc: Center of mass acceleration
            com_vel: Center of mass velocity

        Returns:
            (x_zmp, y_zmp) ZMP position
        """
        g = 9.81  # gravity
        z = com_pos[2]

        # Linear inverted pendulum equation
        x_zmp = com_pos[0] - (z / g) * com_acc[0]
        y_zmp = com_pos[1] - (z / g) * com_acc[1]

        return (x_zmp, y_zmp)

    def compute_foot_trajectory(self, start_pos: Tuple[float, float, float],
                                 end_pos: Tuple[float, float, float],
                                 phase: float) -> Tuple[float, float, float]:
        """
        Compute foot trajectory during swing phase.

        Uses cycloid trajectory for smooth foot motion.

        Args:
            start_pos: Starting foot position
            end_pos: Ending foot position
            phase: Phase in [0, 1] (0=lift, 1=land)

        Returns:
            Foot position at given phase
        """
        # Horizontal motion: linear interpolation
        x = start_pos[0] + (end_pos[0] - start_pos[0]) * phase
        y = start_pos[1] + (end_pos[1] - start_pos[1]) * phase

        # Vertical motion: cycloid
        if phase < 0.5:
            # Swing phase
            swing_height = self.config.step_height
            normalized_phase = phase * 2  # 0 to 1 in swing

            # Cycloid: 2 * h * sin(pi * normalized_phase)
            z = start_pos[2] + swing_height * 2 * np.sin(np.pi * normalized_phase) * (1 - normalized_phase)
        else:
            # Lowering phase
            z = start_pos[2]  # Assume ground level for simplicity

        return (x, y, z)

    def check_balance(self, zmp: Tuple[float, float],
                      support_polygon: List[Tuple[float, float]]) -> Tuple[bool, float]:
        """
        Check if ZMP is within support polygon.

        Args:
            zmp: Zero Moment Point position
            support_polygon: List of support polygon vertices

        Returns:
            (is_stable, margin) - stability status and margin to edge
        """
        if len(support_polygon) < 3:
            return False, 0.0

        # Check if ZMP is inside polygon
        margin = self._compute_zmp_margin(zmp, support_polygon)

        # Check if margin meets requirement
        is_stable = margin >= self.config.zmp_margin

        return is_stable, margin

    def _compute_zmp_margin(self, zmp: Tuple[float, float],
                            polygon: List[Tuple[float, float]]) -> float:
        """Compute minimum distance from ZMP to support polygon edge."""
        min_dist = float('inf')

        n = len(polygon)
        for i in range(n):
            p1 = np.array(polygon[i])
            p2 = np.array(polygon[(i + 1) % n])

            # Distance from point to line segment
            edge = p2 - p1
            zmp_pt = np.array(zmp)

            t = np.dot(zmp_pt - p1, edge) / np.dot(edge, edge)
            t = np.clip(t, 0, 1)

            closest = p1 + t * edge
            dist = np.linalg.norm(zmp_pt - closest)
            min_dist = min(min_dist, dist)

        return min_dist
```

## Gait Generation

### Pattern Generation for Walking

```python
# Gait pattern generation
import numpy as np
from typing import Tuple, List, Dict
from dataclasses import dataclass
import math

@dataclass
class Footstep:
    """Single footstep with position and timing."""
    position: Tuple[float, float, float]  # x, y, z
    orientation: float  # yaw angle
    step_time: float  # When this step starts
    foot: str  # 'left' or 'right'
    is_swing: bool = True  # Whether foot is swinging


class GaitGenerator:
    """
    Generate gait patterns for bipedal walking.
    """

    def __init__(self, config: WalkingConfig = None):
        """Initialize gait generator."""
        self.config = config or WalkingConfig()

        # Initial foot positions
        self.left_foot_start = (-0.1, 0.15, 0)
        self.right_foot_start = (-0.1, -0.15, 0)

        # Timing parameters
        self.single_support_time = self.config.step_duration * (1 - self.config.double_support_ratio)
        self.double_support_time = self.config.step_duration * self.config.double_support_ratio

    def generate_straight_walk(self, num_steps: int,
                                direction: str = 'forward') -> List[Footstep]:
        """
        Generate straight walking gait.

        Args:
            num_steps: Number of steps to generate
            direction: 'forward', 'backward', 'left', 'right'

        Returns:
            List of footstep commands
        """
        footsteps = []
        step_length = self.config.step_length

        # Direction vectors
        direction_map = {
            'forward': (step_length, 0),
            'backward': (-step_length, 0),
            'left': (0, step_length),
            'right': (0, -step_length),
        }

        dx, dy = direction_map.get(direction, (step_length, 0))

        # Current positions
        left_x, left_y = self.left_foot_start[0], self.left_foot_start[1]
        right_x, right_y = self.right_foot_start[0], self.right_foot_start[1]

        time = 0
        current_foot = 'left'  # Start with left foot

        for i in range(num_steps):
            if current_foot == 'left':
                # Left foot step
                new_x = right_x + dx
                new_y = right_y + dy

                footstep = Footstep(
                    position=(new_x, new_y, 0),
                    orientation=0,
                    step_time=time,
                    foot='left',
                    is_swing=True
                )
                footsteps.append(footstep)

                left_x, left_y = new_x, new_y
                current_foot = 'right'
            else:
                # Right foot step
                new_x = left_x + dx
                new_y = left_y + dy

                footstep = Footstep(
                    position=(new_x, new_y, 0),
                    orientation=0,
                    step_time=time,
                    foot='right',
                    is_swing=True
                )
                footsteps.append(footstep)

                right_x, right_y = new_x, new_y
                current_foot = 'left'

            time += self.config.step_duration

        return footsteps

    def generate_stair_climb(self, num_stairs: int,
                             stair_height: float = 0.15,
                             stair_depth: float = 0.30) -> List[Footstep]:
        """
        Generate stair climbing gait.

        Args:
            num_stairs: Number of stairs
            stair_height: Height of each stair
            stair_depth: Depth of each stair

        Returns:
            List of footstep commands
        """
        footsteps = []
        time = 0
        current_foot = 'left'

        for stair in range(num_stairs):
            target_x = stair * stair_depth
            target_z = stair * stair_height

            if current_foot == 'left':
                footstep = Footstep(
                    position=(target_x, 0.15, target_z),
                    orientation=0,
                    step_time=time,
                    foot='left',
                    is_swing=True
                )
                current_foot = 'right'
            else:
                footstep = Footstep(
                    position=(target_x, -0.15, target_z),
                    orientation=0,
                    step_time=time,
                    foot='right',
                    is_swing=True
                )
                current_foot = 'left'

            footsteps.append(footstep)
            time += self.config.step_duration

        return footsteps

    def generate_turn_in_place(self, angle: float) -> List[Footstep]:
        """
        Generate turning in place gait.

        Args:
            angle: Total turn angle in radians

        Returns:
            List of footstep commands
        """
        footsteps = []

        # Alternating steps with rotation
        num_steps = int(abs(angle) / (np.pi / 8)) + 1  # ~22.5 degree steps
        angle_per_step = angle / num_steps

        left_x, left_y = self.left_foot_start[0], self.left_foot_start[1]
        right_x, right_y = self.right_foot_start[0], self.right_foot_start[1]

        time = 0
        current_foot = 'left'

        for i in range(num_steps):
            # Small step while rotating
            step_x = 0.05 if current_foot == 'left' else 0.05
            current_angle = (i + 0.5) * angle_per_step

            if current_foot == 'left':
                new_x = left_x + step_x
                new_y = left_y

                footstep = Footstep(
                    position=(new_x, new_y, 0),
                    orientation=current_angle,
                    step_time=time,
                    foot='left',
                    is_swing=True
                )
                left_x = new_x
                current_foot = 'right'
            else:
                new_x = right_x + step_x
                new_y = right_y

                footstep = Footstep(
                    position=(new_x, new_y, 0),
                    orientation=current_angle,
                    step_time=time,
                    foot='right',
                    is_swing=True
                )
                right_x = new_x
                current_foot = 'left'

            footsteps.append(footstep)
            time += self.config.step_duration

        return footsteps

    def compute_timing(self, velocity: Tuple[float, float, float]) -> Dict:
        """
        Compute timing parameters for given velocity.

        Args:
            velocity: (vx, vy, omega) desired velocity

        Returns:
            Dictionary of timing parameters
        """
        vx, vy, omega = velocity

        # Adjust step duration based on velocity
        speed = np.sqrt(vx**2 + vy**2)

        if speed > 0:
            base_step = self.config.step_length / speed
            step_duration = min(base_step, self.config.step_duration * 2)
        else:
            step_duration = self.config.step_duration

        # Double support ratio depends on speed
        if speed < 0.1:
            double_support = 0.3
        elif speed > 0.3:
            double_support = 0.15
        else:
            double_support = self.config.double_support_ratio

        return {
            'step_duration': step_duration,
            'single_support_time': step_duration * (1 - double_support),
            'double_support_time': step_duration * double_support,
        }


class PreviewController:
    """
    Preview controller for ZMP-based walking.
    Uses future reference to smooth CoM trajectory.
    """

    def __init__(self, config: WalkingConfig = None):
        """Initialize preview controller."""
        self.config = config or WalkingConfig()

        # Preview horizon (number of preview steps)
        self.preview_horizon = 30  # steps
        self.dt = 0.01  # seconds

        # LIPM parameters
        self.g = 9.81
        self.com_height = config.com_height if config else 0.85
        self.c = self.g / self.com_height  # Characteristic frequency squared

        # Gain matrices
        self._compute_gains()

    def _compute_gains(self):
        """Compute LQR gains for preview control."""
        # Discrete-time dynamics for CoM
        # x_{k+1} = A * x_k + B * x_zmp_k
        dt = self.dt
        c = self.c

        self.A = np.array([
            [1, dt, 0],
            [0, 1, -dt * c],
            [0, 0, 1]
        ])

        self.B = np.array([0, dt * c, 0])

        # Optimal gains (precomputed for LIPM)
        self.K = np.array([1.0, 1.5, 0.5])  # Simple gains

    def compute_control(self, zmp_ref: np.ndarray,
                        com_state: np.ndarray) -> float:
        """
        Compute ZMP command from reference and current state.

        Args:
            zmp_ref: Reference ZMP trajectory
            com_state: Current CoM state [x, x_dot, x_ddot] or similar

        Returns:
            Optimal ZMP to apply
        """
        if len(zmp_ref) < self.preview_horizon:
            zmp_ref = np.pad(zmp_ref, (0, self.preview_horizon - len(zmp_ref)))

        # Preview control
        u = 0
        for i in range(self.preview_horizon):
            zmp_error = zmp_ref[i] - com_state[0]
            u += self.K[0] * zmp_error

        return u
```

## Balance Control

### Reactive Balance Controller

```python
# Balance control for bipedal robots
import numpy as np
from typing import Tuple, List, Dict
from dataclasses import dataclass

@dataclass
class BalanceConfig:
    """Balance controller configuration."""
    # Control gains
    kp_com: float = 100.0  # CoM position gain
    kd_com: float = 20.0   # CoM velocity gain
    kp_angular: float = 50.0  # Angular position gain
    kd_angular: float = 10.0  # Angular velocity gain

    # Disturbance rejection
    ankle_strategy_gain: float = 0.5  # Fraction of disturbance absorbed by ankles
    hip_strategy_gain: float = 0.3    # Fraction absorbed by hip sway
    step_strategy_threshold: float = 0.1  # ZMP margin for ankle strategy

    # Limits
    max_ankle_torque: float = 50.0  # Nm
    max_hip_torque: float = 100.0   # Nm
    max_ankle_angle: float = 0.3    # radians
    max_hip_angle: float = 1.0      # radians


class BalanceController:
    """
    Reactive balance controller for humanoid robots.
    Implements ankle, hip, and step strategies.
    """

    def __init__(self, config: BalanceConfig = None):
        """Initialize balance controller."""
        self.config = config or BalanceConfig()

        # State
        self.com_position = np.zeros(3)
        self.com_velocity = np.zeros(3)
        self.body_orientation = np.zeros(3)  # roll, pitch, yaw
        self.angular_velocity = np.zeros(3)

    def compute_joint_torques(self, zmp_error: np.ndarray,
                               support_polygon: List[Tuple[float, float, float]]) -> Dict[str, float]:
        """
        Compute joint torques for balance.

        Args:
            zmp_error: Error from reference ZMP
            support_polygon: Current support polygon vertices

        Returns:
            Dictionary of joint torques
        """
        torques = {}

        # Check which strategy to use
        margin = self._compute_stability_margin(zmp_error, support_polygon)

        if margin > self.config.step_strategy_threshold:
            # Use ankle strategy
            torques = self._ankle_strategy(zmp_error)
        elif margin > 0:
            # Use combined ankle + hip strategy
            torques = self._combined_strategy(zmp_error)
        else:
            # Step required - maximum hip strategy
            torques = self._hip_strategy(zmp_error)

        return torques

    def _ankle_strategy(self, zmp_error: np.ndarray) -> Dict[str, float]:
        """Ankle strategy - tilt body to shift CoM."""
        # CoM acceleration to correct ZMP
        com_correction = self.config.kp_com * zmp_error

        # Apply ankle torque
        ankle_torque = self.config.ankle_strategy_gain * com_correction

        # Limit torque
        ankle_torque = np.clip(ankle_torque, -self.config.max_ankle_torque,
                               self.config.max_ankle_torque)

        return {
            'left_ankle_roll': float(ankle_torque[0]),
            'left_ankle_pitch': float(ankle_torque[1]),
            'right_ankle_roll': float(ankle_torque[0]),
            'right_ankle_pitch': float(ankle_torque[1]),
        }

    def _hip_strategy(self, zmp_error: np.ndarray) -> Dict[str, float]:
        """Hip strategy - swing arms and shift hip."""
        # Split error between ankle and hip
        ankle_torque = self.config.ankle_strategy_gain * zmp_error * 0.5
        hip_torque = self.config.hip_strategy_gain * zmp_error * 0.5

        # Apply to hip joints
        return {
            'left_ankle_roll': float(np.clip(ankle_torque[0], -self.config.max_ankle_torque, self.config.max_ankle_torque)),
            'left_ankle_pitch': float(np.clip(ankle_torque[1], -self.config.max_ankle_torque, self.config.max_ankle_torque)),
            'right_ankle_roll': float(np.clip(ankle_torque[0], -self.config.max_ankle_torque, self.config.max_ankle_torque)),
            'right_ankle_pitch': float(np.clip(ankle_torque[1], -self.config.max_ankle_torque, self.config.max_ankle_torque)),
            'left_hip_roll': float(np.clip(hip_torque[0], -self.config.max_hip_torque, self.config.max_hip_torque)),
            'left_hip_pitch': float(np.clip(hip_torque[1], -self.config.max_hip_torque, self.config.max_hip_torque)),
            'right_hip_roll': float(np.clip(hip_torque[0], -self.config.max_hip_torque, self.config.max_hip_torque)),
            'right_hip_pitch': float(np.clip(hip_torque[1], -self.config.max_hip_torque, self.config.max_hip_torque)),
        }

    def _combined_strategy(self, zmp_error: np.ndarray) -> Dict[str, float]:
        """Combined ankle and hip strategy."""
        ankle_torque = self.config.ankle_strategy_gain * zmp_error * 0.7
        hip_torque = self.config.hip_strategy_gain * zmp_error * 0.3

        return {
            'left_ankle_roll': float(np.clip(ankle_torque[0], -self.config.max_ankle_torque, self.config.max_ankle_torque)),
            'left_ankle_pitch': float(np.clip(ankle_torque[1], -self.config.max_ankle_torque, self.config.max_ankle_torque)),
            'right_ankle_roll': float(np.clip(ankle_torque[0], -self.config.max_ankle_torque, self.config.max_ankle_torque)),
            'right_ankle_pitch': float(np.clip(ankle_torque[1], -self.config.max_ankle_torque, self.config.max_ankle_torque)),
            'left_hip_roll': float(np.clip(hip_torque[0], -self.config.max_hip_torque, self.config.max_hip_torque)),
            'left_hip_pitch': float(np.clip(hip_torque[1], -self.config.max_hip_torque, self.config.max_hip_torque)),
            'right_hip_roll': float(np.clip(hip_torque[0], -self.config.max_hip_torque, self.config.max_hip_torque)),
            'right_hip_pitch': float(np.clip(hip_torque[1], -self.config.max_hip_torque, self.config.max_hip_torque)),
        }

    def _compute_stability_margin(self, zmp_error: np.ndarray,
                                   support_polygon: List[Tuple]) -> float:
        """Compute stability margin from ZMP to support edge."""
        # Simplified margin computation
        margin = 0.1 - np.linalg.norm(zmp_error[:2])
        return max(0, margin)

    def check_step_required(self, zmp_error: np.ndarray,
                            support_polygon: List[Tuple]) -> bool:
        """Check if step strategy is required."""
        margin = self._compute_stability_margin(zmp_error, support_polygon)
        return margin <= 0
```

## Connection to Capstone

Bipedal locomotion fundamentals are essential to the **Navigate** stage of the Voice-to-Plan-to-Navigate-to-Vision-to-Manipulate pipeline in your capstone project:

| Pipeline Stage | How This Section Contributes |
|----------------|------------------------------|
| **Voice** | Voice commands like "walk to the kitchen" or "climb the stairs" require the robot to understand locomotion goals |
| **Plan** | High-level navigation plans decompose into sequences of footsteps using the `GaitGenerator` patterns covered here |
| **Navigate** | The `BipedalDynamics` and `BalanceController` classes directly implement the Navigate stage, converting waypoints into stable walking motions |
| **Vision** | Visual feedback informs terrain assessment, which affects gait selection (flat walk vs. stair climb vs. terrain adaptation) |
| **Manipulate** | Stable bipedal stance is a prerequisite for manipulation - the `BalanceController` maintains stability while arms perform tasks |

**Capstone Integration Points:**

1. **Footstep Planning** - The `generate_straight_walk()` and `generate_stair_climb()` methods provide the footstep sequences that your navigation planner will invoke
2. **Real-time Balance** - The reactive balance controller ensures stability during locomotion and while transitioning to manipulation tasks
3. **Gait Adaptation** - The `GaitType` enum and configurable parameters allow your system to adapt walking behavior based on voice commands and environmental perception

When implementing your capstone, you will extend these fundamentals with reinforcement learning policies (next section) to achieve robust locomotion across diverse real-world scenarios.

## Next Steps

With Bipedal Locomotion Fundamentals covered, you can now understand the dynamics of walking. The next section explores Isaac Gym Reinforcement Learning for training locomotion policies.
