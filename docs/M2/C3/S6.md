---
id: m2-c3-s6
title: Domain Randomization Techniques
sidebar_position: 6
keywords: ['domain-randomization', 'sim2real', 'generalization', 'robustness', 'augmentation']
---

# Domain Randomization Techniques

## Prerequisites

Before starting this section, you should:
- Understand sim-to-real validation metrics from M2-C3-S5
- Be familiar with data augmentation techniques
- Know simulation parameter configuration
- Have understanding of generalization in machine learning

## Learning Objectives

| Level | Objective |
|-------|-----------|
| **[Beginner]** | Explain how domain randomization differs from domain adaptation |
| **[Beginner]** | Identify the types of randomization (visual, physical, dynamical) |
| **[Intermediate]** | Implement visual domain randomization for perception models |
| **[Intermediate]** | Configure physical parameter randomization for control policies |
| **[Advanced]** | Architect automatic domain randomization with learned distributions |
| **[Advanced]** | Design randomization schedules that maximize transfer performance |

## Key Concepts

| Term | Definition |
|------|------------|
| **Domain Randomization** | Randomizing simulation parameters to create diverse training distributions |
| **Visual Randomization** | Varying textures, colors, lighting, and backgrounds in simulation |
| **Physical Randomization** | Varying mass, friction, damping, and other physics parameters |
| **Dynamical Randomization** | Varying actuator delays, noise levels, and control gains |
| **Randomization Range** | The bounds within which parameters are varied |
| **Coverage** | Ensuring randomization encompasses real-world variation |

## Overview

**Domain randomization** exposes models to a wide variety of randomized simulation environments during training, making them robust to domain variations and better able to generalize to real-world data. Unlike domain adaptation which aligns source and target distributions, domain randomization intentionally creates a diverse source distribution that encompasses the target domain, eliminating the need for real-world training data.

**What You'll Build**: Complete domain randomization framework with visual, physical, and dynamical randomization for sim-to-real transfer in humanoid robotics applications.

## Implementation

### Step 1: Visual Domain Randomization

```python
#!/usr/bin/env python3
"""
Visual Domain Randomization
Randomize textures, colors, lighting, and backgrounds
"""

import numpy as np
import cv2
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
import random


@dataclass
class VisualRandomizationConfig:
    """Configuration for visual domain randomization"""
    # Texture randomization
    texture_folders: List[str] = None
    texture_probability: float = 0.5

    # Color randomization
    hue_range: float = 0.1
    saturation_range: float = 0.3
    value_range: float = 0.3

    # Lighting randomization
    light_direction_range: float = 0.5
    light_intensity_range: float = 0.4
    ambient_intensity_range: float = 0.3

    # Background randomization
    background_folders: List[str] = None
    background_probability: float = 0.5

    # Camera randomization
    intrinsics_noise_std: float = 0.02
    extrinsics_noise_std: float = 0.01


class VisualRandomizer:
    """Apply visual domain randomization to images"""

    def __init__(self, config: VisualRandomizationConfig = None):
        self.config = config or VisualRandomizationConfig()

        # Load textures if available
        self.textures = self._load_textures(self.config.texture_folders or [])

        # Load backgrounds if available
        self.backgrounds = self._load_backgrounds(
            self.config.background_folders or []
        )

    def _load_textures(self, folders: List[str]) -> List[np.ndarray]:
        """Load texture images"""
        textures = []
        for folder in folders:
            folder_path = Path(folder)
            if folder_path.exists():
                for img_path in folder_path.glob("*.jpg") + folder_path.glob("*.png"):
                    img = cv2.imread(str(img_path))
                    if img is not None:
                        textures.append(img)
        return textures

    def _load_backgrounds(self, folders: List[str]) -> List[np.ndarray]:
        """Load background images"""
        backgrounds = []
        for folder in folders:
            folder_path = Path(folder)
            if folder_path.exists():
                for img_path in folder_path.glob("*.jpg") + folder_path.glob("*.png"):
                    img = cv2.imread(str(img_path))
                    if img is not None:
                        backgrounds.append(img)
        return backgrounds

    def randomize_colors(self, image: np.ndarray) -> np.ndarray:
        """Apply color randomization (hue, saturation, value)"""
        hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

        # Hue shift (-0.1 to 0.1 of full range)
        hue_shift = random.uniform(-self.config.hue_range, self.config.hue_range) * 180
        hsv[:, :, 0] = (hsv[:, :, 0] + hue_shift) % 180

        # Saturation scale
        sat_scale = 1 + random.uniform(-self.config.saturation_range,
                                        self.config.saturation_range)
        hsv[:, :, 1] = np.clip(hsv[:, :, 1] * sat_scale, 0, 255)

        # Value scale
        val_scale = 1 + random.uniform(-self.config.value_range,
                                        self.config.value_range)
        hsv[:, :, 2] = np.clip(hsv[:, :, 2] * val_scale, 0, 255)

        return cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)

    def randomize_contrast(self, image: np.ndarray) -> np.ndarray:
        """Apply contrast randomization"""
        # Random contrast factor
        contrast = random.uniform(0.8, 1.2)
        brightness = random.uniform(-20, 20)

        # Convert to float
        img_float = image.astype(np.float32)

        # Apply contrast and brightness
        result = img_float * contrast + brightness

        # Clip and convert back
        return np.clip(result, 0, 255).astype(np.uint8)

    def randomize_texture_overlay(self, image: np.ndarray) -> np.ndarray:
        """Overlay random texture pattern"""
        if not self.textures or random.random() > self.config.texture_probability:
            return image

        # Choose random texture
        texture = random.choice(self.textures)

        # Resize texture to image size
        texture = cv2.resize(texture, (image.shape[1], image.shape[0]))

        # Random blend
        alpha = random.uniform(0.05, 0.2)
        result = cv2.addWeighted(image, 1 - alpha, texture, alpha, 0)

        return result

    def randomize_background(
        self,
        image: np.ndarray,
        segmentation: np.ndarray = None
    ) -> np.ndarray:
        """Replace or blend background"""
        if not self.backgrounds or random.random() > self.config.background_probability:
            return image

        # Choose random background
        bg = random.choice(self.backgrounds)
        bg = cv2.resize(bg, (image.shape[1], image.shape[0]))

        if segmentation is not None:
            # Keep foreground from segmentation mask
            mask = segmentation > 0
            result = image.copy()
            result[~mask] = bg[~mask]
            return result
        else:
            # Random blend
            alpha = random.uniform(0.1, 0.4)
            return cv2.addWeighted(bg, alpha, image, 1 - alpha, 0)

    def add_camera_noise(self, image: np.ndarray) -> np.ndarray:
        """Add camera-specific noise"""
        # Gaussian noise
        noise_std = random.uniform(3, 10)
        noise = np.random.normal(0, noise_std, image.shape).astype(np.int16)
        noisy = np.clip(image.astype(np.int16) + noise, 0, 255).astype(np.uint8)

        # Motion blur
        if random.random() < 0.2:
            kernel_size = random.choice([3, 5, 7])
            kernel = np.zeros((kernel_size, kernel_size))
            kernel[kernel_size // 2, :] = 1
            kernel = kernel / kernel_size
            noisy = cv2.filter2D(noisy, -1, kernel)

        # Dead pixels
        if random.random() < 0.1:
            dead_mask = np.random.random(image.shape[:2]) < 0.001
            noisy[dead_mask] = 0 if random.random() < 0.5 else 255

        return noisy

    def apply_all(self, image: np.ndarray, segmentation: np.ndarray = None) -> np.ndarray:
        """Apply all visual randomization"""
        # Color randomization
        image = self.randomize_colors(image)

        # Contrast randomization
        image = self.randomize_contrast(image)

        # Texture overlay
        image = self.randomize_texture_overlay(image)

        # Background randomization
        image = self.randomize_background(image, segmentation)

        # Camera noise
        image = self.add_camera_noise(image)

        return image


class ProceduralTextureGenerator:
    """Generate procedural textures for randomization"""

    @staticmethod
    def generate_checkerboard(
        size: Tuple[int, int] = (256, 256),
        cell_size: int = 16,
        colors: Tuple[Tuple[int, int, int], Tuple[int, int, int]] = None
    ) -> np.ndarray:
        """Generate checkerboard texture"""
        if colors is None:
            colors = (
                (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)),
                (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
            )

        texture = np.zeros((*size, 3), dtype=np.uint8)

        for y in range(0, size[0], cell_size):
            for x in range(0, size[1], cell_size):
                if ((x + y) // cell_size) % 2 == 0:
                    color = colors[0]
                else:
                    color = colors[1]
                texture[y:y+cell_size, x:x+cell_size] = color

        return texture

    @staticmethod
    def generate_stripes(
        size: Tuple[int, int] = (256, 256),
        thickness: int = 8,
        angle: float = 0.0,
        colors: Tuple[Tuple[int, int, int], Tuple[int, int, int]] = None
    ) -> np.ndarray:
        """Generate striped texture"""
        if colors is None:
            colors = (
                (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)),
                (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
            )

        texture = np.zeros((*size, 3), dtype=np.uint8)

        # Create stripe pattern
        stripe = np.zeros((size[1], 1), dtype=np.uint8)
        stripe[:thickness] = 1
        stripe[thickness:2*thickness] = 0

        # Apply angle rotation
        M = cv2.getRotationMatrix2D((size[1]//2, size[0]//2), np.degrees(angle), 1.0)

        # Create full texture
        for y in range(size[0]):
            if (y // thickness) % 2 == 0:
                texture[y, :, :] = colors[0]
            else:
                texture[y, :, :] = colors[1]

        return texture

    @staticmethod
    def generate_noise_texture(
        size: Tuple[int, int] = (256, 256),
        noise_type: str = 'gaussian',
        std: float = 20.0
    ) -> np.ndarray:
        """Generate noise texture"""
        if noise_type == 'gaussian':
            noise = np.random.normal(128, std, (*size, 3))
        elif noise_type == 'uniform':
            noise = np.random.uniform(0, 255, (*size, 3))
        else:
            noise = np.random.rand(*size, 3) * 255

        return np.clip(noise, 0, 255).astype(np.uint8)

    @staticmethod
    def generate_gradient_texture(
        size: Tuple[int, int] = (256, 256),
        direction: str = 'diagonal',
        color1: Tuple[int, int, int] = (0, 0, 0),
        color2: Tuple[int, int, int] = (255, 255, 255)
    ) -> np.ndarray:
        """Generate gradient texture"""
        texture = np.zeros((*size, 3), dtype=np.uint8)

        if direction == 'horizontal':
            for x in range(size[1]):
                t = x / size[1]
                texture[:, x, :] = [
                    int(color1[i] * (1 - t) + color2[i] * t) for i in range(3)
                ]
        elif direction == 'vertical':
            for y in range(size[0]):
                t = y / size[0]
                texture[y, :, :] = [
                    int(color1[i] * (1 - t) + color2[i] * t) for i in range(3)
                ]
        else:  # diagonal
            for y in range(size[0]):
                for x in range(size[1]):
                    t = (x + y) / (size[0] + size[1])
                    texture[y, x, :] = [
                        int(color1[i] * (1 - t) + color2[i] * t) for i in range(3)
                    ]

        return texture
```

### Step 2: Physical Domain Randomization

```python
#!/usr/bin/env python3
"""
Physical Domain Randomization
Randomize physics properties for robust control learning
"""

import numpy as np
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
import random


@dataclass
class PhysicsRandomizationConfig:
    """Configuration for physics domain randomization"""
    # Mass randomization
    mass_range: Tuple[float, float] = (0.8, 1.2)  # 80% to 120% of nominal

    # Friction randomization
    friction_range: Tuple[float, float] = (0.3, 0.8)

    # Damping randomization
    linear_damping_range: Tuple[float, float] = (0.1, 1.0)
    angular_damping_range: Tuple[float, float] = (0.1, 1.0)

    # Joint property randomization
    joint_friction_range: Tuple[float, float] = (0.0, 0.5)
    joint_damping_range: Tuple[float, float] = (0.1, 0.5)

    # Delay randomization
    action_delay_range: Tuple[float, float] = (0.0, 0.05)  # seconds


class PhysicsRandomizer:
    """Randomize physics properties"""

    def __init__(self, config: PhysicsRandomizationConfig = None):
        self.config = config or PhysicsRandomizationConfig()
        self.current_params = None

    def randomize_mass(self, nominal_mass: float) -> float:
        """Randomize mass within range"""
        scale = random.uniform(*self.config.mass_range)
        return nominal_mass * scale

    def randomize_friction(self, nominal_friction: float) -> float:
        """Randomize friction coefficient"""
        return random.uniform(*self.config.friction_range)

    def randomize_damping(
        self,
        nominal_linear: float = 0.5,
        nominal_angular: float = 0.5
    ) -> Tuple[float, float]:
        """Randomize damping coefficients"""
        linear = random.uniform(*self.config.linear_damping_range)
        angular = random.uniform(*self.config.angular_damping_range)
        return linear, angular

    def randomize_joint_properties(self) -> Dict:
        """Randomize joint properties"""
        return {
            'friction': random.uniform(*self.config.joint_friction_range),
            'damping': random.uniform(*self.config.joint_damping_range),
            'max_effort': random.uniform(50, 100),
            'velocity_limit': random.uniform(2, 5),
        }

    def randomize_action_delay(self) -> float:
        """Randomize action delay"""
        return random.uniform(*self.config.action_delay_range)

    def randomize_all(self, nominal_params: Dict) -> Dict:
        """Randomize all physics properties"""
        randomized = {}

        # Mass
        if 'mass' in nominal_params:
            randomized['mass'] = self.randomize_mass(nominal_params['mass'])

        # Friction
        if 'friction' in nominal_params:
            randomized['friction'] = self.randomize_friction(nominal_params['friction'])

        # Damping
        if 'linear_damping' in nominal_params:
            linear, angular = self.randomize_damping(
                nominal_params.get('linear_damping', 0.5),
                nominal_params.get('angular_damping', 0.5)
            )
            randomized['linear_damping'] = linear
            randomized['angular_damping'] = angular

        # Joint properties
        randomized['joint'] = self.randomize_joint_properties()

        # Action delay
        randomized['action_delay'] = self.randomize_action_delay()

        self.current_params = randomized
        return randomized

    def get_sdf_modifications(self, base_sdf: str) -> str:
        """Generate SDF modifications for randomized physics"""
        if self.current_params is None:
            return base_sdf

        sdf = base_sdf

        # Apply mass modification
        if 'mass' in self.current_params:
            sdf = sdf.replace(
                '<mass>1.0</mass>',
                f"<mass>{self.current_params['mass']:.3f}</mass>"
            )

        # Apply friction modification
        if 'friction' in self.current_params:
            sdf = sdf.replace(
                '<mu>0.5</mu>',
                f"<mu>{self.current_params['friction']:.3f}</mu>"
            )

        # Apply damping modifications
        if 'linear_damping' in self.current_params:
            sdf = sdf.replace(
                '<linear_damping>0.5</linear_damping>',
                f"<linear_damping>{self.current_params['linear_damping']:.3f}</linear_damping>"
            )

        return sdf


class DelaySimulator:
    """Simulate action delays for robust control"""

    def __init__(self, max_delay: float = 0.05):
        self.max_delay = max_delay
        self.current_delay = 0.0
        self.action_buffer = []

    def set_delay(self, delay: float):
        """Set current delay"""
        self.current_delay = delay

    def randomize_delay(self):
        """Randomize delay within range"""
        self.current_delay = random.uniform(0, self.max_delay)

    def apply_delay(self, action: np.ndarray, current_time: float) -> np.ndarray:
        """Apply delay to action"""
        # Store action with timestamp
        self.action_buffer.append((current_time, action.copy()))

        # Remove old actions
        cutoff = current_time - self.current_delay
        self.action_buffer = [
            (t, a) for t, a in self.action_buffer if t >= cutoff
        ]

        # Return oldest buffered action (delayed)
        if self.action_buffer:
            return self.action_buffer[0][1].copy()

        return action

    def reset(self):
        """Reset buffer"""
        self.action_buffer = []
        self.current_delay = 0.0
```

### Step 3: Dynamics Randomization

```python
#!/usr/bin/env python3
"""
Dynamics Randomization
Randomize dynamics for robust policy learning
"""

import numpy as np
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
import random


@dataclass
class DynamicsRandomizationConfig:
    """Configuration for dynamics randomization"""
    # Joint scaling
    joint_scale_range: Tuple[float, float] = (0.9, 1.1)

    # Torque scale
    torque_scale_range: Tuple[float, float] = (0.8, 1.2)

    # Observation noise
    position_noise_std: float = 0.01
    velocity_noise_std: float = 0.1

    # Action noise
    action_noise_std: float = 0.01

    # Latency range (seconds)
    latency_range: Tuple[float, float] = (0.0, 0.02)


class DynamicsRandomizer:
    """Randomize dynamics properties"""

    def __init__(self, config: DynamicsRandomizationConfig = None):
        self.config = config or DynamicsRandomizationConfig()
        self.scales = {}
        self.noise_sources = {}

    def randomize_scales(self, num_joints: int):
        """Randomize per-joint scales"""
        self.scales = {
            'position': np.random.uniform(
                self.config.joint_scale_range[0],
                self.config.joint_scale_range[1],
                num_joints
            ),
            'velocity': np.random.uniform(
                self.config.joint_scale_range[0],
                self.config.joint_scale_range[1],
                num_joints
            ),
            'torque': np.random.uniform(
                self.config.torque_scale_range[0],
                self.config.torque_scale_range[1],
                num_joints
            ),
        }

    def apply_position_scale(self, positions: np.ndarray) -> np.ndarray:
        """Apply position scaling"""
        if 'position' not in self.scales:
            return positions
        return positions * self.scales['position']

    def apply_velocity_scale(self, velocities: np.ndarray) -> np.ndarray:
        """Apply velocity scaling"""
        if 'velocity' not in self.scales:
            return velocities
        return velocities * self.scales['velocity']

    def apply_torque_scale(self, torques: np.ndarray) -> np.ndarray:
        """Apply torque scaling"""
        if 'torque' not in self.scales:
            return torques
        return torques * self.scales['torque']

    def add_observation_noise(
        self,
        positions: np.ndarray,
        velocities: np.ndarray
    ) -> Tuple[np.ndarray, np.ndarray]:
        """Add noise to observations"""
        # Position noise
        pos_noise = np.random.normal(
            0, self.config.position_noise_std, positions.shape
        )

        # Velocity noise
        vel_noise = np.random.normal(
            0, self.config.velocity_noise_std, velocities.shape
        )

        return positions + pos_noise, velocities + vel_noise

    def add_action_noise(self, actions: np.ndarray) -> np.ndarray:
        """Add noise to actions"""
        noise = np.random.normal(0, self.config.action_noise_std, actions.shape)
        return actions + noise


class LatencyInjector:
    """Inject latency between observation and action"""

    def __init__(self, max_latency: float = 0.02):
        self.max_latency = max_latency
        self.current_latency = 0.0
        self.observation_buffer = []
        self.action_delivery_time = {}

    def set_latency(self, latency: float):
        """Set current latency"""
        self.current_latency = latency

    def randomize_latency(self):
        """Randomize latency within range"""
        self.current_latency = random.uniform(*self.latency_range)

    def inject(
        self,
        observation: np.ndarray,
        action: np.ndarray,
        timestamp: float
    ) -> np.ndarray:
        """
        Inject latency between observation and action

        Returns the action that should have been applied at (timestamp - latency)
        """
        # Store observation
        self.observation_buffer.append((timestamp, observation.copy()))

        # Find observation at (timestamp - latency)
        target_time = timestamp - self.current_latency
        delivered_action = action.copy()  # Default: current action

        for obs_time, obs in reversed(self.observation_buffer):
            if obs_time <= target_time:
                # Found observation at target time
                # In practice, would recompute action based on this observation
                delivered_action = action.copy()
                break

        # Remove old observations
        cutoff = timestamp - self.max_latency - 0.1
        self.observation_buffer = [
            (t, o) for t, o in self.observation_buffer if t >= cutoff
        ]

        return delivered_action


class EnvironmentRandomizer:
    """Comprehensive environment randomization"""

    def __init__(self):
        self.visual_randomizer = VisualRandomizer()
        self.physics_randomizer = PhysicsRandomizer()
        self.dynamics_randomizer = DynamicsRandomizer()

        # Randomization schedule
        self.randomize_every_n_steps = 10
        self.step_count = 0

    def randomize_if_needed(self, step: int = None):
        """Randomize if step count matches schedule"""
        if step is None:
            step = self.step_count

        if step % self.randomize_every_n_steps == 0:
            self.randomize_all()

        self.step_count += 1

    def randomize_all(self):
        """Randomize all components"""
        self.visual_randomizer = VisualRandomizer()
        self.physics_randomizer.randomize_all({})
        self.dynamics_randomizer.randomize_scales(10)

    def apply_to_observation(
        self,
        image: np.ndarray,
        positions: np.ndarray,
        velocities: np.ndarray
    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Apply all randomization to observation"""
        # Randomize image
        randomized_image = self.visual_randomizer.apply_all(image)

        # Add dynamics noise
        noisy_positions, noisy_velocities = self.dynamics_randomizer.add_observation_noise(
            positions, velocities
        )

        return randomized_image, noisy_positions, noisy_velocities

    def apply_to_action(self, action: np.ndarray) -> np.ndarray:
        """Apply dynamics randomization to action"""
        # Scale action
        scaled_action = self.dynamics_randomizer.apply_torque_scale(action)

        # Add noise
        noisy_action = self.dynamics_randomizer.add_action_noise(scaled_action)

        return noisy_action
```

### Step 4: Adaptive Domain Randomization

```python
#!/usr/bin/env python3
"""
Adaptive Domain Randomization
Dynamically adjust randomization based on performance
"""

import numpy as np
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass


@dataclass
class AdaptiveConfig:
    """Configuration for adaptive domain randomization"""
    # Performance thresholds
    success_threshold: float = 0.8
    failure_threshold: float = 0.5

    # Adjustment rates
    increase_rate: float = 0.1
    decrease_rate: float = 0.1

    # History window
    history_window: int = 100

    # Initial difficulty
    initial_difficulty: float = 0.5


class AdaptiveDomainRandomizer:
    """Adaptively adjust domain randomization difficulty"""

    def __init__(self, config: AdaptiveConfig = None):
        self.config = config or AdaptiveConfig()

        # Current difficulty (0 = easy, 1 = hard)
        self.difficulty = self.config.initial_difficulty

        # Performance history
        self.success_history = []

        # Base randomizers
        self.visual_randomizer = VisualRandomizer(VisualRandomizationConfig())
        self.physics_randomizer = PhysicsRandomizer(PhysicsRandomizationConfig())
        self.dynamics_randomizer = DynamicsRandomizer(DynamicsRandomizationConfig())

    def update_performance(self, success: float):
        """Update performance and adjust difficulty"""
        # Add to history
        self.success_history.append(success)

        # Keep only recent history
        if len(self.success_history) > self.config.history_window:
            self.success_history.pop(0)

        # Compute average performance
        if len(self.success_history) >= 10:
            avg_success = np.mean(self.success_history)

            # Adjust difficulty
            if avg_success > self.config.success_threshold:
                # Doing well, increase difficulty
                self.difficulty = min(1.0, self.difficulty + self.config.increase_rate)
            elif avg_success < self.config.failure_threshold:
                # Struggling, decrease difficulty
                self.difficulty = max(0.0, self.difficulty - self.config.decrease_rate)

    def get_difficulty(self) -> float:
        """Get current difficulty level"""
        return self.difficulty

    def get_randomization_config(self) -> Dict:
        """Get randomization configuration based on difficulty"""
        return {
            'visual': {
                'hue_range': 0.1 * (1 + self.difficulty),
                'saturation_range': 0.3 * (1 + self.difficulty),
                'value_range': 0.3 * (1 + self.difficulty),
                'texture_probability': 0.3 + 0.4 * self.difficulty,
                'background_probability': 0.3 + 0.4 * self.difficulty,
            },
            'physics': {
                'mass_range': (0.9 - 0.2 * self.difficulty, 1.1 + 0.2 * self.difficulty),
                'friction_range': (0.3 - 0.1 * self.difficulty, 0.8 + 0.2 * self.difficulty),
                'action_delay_range': (0.0, 0.02 + 0.05 * self.difficulty),
            },
            'dynamics': {
                'position_noise_std': 0.005 + 0.02 * self.difficulty,
                'velocity_noise_std': 0.05 + 0.1 * self.difficulty,
                'action_noise_std': 0.005 + 0.02 * self.difficulty,
            },
        }

    def create_randomizers(self) -> Tuple[VisualRandomizer, PhysicsRandomizer, DynamicsRandomizer]:
        """Create randomizers with current difficulty"""
        config = self.get_randomization_config()

        visual_config = VisualRandomizationConfig(
            hue_range=config['visual']['hue_range'],
            saturation_range=config['visual']['saturation_range'],
            value_range=config['visual']['value_range'],
            texture_probability=config['visual']['texture_probability'],
            background_probability=config['visual']['background_probability'],
        )

        physics_config = PhysicsRandomizationConfig(
            mass_range=config['physics']['mass_range'],
            friction_range=config['physics']['friction_range'],
            action_delay_range=config['physics']['action_delay_range'],
        )

        dynamics_config = DynamicsRandomizationConfig(
            position_noise_std=config['dynamics']['position_noise_std'],
            velocity_noise_std=config['dynamics']['velocity_noise_std'],
            action_noise_std=config['dynamics']['action_noise_std'],
        )

        return (
            VisualRandomizer(visual_config),
            PhysicsRandomizer(physics_config),
            DynamicsRandomizer(dynamics_config),
        )

    def get_status_report(self) -> Dict:
        """Get current status report"""
        return {
            'difficulty': self.difficulty,
            'avg_success_rate': np.mean(self.success_history) if self.success_history else 0,
            'history_length': len(self.success_history),
            'config': self.get_randomization_config(),
        }
```

## Next Steps

- **M2-C3-S7**: Module 2 Consistency Check

---

**Assessment Preparation**: Domain randomization implementation and adaptive difficulty adjustment.
