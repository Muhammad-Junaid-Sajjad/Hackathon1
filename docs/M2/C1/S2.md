---
id: m2-c1-s2
title: Physics Engines and Simulation Parameters
sidebar_position: 2
keywords: ['physics', 'ode', 'bullet', 'dart', 'timestep', 'solver', 'real-time-factor']
---

# Physics Engines and Simulation Parameters

## Overview

**Physics engines** are the computational core of simulationâ€”they solve equations of motion, handle collisions, enforce constraints, and compute forces at every timestep. Gazebo Harmonic supports three physics engines: **ODE** (Open Dynamics Engine), **Bullet**, and **DART** (Dynamic Animation and Robotics Toolkit). Each has different performance characteristics, accuracy tradeoffs, and suitability for specific tasks (manipulation vs. locomotion vs. large-scale multi-robot).

**What You'll Build**: A systematic comparison of ODE, Bullet, and DART using benchmark worlds, configuration files to tune physics parameters (timestep, solver iterations, contact constraints), and performance analysis tools to measure real-time factor and simulation stability.

## Prerequisites

Before starting this section, ensure you have:

- **Completed [M2-C1-S1](./S1.md)**: Gazebo Harmonic installed and verified
- **ROS 2 Humble workspace**: Sourced and functional (`ros2 topic list` works)
- **Basic SDF knowledge**: Understanding of XML-based world description files
- **Linux command line**: Comfortable with terminal commands and file editing
- **Python 3.10+**: For running benchmark scripts

**Hardware Requirements**:
- 8-core CPU minimum for real-time simulation
- 16GB RAM recommended
- NVIDIA GPU (optional but recommended for Bullet GPU acceleration)

## Learning Objectives

By the end of this section, you will be able to:

- **[Beginner]** Explain the role of physics engines in robotics simulation and identify the three engines available in Gazebo
- **[Beginner]** Configure basic physics parameters (timestep, gravity) in an SDF world file
- **[Intermediate]** Select the appropriate physics engine for manipulation, locomotion, or RL workloads
- **[Intermediate]** Tune solver iterations, CFM, and ERP to achieve stable contact dynamics
- **[Advanced]** Benchmark physics performance using real-time factor (RTF) analysis
- **[Advanced]** Configure GPU-accelerated physics for large-scale multi-robot simulation
- **[Expert]** Design physics configurations that balance fidelity and computational cost for production deployments

## Key Concepts

| Term | Definition | Why It Matters |
|------|------------|----------------|
| **Physics Engine** | Software that solves equations of motion, collisions, and constraints | Determines simulation accuracy and speed |
| **Timestep** | Time increment per physics calculation (e.g., 1ms) | Smaller = more accurate but slower |
| **Real-Time Factor (RTF)** | Ratio of sim time to wall-clock time | RTF &gt; 1.0 means faster than real-time |
| **Solver Iterations** | Number of constraint solver passes per timestep | More = stable contacts, slower simulation |
| **CFM (Constraint Force Mixing)** | Softness parameter for constraints | Prevents jitter in stiff contacts |
| **ERP (Error Reduction Parameter)** | Speed of constraint error correction | Higher = aggressive correction, risk of oscillation |
| **Contact Stiffness (kp)** | Spring constant for contact forces (N/m) | Determines surface "hardness" |

:::danger Latency Trap Warning
**Physics simulation must run on local hardware for real-time control.** Network-based simulation introduces 50-200ms latency that destabilizes control loops. Always:
- Run physics on the Jetson or workstation directly connected to the robot
- Never stream physics state over WiFi during real-time operation
- Train in simulation, deploy models locally
:::

## Skill-Level Pathways

:::note For Beginners
If you're new to physics simulation, focus on:
1. Understanding the **Physics Engine Comparison** table
2. Running the basic world file with default ODE settings
3. Observing RTF in the Gazebo GUI (bottom status bar)
4. Completing **Exercise 1** to verify your setup

**Skip on first read**: GPU acceleration, DART configuration, advanced solver tuning
:::

:::tip Intermediate Path
If you have ROS 2 experience and want production-ready configurations:
1. Compare ODE vs Bullet using the benchmark script
2. Learn to tune timestep and solver iterations for your robot
3. Configure contact parameters for grasping scenarios
4. Complete **Exercises 1-2**
:::

:::caution Advanced Path
For production systems and large-scale simulation:
1. Master GPU-accelerated Bullet for RL training
2. Understand failure modes and how to diagnose them
3. Design physics configs for 10+ robot fleets
4. Complete **Exercise 3** and attempt the **Architect Challenge**
:::

## Hardware Requirements

**Workstation** (from M1-C1-S1)
- Ubuntu 22.04 LTS
- NVIDIA RTX 4070 Ti (12GB VRAM) for GPU-accelerated physics (Bullet)
- ROS 2 Humble + Gazebo Harmonic (M2-C1-S1)
- 8-core CPU minimum for real-time simulation

---

## Industry Perspectives

:::info Industry Spotlight: Tesla Manufacturing
**How Tesla uses physics simulation:**
Tesla's Optimus humanoid uses custom physics engines running at 0.5ms timesteps with GPU acceleration to train manipulation policies. Their simulation infrastructure supports 10,000+ parallel environments for RL training.

**Key metrics they care about:**
- **Sim-to-real gap**: &lt;5% policy performance drop in real world
- **Training throughput**: 1M+ environment steps per hour
- **Contact fidelity**: Sub-millimeter grasp precision in simulation

**Lessons learned:**
Physics accuracy matters less than physics *consistency* for RLâ€”models can adapt to systematic errors but not random ones.
:::

:::info Industry Spotlight: Amazon Robotics
**How Amazon Robotics (Kiva) uses physics simulation:**
Fleet simulation for warehouse robots requires simulating 100+ robots simultaneously with realistic floor friction, payload dynamics, and collision avoidance. They use Bullet with reduced solver iterations for speed.

**Key metrics they care about:**
- **Fleet throughput**: Picks per hour per robot
- **Collision prediction**: False positive rate &lt;1%
- **Battery simulation**: &lt;3% error vs real depletion

**Lessons learned:**
For fleet simulation, GPU-accelerated physics pays off at 10+ robots. Below that, the CPUâ†’GPU transfer overhead dominates.
:::

:::info Industry Spotlight: Intuitive Surgical (da Vinci)
**How Intuitive Surgical uses physics simulation:**
Surgical robot simulation requires extremely high contact fidelityâ€”millimeter-scale tissue interactions with force feedback. They use DART-like custom engines with 0.2ms timesteps.

**Key metrics they care about:**
- **Force accuracy**: &lt;0.1N error in contact forces
- **Latency**: &lt;1ms physics computation for real-time teleoperation training
- **Tissue deformation**: Validated against cadaver studies

**Lessons learned:**
Medical robotics prioritizes accuracy over speedâ€”a 2x slower but more accurate simulation is preferred over fast but approximate physics.
:::

---

## Connection to Capstone

The capstone uses physics simulation for:

1. **Grasping Simulation**: Contact physics determines grasp stability (friction, normal forces)
2. **Locomotion**: Ground contact dynamics for bipedal walking (humanoid legs, balance)
3. **Object Manipulation**: Inertia tensors, joint damping affect trajectory tracking accuracy
4. **Reinforcement Learning**: Physics fidelity impacts sim-to-real transfer (reward shaping depends on accurate contact)
5. **Multi-Robot Testing**: Engine performance determines how many robots can simulate in parallel

**Physics Engine Selection**:
- **ODE**: Default, stable, good for manipulation (contact-rich grasping)
- **Bullet**: Faster, GPU-accelerated, best for large-scale RL (100+ robots)
- **DART**: Most accurate, slower, best for research (human motion, soft bodies)

## Implementation

### Physics Engine Comparison

| Feature | ODE | Bullet | DART |
|---------|-----|--------|------|
| **Solver Type** | Iterative LCP (Dantzig) | Sequential Impulse | Recursive Newton-Euler |
| **Contact Model** | Penalty-based springs | Impulse-based | Constraint-based |
| **Performance** | 1-10x real-time | 10-100x real-time (GPU) | 0.5-5x real-time |
| **Stability** | Medium (needs tuning) | High (robust to stiff contacts) | Highest (accurate integrator) |
| **Joints** | 6 DOF, hinge, slider | All standard + soft | All + ball, screw, universal |
| **Collision** | Opcode, Trimesh | Bullet native (SAT) | FCL (GJK/EPA) |
| **GPU Support** | No | Yes (CUDA) | No |
| **Use Case** | General robotics | Large-scale RL, games | Research, biomechanics |
| **ROS 2 Support** | Excellent | Good | Experimental |

**Performance Benchmark** (humanoid arm, 7 DOF):
- ODE: 5x real-time (200 Hz physics @ 1ms timestep)
- Bullet: 50x real-time (GPU, 1000 Hz physics @ 1ms timestep)
- DART: 2x real-time (500 Hz physics @ 2ms timestep)

### Step 1: Configure Physics Engine in World File

**World File**: `~/ros2_ws/src/humanoid_description/worlds/physics_test.world`

```xml
<?xml version="1.0"?>
<sdf version="1.9">
  <world name="physics_benchmark">

    <!-- Physics Engine Selection -->
    <physics name="default_physics" type="ode">  <!-- ode | bullet | dart -->

      <!-- Real-time update rate (Hz) -->
      <real_time_update_rate>1000.0</real_time_update_rate>

      <!-- Max step size (seconds) -->
      <!-- Smaller = more accurate, more CPU -->
      <!-- Typical: 0.001 (1ms) for manipulation, 0.01 (10ms) for navigation -->
      <max_step_size>0.001</max_step_size>

      <!-- Real-time factor (1.0 = real-time, >1 = faster than real-time) -->
      <real_time_factor>1.0</real_time_factor>

      <!-- ODE-specific parameters -->
      <ode>
        <solver>
          <!-- Solver type: quick (fast, less accurate) | world (accurate, slower) -->
          <type>quick</type>

          <!-- Constraint solver iterations (more = stable, slower) -->
          <!-- Typical: 20-50 for manipulation, 10-20 for locomotion -->
          <iters>50</iters>

          <!-- Successive Over-Relaxation parameter (1.0-1.3) -->
          <!-- Higher = faster convergence, risk of instability -->
          <sor>1.3</sor>

          <!-- Constraint Force Mixing (regularization) -->
          <!-- Softens constraints, prevents jitter -->
          <!-- Typical: 1e-5 to 1e-3 -->
          <cfm>0.00001</cfm>

          <!-- Error Reduction Parameter (0-1) -->
          <!-- How aggressively to correct constraint violations -->
          <!-- Typical: 0.2 (stable) to 0.8 (aggressive) -->
          <erp>0.2</erp>
        </solver>

        <constraints>
          <!-- Contact Force Mixing (contact softness) -->
          <cfm>0.0</cfm>

          <!-- Contact Error Reduction Parameter -->
          <erp>0.2</erp>

          <!-- Max contact correcting velocity -->
          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>

          <!-- Contact surface layer (penetration tolerance) -->
          <contact_surface_layer>0.001</contact_surface_layer>
        </constraints>
      </ode>

      <!-- Bullet-specific parameters -->
      <bullet>
        <solver>
          <type>sequential_impulse</type>  <!-- or mlcp_dantzig -->
          <iters>50</iters>
          <sor>1.3</sor>
        </solver>

        <constraints>
          <cfm>0.0</cfm>
          <erp>0.2</erp>
          <contact_surface_layer>0.001</contact_surface_layer>
          <split_impulse>true</split_impulse>  <!-- Stabilizes stacking -->
          <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold>
        </constraints>
      </bullet>

      <!-- DART-specific parameters -->
      <dart>
        <solver>
          <type>dantzig</type>  <!-- or pgs -->
        </solver>

        <collision_detector>fcl</collision_detector>  <!-- or bullet, ode -->
      </dart>

    </physics>

    <!-- Gravity -->
    <gravity>0 0 -9.81</gravity>

    <!-- Magnetic field (for IMU simulation) -->
    <magnetic_field>5.5645e-6 22.8758e-6 -42.3884e-6</magnetic_field>

    <!-- Atmospheric pressure (for barometer simulation) -->
    <atmosphere type="adiabatic">
      <pressure>101325</pressure>
    </atmosphere>

    <!-- Ground plane -->
    <model name="ground_plane">
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <surface>
            <friction>
              <ode>
                <mu>1.0</mu>    <!-- Coefficient of friction -->
                <mu2>1.0</mu2>
              </ode>
            </friction>
            <contact>
              <ode>
                <kp>1e7</kp>   <!-- Contact stiffness (N/m) -->
                <kd>1.0</kd>   <!-- Contact damping (NÂ·s/m) -->
              </ode>
            </contact>
          </surface>
        </collision>
        <visual name="visual">
          <geometry>
            <plane>
              <normal>0 0 1</normal>
              <size>100 100</size>
            </plane>
          </geometry>
          <material>
            <ambient>0.8 0.8 0.8 1</ambient>
            <diffuse>0.8 0.8 0.8 1</diffuse>
          </material>
        </visual>
      </link>
    </model>

    <!-- Lighting -->
    <light type="directional" name="sun">
      <cast_shadows>true</cast_shadows>
      <pose>0 0 10 0 0 0</pose>
      <diffuse>0.8 0.8 0.8 1</diffuse>
      <specular>0.2 0.2 0.2 1</specular>
      <attenuation>
        <range>1000</range>
        <constant>0.9</constant>
        <linear>0.01</linear>
        <quadratic>0.001</quadratic>
      </attenuation>
      <direction>-0.5 0.1 -0.9</direction>
    </light>

  </world>
</sdf>
```

### Step 2: Physics Parameter Tuning Guide

**Timestep Selection**:

```python
# Rule of Thumb: Timestep â‰¤ 1 / (10 * highest_frequency_in_system)

# Example: Humanoid gripper servo runs at 50 Hz
max_frequency = 50  # Hz
recommended_timestep = 1.0 / (10 * max_frequency)
# = 0.002 seconds (2ms)

# Common timesteps:
# - 0.001 (1ms): High-frequency manipulation, grasping, contact-rich
# - 0.002 (2ms): General manipulation, humanoid arms
# - 0.005 (5ms): Mobile robots, navigation
# - 0.010 (10ms): Slow-moving systems, wheeled robots
```

**Solver Iterations**:
- Too few: Jittery contacts, constraint violations, objects fall through
- Too many: Slow simulation, diminishing returns
- **Tuning**: Start at 50, reduce until you see instability, add 20% margin

**CFM (Constraint Force Mixing)**:
- Acts as constraint "softness" (spring stiffness)
- `CFM = 0`: Infinitely stiff (risk of jitter)
- `CFM = 1e-5`: Good default for rigid bodies
- `CFM = 1e-3`: Soft contacts (rubber, foam)

**ERP (Error Reduction Parameter)**:
- How fast to correct constraint violations
- `ERP = 0.2`: Stable, gradual correction (default)
- `ERP = 0.8`: Aggressive, fast correction (risk of oscillation)

**Contact Parameters**:
```xml
<surface>
  <friction>
    <ode>
      <mu>0.8</mu>    <!-- Wood-on-wood: 0.4, Rubber: 1.0, Ice: 0.05 -->
      <mu2>0.8</mu2>  <!-- Anisotropic friction (different in two directions) -->
    </ode>
  </friction>

  <contact>
    <ode>
      <kp>1e7</kp>    <!-- Stiffness: Steel: 1e8, Rubber: 1e5 -->
      <kd>1.0</kd>    <!-- Damping: prevents bouncing -->
      <max_vel>0.01</max_vel>  <!-- Max penetration correction velocity -->
      <min_depth>0.0</min_depth>  <!-- Contact activation threshold -->
    </ode>
  </contact>

  <bounce>
    <restitution_coefficient>0.5</restitution_coefficient>  <!-- 0=no bounce, 1=perfect -->
    <threshold>0.01</threshold>  <!-- Min velocity for bounce -->
  </bounce>
</surface>
```

### Step 3: Benchmark Physics Engines

**Benchmark Script**: `~/ros2_ws/src/humanoid_control/scripts/physics_benchmark.py`

```python
#!/usr/bin/env python3
"""
Physics Engine Benchmark
Compare ODE, Bullet, DART performance and accuracy
"""

import rclpy
from rclpy.node import Node
from rosgraph_msgs.msg import Clock
from sensor_msgs.msg import JointState
import time
import numpy as np

class PhysicsBenchmark(Node):
    def __init__(self):
        super().__init__('physics_benchmark')

        # Subscribe to simulation clock
        self.clock_sub = self.create_subscription(
            Clock, '/clock', self.clock_callback, 10
        )

        # Subscribe to joint states
        self.joint_sub = self.create_subscription(
            JointState, '/joint_states', self.joint_callback, 10
        )

        # Metrics
        self.sim_time_start = None
        self.wall_time_start = None
        self.sim_times = []
        self.wall_times = []
        self.joint_velocities = []

        self.get_logger().info('Physics benchmark initialized')

    def clock_callback(self, msg):
        sim_time = msg.clock.sec + msg.clock.nanosec * 1e-9
        wall_time = time.time()

        if self.sim_time_start is None:
            self.sim_time_start = sim_time
            self.wall_time_start = wall_time

        self.sim_times.append(sim_time - self.sim_time_start)
        self.wall_times.append(wall_time - self.wall_time_start)

    def joint_callback(self, msg):
        if msg.velocity:
            self.joint_velocities.append(np.array(msg.velocity))

    def compute_metrics(self):
        """Compute real-time factor and stability metrics"""
        if len(self.sim_times) < 100:
            self.get_logger().warn('Not enough data for metrics')
            return

        # Real-time factor (RTF)
        # RTF = sim_time_elapsed / wall_time_elapsed
        # RTF > 1.0 = faster than real-time
        # RTF = 1.0 = real-time
        # RTF < 1.0 = slower than real-time
        sim_elapsed = self.sim_times[-1]
        wall_elapsed = self.wall_times[-1]
        rtf = sim_elapsed / wall_elapsed if wall_elapsed > 0 else 0

        # Velocity stability (standard deviation)
        if len(self.joint_velocities) > 10:
            vel_array = np.array(self.joint_velocities)
            vel_std = np.std(vel_array, axis=0)
            avg_vel_std = np.mean(vel_std)
        else:
            avg_vel_std = 0.0

        # Update rate (Hz)
        update_rate = len(self.sim_times) / wall_elapsed if wall_elapsed > 0 else 0

        self.get_logger().info('\n' + '='*60)
        self.get_logger().info('PHYSICS BENCHMARK RESULTS')
        self.get_logger().info('='*60)
        self.get_logger().info(f'Real-Time Factor (RTF): {rtf:.2f}x')
        self.get_logger().info(f'  (>1.0 = faster than real-time, 1.0 = real-time)')
        self.get_logger().info(f'Physics Update Rate: {update_rate:.1f} Hz')
        self.get_logger().info(f'Joint Velocity StdDev: {avg_vel_std:.4f} rad/s')
        self.get_logger().info(f'  (Lower = more stable)')
        self.get_logger().info(f'Simulation Time: {sim_elapsed:.2f}s')
        self.get_logger().info(f'Wall Clock Time: {wall_elapsed:.2f}s')
        self.get_logger().info('='*60)


def main(args=None):
    rclpy.init(args=args)
    node = PhysicsBenchmark()

    # Run for 30 seconds
    duration = 30.0
    node.get_logger().info(f'Running benchmark for {duration}s...')

    try:
        start = time.time()
        while time.time() - start < duration:
            rclpy.spin_once(node, timeout_sec=0.1)

        # Compute results
        node.compute_metrics()

    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

**Run Benchmark**:
```bash
# Terminal 1: Launch Gazebo with ODE
gz sim physics_test.world

# Terminal 2: Run benchmark
ros2 run humanoid_control physics_benchmark.py

# Expected Output (ODE, 1ms timestep):
# Real-Time Factor: 5.2x
# Physics Update Rate: 1000.0 Hz
# Joint Velocity StdDev: 0.0012 rad/s
```

**Switch to Bullet**:
```bash
# Edit physics_test.world, change:
<physics name="default_physics" type="bullet">
# Re-run benchmark, expect RTF: 20-50x (if GPU available)
```

### Step 4: Debugging Physics Issues

**Common Issues and Solutions**:

| Issue | Symptom | Diagnosis | Solution |
|-------|---------|-----------|----------|
| **Objects fall through floor** | Robot sinks, no collision | Timestep too large | Reduce `max_step_size` to 0.001s |
| **Jittery contacts** | Vibrating, oscillating | Too few solver iterations | Increase `<iters>` to 50-100 |
| **Slow simulation** | RTF < 1.0 | Too many iterations or small timestep | Reduce `<iters>`, increase timestep |
| **Unrealistic bouncing** | Objects bounce excessively | High restitution or ERP | Set `<restitution_coefficient>` to 0.0-0.3 |
| **Joints drift** | Joint angles change slowly | CFM too high | Reduce `<cfm>` to 1e-5 |
| **Explosions** | Robot flies apart | Timestep too large or stiff constraints | Reduce timestep, increase iterations |

**Diagnostic Commands**:
```bash
# Monitor real-time factor
gz topic -e -t /stats
# Shows: real_time_factor, sim_time, iterations

# Check physics engine
gz model -m humanoid_arm -i
# Shows: physics engine, joint info

# Profile performance
gz log -d 1  # Record for 1 second
gz log -p --hz  # Analyze update rates
```

### Step 5: Physics Tuning for Specific Tasks

**Manipulation (Grasping)**:
```xml
<physics type="ode">
  <max_step_size>0.001</max_step_size>  <!-- 1ms for contact-rich -->
  <real_time_update_rate>1000.0</real_time_update_rate>
  <ode>
    <solver>
      <iters>100</iters>  <!-- High for stable contacts -->
      <sor>1.3</sor>
    </solver>
  </ode>
</physics>

<!-- Gripper friction -->
<surface>
  <friction>
    <ode>
      <mu>1.5</mu>  <!-- High friction for grasping -->
    </ode>
  </friction>
  <contact>
    <ode>
      <kp>1e6</kp>  <!-- Compliant for soft contact -->
      <kd>10.0</kd>
    </ode>
  </contact>
</surface>
```

**Locomotion (Bipedal Walking)**:
```xml
<physics type="bullet">  <!-- Bullet more stable for ground contact -->
  <max_step_size>0.002</max_step_size>  <!-- 2ms acceptable -->
  <bullet>
    <solver>
      <iters>50</iters>
    </solver>
    <constraints>
      <split_impulse>true</split_impulse>  <!-- Critical for foot contact -->
    </constraints>
  </bullet>
</physics>

<!-- Foot friction -->
<surface>
  <friction>
    <ode>
      <mu>0.8</mu>  <!-- Prevent slipping -->
      <mu2>0.8</mu2>
    </ode>
  </friction>
  <contact>
    <ode>
      <kp>1e7</kp>  <!-- Stiff for ground -->
      <kd>1.0</kd>
    </ode>
  </contact>
</surface>
```

**Reinforcement Learning (Large-Scale)**:
```xml
<physics type="bullet">
  <max_step_size>0.01</max_step_size>  <!-- 10ms for speed -->
  <real_time_factor>10.0</real_time_factor>  <!-- Run 10x faster -->
  <bullet>
    <solver>
      <iters>20</iters>  <!-- Fewer iterations for speed -->
    </solver>
  </bullet>
</physics>
```

### Step 6: GPU-Accelerated Physics (Bullet)

**Enable Bullet GPU**:
```bash
# Install CUDA-enabled Bullet (if not already installed)
sudo apt install libbullet-dev libbullet-extras-dev

# Verify GPU support
nvidia-smi
# Should show CUDA 12.2+
```

**GPU Configuration**:
```xml
<physics type="bullet">
  <bullet>
    <solver>
      <type>sequential_impulse</type>
    </solver>
    <!-- GPU acceleration automatically enabled if CUDA available -->
  </bullet>
</physics>
```

**GPU Performance**:
- Single robot: 2-5x speedup (overhead not worth it)
- 10+ robots: 10-50x speedup (GPU parallelization shines)
- 100+ robots: 100-500x speedup (massive parallelism)

## Physics Engine Selection Guide

**Choose ODE when**:
- Standard manipulation tasks (grasping, pick-place)
- ROS 2 ecosystem (best tested, most compatible)
- Contact-rich environments (multiple simultaneous contacts)
- CPU-only systems

**Choose Bullet when**:
- Large-scale simulations (10+ robots)
- Reinforcement learning (need >10x real-time)
- GPU available (RTX series)
- Stacking, piling scenarios (split impulse stabilization)

**Choose DART when**:
- Research requiring high accuracy (biomechanics, human motion)
- Soft body simulation (deformable objects)
- Complex joint types (ball, screw, universal)
- Willing to trade speed for precision

---

## Agentic AI Integration

:::warning Agentic AI Consideration
**For autonomous robotics systems:**

Physics engines are the "world model" that AI agents use for:

**Perception â†’ Planning â†’ Action Loop:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Sensors   â”‚â”€â”€â”€â”€â–¶â”‚  AI Planner  â”‚â”€â”€â”€â”€â–¶â”‚   Physics   â”‚
â”‚ (Gazebo)    â”‚     â”‚  (LLM/RL)    â”‚     â”‚   Engine    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â–²                   â”‚                    â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    Feedback Loop
```

**Key Agentic Patterns:**

1. **Imagination/Planning**: Run physics forward to predict outcomes before executing
   ```python
   # Agent "imagines" multiple grasp approaches
   for grasp_candidate in candidates:
       sim_state = physics_engine.save_state()
       result = physics_engine.simulate(grasp_candidate, steps=100)
       grasp_success[grasp_candidate] = result.object_stable
       physics_engine.restore_state(sim_state)
   best_grasp = max(grasp_success, key=grasp_success.get)
   ```

2. **Monte Carlo Tree Search**: Parallel physics for decision tree exploration
3. **Reward Shaping**: Physics provides ground truth for RL reward computation
4. **Safety Verification**: Simulate actions before real-world execution

**LLM/Agent Interface Pattern:**
```python
class PhysicsWorldModel:
    """Interface for LLM agents to query physics state"""

    def get_contact_state(self, object_name: str) -> dict:
        """Returns contact forces, normals, friction for planning"""
        return {
            'in_contact': True,
            'contact_force_n': 15.2,
            'friction_margin': 0.3,  # How close to slipping
            'grasp_stable': True
        }

    def predict_action_outcome(self, action: str) -> dict:
        """Run physics forward to predict action result"""
        # Save state, apply action, simulate, restore
        return {'success_probability': 0.85, 'risk_factors': [...]}
```

**Safety Constraints for Autonomous Operation:**
- **Never** let agents modify physics parameters (timestep, solver) at runtime
- **Always** validate force/torque commands against safety limits before physics step
- **Require** human approval for physics configurations that differ &gt;10% from validated settings
:::

:::tip Elite Insight: Physics for Foundation Models
Large robotics foundation models (RT-2, PaLM-E) benefit from physics engines in two ways:

1. **Training Data Generation**: Generate millions of diverse physics interactions
2. **Inference-Time Verification**: Use physics to verify LLM-proposed plans are physically feasible

The trend is toward "physics-informed" AIâ€”models that understand Newton's laws implicitly through massive simulation exposure.
:::

---

## Practice Exercises

### Exercise 1: Foundation (Beginner)
**Objective:** Verify physics engine configuration and observe real-time factor

**Time:** ~15 minutes

**Skills Practiced:** World file editing, Gazebo launch, RTF monitoring

**Instructions:**
1. Create a minimal world file with the ODE physics engine:
   ```bash
   mkdir -p ~/ros2_ws/src/physics_exercises
   cd ~/ros2_ws/src/physics_exercises
   ```

2. Create `minimal_physics.world`:
   ```xml
   <?xml version="1.0"?>
   <sdf version="1.9">
     <world name="minimal_physics">
       <physics name="default" type="ode">
         <max_step_size>0.001</max_step_size>
         <real_time_update_rate>1000.0</real_time_update_rate>
       </physics>
       <gravity>0 0 -9.81</gravity>

       <!-- Ground plane -->
       <model name="ground">
         <static>true</static>
         <link name="link">
           <collision name="collision">
             <geometry><plane><normal>0 0 1</normal></plane></geometry>
           </collision>
         </link>
       </model>

       <!-- Falling box -->
       <model name="test_box">
         <pose>0 0 2 0 0 0</pose>
         <link name="link">
           <collision name="collision">
             <geometry><box><size>0.5 0.5 0.5</size></box></geometry>
           </collision>
           <visual name="visual">
             <geometry><box><size>0.5 0.5 0.5</size></box></geometry>
           </visual>
         </link>
       </model>
     </world>
   </sdf>
   ```

3. Launch and observe:
   ```bash
   gz sim minimal_physics.world
   ```

4. Check RTF in the bottom status bar of Gazebo GUI

**Success Criteria:**
- [ ] Box falls and lands on ground plane
- [ ] RTF displays ~1.0 or higher
- [ ] No error messages in terminal

<details>
<summary>ðŸ’¡ Hint</summary>
If RTF is very low (&lt;0.5), your CPU may be throttling. Check with `htop` and close other applications.
</details>

---

### Exercise 2: Engine Comparison (Intermediate)
**Objective:** Compare ODE and Bullet physics engines quantitatively

**Time:** ~30 minutes

**Skills Practiced:** Physics configuration, benchmarking, analysis

**Instructions:**
1. Modify your world file to support easy engine switching
2. Add 10 falling boxes at different positions
3. Run the benchmark script from Step 3 of the Implementation section
4. Record RTF for both ODE and Bullet (30 seconds each)
5. Create a comparison table

**Success Criteria:**
- [ ] Both engines run without errors
- [ ] RTF measurements recorded for each engine
- [ ] Documented which engine performs better and why

<details>
<summary>ðŸ’¡ Hint</summary>
Bullet typically shows higher RTF with multiple objects due to better cache optimization. ODE may be more stable for single-robot contact scenarios.
</details>

---

### Exercise 3: Production Challenge (Advanced)
**Objective:** Configure physics for a grasping scenario with stability validation

**Time:** ~60 minutes

**Skills Practiced:** Contact tuning, stability analysis, production configuration

**Scenario:** You're deploying a pick-and-place robot that must grasp cylindrical objects (soda cans) from a conveyor belt. The simulation must:
- Run at least 5x real-time for training
- Have stable grasp contacts (no jitter)
- Support 100+ training episodes without physics failures

**Requirements:**
1. Configure ODE with appropriate solver iterations
2. Set contact parameters for cylindrical objects
3. Implement a stability metric (joint velocity standard deviation)
4. Demonstrate 100 consecutive grasps without failure

**Constraints:**
- RTF must be â‰¥ 5.0
- Joint velocity std dev must be &lt; 0.01 rad/s during stable grasp
- No objects falling through gripper

<details>
<summary>âœ… Solution Approach</summary>

```xml
<physics type="ode">
  <max_step_size>0.002</max_step_size>  <!-- 2ms for speed -->
  <real_time_update_rate>500.0</real_time_update_rate>
  <ode>
    <solver>
      <iters>75</iters>  <!-- Balance speed/stability -->
      <sor>1.2</sor>     <!-- Slightly lower for stability -->
    </solver>
  </ode>
</physics>

<!-- Gripper surface -->
<surface>
  <friction>
    <ode><mu>1.2</mu></ode>  <!-- High for cylindrical grip -->
  </friction>
  <contact>
    <ode>
      <kp>5e5</kp>  <!-- Slightly softer -->
      <kd>50.0</kd> <!-- Higher damping for cylinders -->
    </ode>
  </contact>
</surface>
```
</details>

---

### Exercise 4: Architect's Design Challenge (Expert)
**Objective:** Design a multi-robot physics configuration for warehouse simulation

**Time:** ~2+ hours (can be ongoing)

**Scenario:** Design the physics architecture for simulating a warehouse with:
- 50 mobile robots (differential drive)
- 10 arm manipulators at picking stations
- 1000+ packages of varying sizes/weights
- Real-time visualization requirement

**Design Requirements:**
1. Select physics engine(s) and justify choice
2. Define timestep and solver configuration
3. Plan for GPU vs CPU allocation
4. Design contact parameter hierarchy (floor, packages, grippers)
5. Define monitoring and alerting for physics failures

**Deliverables:**
- Architecture diagram showing physics pipeline
- Configuration files for each robot type
- Performance budget (expected RTF, CPU/GPU utilization)
- Failure mode analysis and mitigation strategies

**Considerations:**
- Different physics parameters may be needed for mobile robots vs arms
- GPU acceleration ROI depends on parallelism
- Must integrate with existing ROS 2 navigation stack

---

## Enhanced Troubleshooting Guide

### Quick Fixes

| Symptom | Likely Cause | Quick Fix |
|---------|--------------|-----------|
| RTF always 1.0 | Real-time mode locked | Set `<real_time_factor>0.0</real_time_factor>` |
| Objects fall through floor | Timestep too large | Reduce to `<max_step_size>0.001</max_step_size>` |
| Jittery contacts | Too few iterations | Increase `<iters>` to 50+ |
| Simulation freezes | Constraint explosion | Increase `<cfm>` to 1e-4 |
| GPU not used (Bullet) | CUDA not detected | Verify with `nvidia-smi` |

### Diagnostic Decision Tree

```
RTF too low (<1.0)?
â”œâ”€â”€ Yes: Check CPU usage
â”‚   â”œâ”€â”€ CPU maxed â†’ Reduce solver iterations or increase timestep
â”‚   â””â”€â”€ CPU not maxed â†’ Check for I/O bottleneck (logging?)
â””â”€â”€ No: Performance acceptable

Objects behaving strangely?
â”œâ”€â”€ Falling through surfaces â†’ Reduce timestep
â”œâ”€â”€ Jittering/vibrating â†’ Increase solver iterations
â”œâ”€â”€ Exploding apart â†’ Check for interpenetrating initial poses
â””â”€â”€ Sliding unexpectedly â†’ Increase friction coefficient
```

### Deep Dive: Contact Instability

**Symptoms:**
- Objects vibrate when in contact
- Joints oscillate around rest position
- Intermittent "popping" of objects

**Root Causes:**
1. **Timestep too large** - Probability: High
2. **Solver iterations too low** - Probability: High
3. **Contact stiffness too high** - Probability: Medium
4. **ERP too aggressive** - Probability: Low

**Diagnosis Steps:**
```bash
# Step 1: Check current physics stats
gz topic -e -t /stats | head -20
# Look for: real_time_factor, iterations, step_size

# Step 2: Monitor joint states for oscillation
ros2 topic echo /joint_states --field velocity
# Look for: values oscillating instead of converging to 0

# Step 3: Check contact forces
gz topic -e -t /world/default/physics/contacts
# Look for: rapidly changing contact points
```

**Solutions:**
- **If Cause 1 (timestep):** Reduce `max_step_size` by 50%
- **If Cause 2 (iterations):** Double `<iters>` value
- **If Cause 3 (stiffness):** Reduce `kp` by 10x, increase `kd` by 2x
- **If Cause 4 (ERP):** Reduce `erp` to 0.1

**Prevention:**
- Always test physics config with worst-case scenario (many contacts)
- Use benchmark script to validate stability before deployment
- Log physics stats continuously in production

---

## Summary

### Key Commands Reference

```bash
# Launch Gazebo with specific world
gz sim <world_file.world>

# Check physics stats
gz topic -e -t /stats

# List available physics plugins
gz plugin --list | grep physics

# Run in headless mode (no GUI, faster)
gz sim -s <world_file.world>

# Profile physics performance
gz log -d 10 && gz log -p --hz
```

### Physics Engine Decision Matrix

| Scenario | Engine | Timestep | Iterations | Expected RTF |
|----------|--------|----------|------------|--------------|
| Single arm manipulation | ODE | 1ms | 50-100 | 3-10x |
| Bipedal locomotion | Bullet | 2ms | 50 | 5-15x |
| Multi-robot (10+) | Bullet+GPU | 5ms | 20-30 | 20-100x |
| Research/accuracy | DART | 1ms | N/A | 1-3x |
| RL training (speed) | Bullet+GPU | 10ms | 20 | 50-200x |

### Configuration Checklist

Before deploying a physics configuration:
- [ ] Benchmark RTF meets requirements
- [ ] Contact stability validated (no jitter)
- [ ] Tested with maximum expected load
- [ ] Failure modes documented
- [ ] Monitoring/alerting configured
- [ ] Rollback procedure defined

## Next Steps

With physics engines configured, proceed to:
- **M2-C1-S3**: World Creation (environments, lighting, object spawning)
- **M2-C1-S4**: Sensor Plugins (camera, lidar, depth, force/torque)
- **M2-C1-S5**: Contact Dynamics (friction models, contact forces)

**Troubleshooting**:
- **"Physics engine not found"**: Reinstall Gazebo, check `gz plugin --list`
- **RTF always 1.0**: Disable real-time mode: `<real_time_factor>0.0</real_time_factor>`
- **GPU not detected**: Verify CUDA with `nvcc --version`, reinstall Bullet with CUDA
- **Simulation freezes**: Reduce solver iterations, increase timestep

**Real-World Physics Tuning**:
- Boston Dynamics (Spot): Bullet, 2ms timestep, 30 iterations, 5x real-time
- Tesla (Optimus humanoid): Custom engine, 0.5ms timestep, GPU-accelerated
- OpenAI (Dactyl hand): MuJoCo (similar to DART), 2ms timestep, 50 iterations

**Performance Tips**:
1. **Profile first**: Run benchmark before tuning (don't guess)
2. **Start simple**: Use default ODE, only switch if bottlenecked
3. **Reduce geometry**: Use primitive shapes (cylinders, boxes) not meshes
4. **Disable shadows**: `<cast_shadows>false</cast_shadows>` saves 30% rendering
5. **Headless mode**: Run without GUI for RL training: `gz sim -s` (server only)

---

**Assessment Preparation**: This section prepares for **Assessment 3: Simulation and Sim-to-Real (Week 9)**. You must demonstrate configuring physics engines, tuning parameters for stability, and benchmarking real-time factor.

