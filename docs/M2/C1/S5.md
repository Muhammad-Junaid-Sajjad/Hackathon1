---
id: m2-c1-s5
title: Friction Models and Ground Interaction
sidebar_position: 5
keywords: ['friction', 'ground', 'interaction', 'coulomb', 'rolling-resistance', 'torsional']
---

# Friction Models and Ground Interaction

## Overview

**Friction models** determine how surfaces interact—whether a humanoid foot slips during locomotion, whether a wheel rolls smoothly or skids, and whether a gripper maintains contact during manipulation. Gazebo implements multiple friction models: **Coulomb friction** (standard sliding), **viscous friction** (velocity-dependent), **rolling resistance** (wheels, spheres), and **torsional friction** (spinning resistance). Accurate friction modeling is critical for sim-to-real transfer in locomotion and wheeled navigation.

**What You'll Build**: A comprehensive friction testing environment with benchmarks for different friction models, ground contact analysis for bipedal walking, wheel-ground interaction for mobile robots, and friction parameter identification from real-world data.

## Prerequisites

Before starting this section, ensure you have:

- **Completed [M2-C1-S4](./S4.md)**: Contact forces and collision properties
- **Physics engine configured**: ODE or Bullet with appropriate solver settings
- **Understanding of contact mechanics**: Normal and tangential forces
- **Python 3.11+**: With numpy, scipy, matplotlib for analysis

## Learning Objectives

By the end of this section, you will be able to:

- **[Beginner]** Explain Coulomb friction and configure basic friction coefficients
- **[Beginner]** Set up friction parameters in SDF for common materials
- **[Intermediate]** Implement anisotropic friction for specialized surfaces
- **[Intermediate]** Configure rolling resistance for wheeled robots
- **[Advanced]** Build slip detection systems for bipedal locomotion
- **[Advanced]** Perform friction parameter identification from real data
- **[Expert]** Design friction models for sim-to-real transfer validation

## Key Concepts

| Term | Definition | Why It Matters |
|------|------------|----------------|
| **Coulomb Friction** | F_friction = μ × N (force proportional to normal) | Standard friction model |
| **Static Friction (μs)** | Friction before sliding begins | Higher than kinetic |
| **Kinetic Friction (μk)** | Friction during sliding | Used in simulation |
| **Anisotropic Friction** | Different μ in different directions | Conveyor belts, grooves |
| **Rolling Resistance** | Opposes wheel rotation | Affects mobile robots |
| **Torsional Friction** | Resists spinning/pivoting | In-place rotation |
| **Slip** | When tangential force exceeds μ × N | Causes locomotion failure |

:::danger Latency Trap Warning
**Slip detection for locomotion requires sub-5ms control loops.** A bipedal robot falling cannot wait for cloud-based balance computation. Always:
- Run slip detection and balance control locally on Jetson
- Pre-deploy trained balance policies (no network inference during walking)
- Use onboard IMU/force sensors with direct hardware connection
:::

## Skill-Level Pathways

:::note For Beginners
If you're new to friction modeling, focus on:
1. Understanding the **Friction Reference Table**
2. Configuring basic Coulomb friction (mu, mu2)
3. Testing with tilted plane experiments
4. Completing **Exercise 1**

**Skip on first read**: System identification, torsional friction, domain randomization
:::

:::tip Intermediate Path
If you have simulation experience:
1. Implement **Slip Detection** for locomotion
2. Configure **Rolling Resistance** for mobile robots
3. Test anisotropic friction on conveyor surfaces
4. Complete **Exercises 1-2**
:::

:::caution Advanced Path
For production locomotion/navigation systems:
1. Master friction parameter identification
2. Implement domain randomization for robust policies
3. Validate sim-to-real friction transfer
4. Complete **Exercise 3** and attempt the **Architect Challenge**
:::

---

## Industry Perspectives

:::info Industry Spotlight: Boston Dynamics (Atlas/Spot)
**How Boston Dynamics uses friction modeling:**
Atlas and Spot train on varied terrain friction (μ = 0.3-1.5) to build robust locomotion. They use real-world friction measurements to calibrate simulation and domain randomization to handle uncertainty.

**Key metrics they care about:**
- **Slip recovery**: &lt;200ms from slip detection to recovery action
- **Terrain classification**: 5+ terrain types identified in real-time
- **Friction estimation**: Online μ estimation within ±20% accuracy

**Lessons learned:**
For dynamic locomotion, train on *worst-case* friction (μ = 0.4), not average. Robots that train on high friction fail on wet surfaces.
:::

:::info Industry Spotlight: NASA JPL (Mars Rovers)
**How NASA uses friction modeling:**
Mars rovers operate on regolith (μ ≈ 0.3-0.5) with unpredictable slip. They use detailed wheel-terrain interaction models validated against test beds.

**Key metrics they care about:**
- **Slip prediction**: &lt;10% error on predicted vs actual slip
- **Power consumption**: Friction affects drive motor current
- **Path planning**: Avoid high-slip terrain (slopes &gt;15°)

**Lessons learned:**
Wheel sinkage matters as much as friction—soft terrain models require deformation in addition to slip.
:::

:::info Industry Spotlight: Amazon Robotics (Warehouse AMRs)
**How Amazon uses friction modeling:**
Warehouse floors have consistent friction (sealed concrete, μ ≈ 0.6-0.8), but spills, debris, and wear create local variations. They simulate friction variation for robust navigation.

**Key metrics they care about:**
- **Stopping distance**: Must be predictable for collision avoidance
- **Turn accuracy**: Torsional friction affects rotation
- **Fleet consistency**: All robots must handle same friction range

**Lessons learned:**
For indoor environments, floor friction is more consistent than expected—focus on edge cases (spills, plastic wrap, ramps).
:::

---

## Hardware Requirements

**Workstation** (from M1-C1-S1)
- Ubuntu 24.04 LTS
- NVIDIA RTX 5080/6080 (16GB+ VRAM) for 2025-standard contact/friction physics
- ROS 2 Kilted Kaiju + Gazebo Ionic (M2-C1-S1)
- 16-core CPU for high-frequency locomotion control loops

## Connection to Capstone

The capstone uses friction models for:

1. **Bipedal Walking**: Foot-ground friction prevents slip during stance phase (humanoid locomotion)
2. **Mobile Base Navigation**: Wheel-ground friction affects odometry accuracy and traction
3. **Grasping**: Finger-object friction determines grasp stability (covered in M2-C1-S4)
4. **Terrain Adaptation**: Different surfaces (tile, carpet, gravel) require friction tuning
5. **Slip Detection**: Monitor friction forces to detect and recover from slip

**Critical Friction Parameters**:
- **μ (mu)**: Static friction coefficient (0.0-2.0)
- **μ2 (mu2)**: Secondary direction friction (anisotropic)
- **Rolling resistance**: Coefficient for wheels (0.001-0.1)
- **Torsional friction**: Spinning resistance (advanced)

## Implementation

### Step 1: Coulomb Friction Model

**Basic Coulomb Friction** (force = μ × normal_force):

```xml
<!-- Standard Friction (Isotropic) -->
<surface>
  <friction>
    <ode>
      <mu>0.8</mu>    <!-- Coefficient of friction -->
      <mu2>0.8</mu2>  <!-- Same in both directions -->
    </ode>
  </friction>
</surface>

<!-- Material-Specific Examples -->
<!-- Rubber on Concrete -->
<friction>
  <ode>
    <mu>1.0</mu>
    <mu2>1.0</mu2>
  </ode>
</friction>

<!-- Steel on Steel -->
<friction>
  <ode>
    <mu>0.4</mu>
    <mu2>0.4</mu2>
  </ode>
</friction>

<!-- Ice on Ice -->
<friction>
  <ode>
    <mu>0.05</mu>
    <mu2>0.05</mu2>
  </ode>
</friction>

<!-- Teflon (very low friction) -->
<friction>
  <ode>
    <mu>0.04</mu>
    <mu2>0.04</mu2>
  </ode>
</friction>
```

**Friction Reference Table**:

| Material Pair | μ (Static) | μ (Kinetic) | Use Case |
|--------------|------------|-------------|----------|
| Rubber on Concrete | 1.0 | 0.8 | Robot feet, tires |
| Rubber on Wet Concrete | 0.7 | 0.5 | Outdoor navigation |
| Steel on Steel | 0.4 | 0.3 | Actuator joints |
| Wood on Wood | 0.6 | 0.4 | Furniture manipulation |
| Plastic on Plastic | 0.3 | 0.2 | Object handling |
| Ice on Ice | 0.05 | 0.03 | Slippery surfaces |
| Tire on Asphalt | 0.9 | 0.7 | Vehicle simulation |
| Tire on Wet Asphalt | 0.6 | 0.4 | Rain conditions |

### Step 2: Anisotropic Friction

**Different friction in two perpendicular directions**:

```xml
<!-- Example: Conveyor Belt (easy to slide along, hard across) -->
<surface>
  <friction>
    <ode>
      <mu>0.3</mu>      <!-- Low friction along belt direction -->
      <mu2>1.2</mu2>    <!-- High friction across belt -->
      <fdir1>1 0 0</fdir1>  <!-- Primary direction (belt motion) -->
    </ode>
  </friction>
</surface>

<!-- Example: Grooved Surface -->
<surface>
  <friction>
    <ode>
      <mu>0.5</mu>      <!-- Friction along grooves -->
      <mu2>1.0</mu2>    <!-- Higher friction across grooves -->
      <fdir1>0 1 0</fdir1>
    </ode>
  </friction>
</surface>
```

**Anisotropic Friction Visualizer**:

```python
#!/usr/bin/env python3
"""
Anisotropic Friction Tester
Spawn object on anisotropic surface and apply forces
"""

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Wrench
import numpy as np

class FrictionTester(Node):
    def __init__(self):
        super().__init__('friction_tester')

        # Publisher to apply forces to test object
        self.wrench_pub = self.create_publisher(
            Wrench,
            '/test_object/apply_force',
            10
        )

        self.get_logger().info('Friction tester initialized')

    def test_friction_directions(self):
        """Apply forces in different directions to test friction"""

        # Test force along primary direction (fdir1)
        self.get_logger().info('Testing friction along primary direction...')
        wrench_x = Wrench()
        wrench_x.force.x = 10.0  # 10N force
        self.wrench_pub.publish(wrench_x)

        # Wait and observe slip
        self.get_clock().sleep_for(rclpy.duration.Duration(seconds=2))

        # Test force perpendicular to primary direction
        self.get_logger().info('Testing friction perpendicular to primary...')
        wrench_y = Wrench()
        wrench_y.force.y = 10.0  # Same magnitude
        self.wrench_pub.publish(wrench_y)

        # Compare slip distances
        self.get_logger().info('Compare slip: should be different in each direction')


def main(args=None):
    rclpy.init(args=args)
    node = FrictionTester()

    node.test_friction_directions()

    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Step 3: Force-Dependent Slip

**Slip parameters allow gradual transition from static to kinetic friction**:

```xml
<surface>
  <friction>
    <ode>
      <mu>0.8</mu>
      <mu2>0.8</mu2>
      <!-- Slip = force-dependent slip coefficient -->
      <!-- 0.0 = no slip (infinitely stiff contact) -->
      <!-- 0.01 = slight compliance (realistic) -->
      <slip1>0.01</slip1>
      <slip2>0.01</slip2>
    </ode>
  </friction>
</surface>
```

**Slip Behavior**:
- `slip = 0.0`: Contact behaves as rigid constraint (can cause jitter)
- `slip = 0.01`: Small slip under high tangential forces (realistic)
- `slip = 0.1`: Significant slip (low friction or soft contact)

### Step 4: Rolling Resistance

**Wheels and spheres experience rolling resistance** (opposes rolling motion):

```xml
<!-- Wheel with Rolling Resistance -->
<link name="wheel">
  <collision name="collision">
    <geometry>
      <cylinder>
        <radius>0.15</radius>
        <length>0.05</length>
      </cylinder>
    </geometry>
    <surface>
      <friction>
        <ode>
          <mu>0.9</mu>      <!-- Lateral friction (prevents slip) -->
          <mu2>0.9</mu2>
        </ode>
        <!-- Rolling resistance not directly in SDF, modeled via joint damping -->
      </friction>
    </surface>
  </collision>
</link>

<!-- Joint with rolling resistance (damping) -->
<joint name="wheel_joint" type="revolute">
  <parent>base_link</parent>
  <child>wheel</child>
  <axis>
    <xyz>0 1 0</xyz>
    <dynamics>
      <damping>0.01</damping>  <!-- Rolling resistance -->
      <friction>0.005</friction>
    </dynamics>
  </axis>
</joint>
```

**Rolling Resistance Coefficients**:
- Hard tire on asphalt: 0.01-0.015
- Inflated tire on asphalt: 0.005-0.01
- Car tire on concrete: 0.01
- Train wheel on rail: 0.001-0.002
- Ball bearing: 0.001

### Step 5: Torsional Friction

**Spinning resistance** (important for pivoting, in-place rotation):

```xml
<surface>
  <friction>
    <torsional>
      <coefficient>0.1</coefficient>  <!-- Torsional friction coefficient -->
      <surface_radius>0.05</surface_radius>  <!-- Contact patch radius -->
      <use_patch_radius>true</use_patch_radius>
    </torsional>
  </friction>
</surface>
```

**Use Cases**:
- Humanoid foot rotation during turning
- Robotic vacuum cleaner spinning in place
- Gripper finger rotation (twisting grasp)

### Step 6: Ground Contact Analysis for Bipedal Walking

**Foot Contact Sensor with Friction Monitoring**:

```xml
<gazebo reference="foot_link">
  <sensor name="foot_contact" type="contact">
    <update_rate>100</update_rate>
    <contact>
      <collision>foot_collision</collision>
    </contact>
    <plugin name="foot_contact_plugin" filename="libgazebo_ros_bumper.so">
      <ros>
        <remapping>~/out:=/foot/contact</remapping>
      </ros>
    </plugin>
  </sensor>
</gazebo>
```

**Slip Detection Node**:

```python
#!/usr/bin/env python3
"""
Slip Detector for Bipedal Walking
Monitors foot contact forces and detects slip
"""

import rclpy
from rclpy.node import Node
from gazebo_msgs.msg import ContactsState
from geometry_msgs.msg import Twist
import numpy as np

class SlipDetector(Node):
    def __init__(self):
        super().__init__('slip_detector')

        # Subscribe to foot contacts
        self.foot_contact_sub = self.create_subscription(
            ContactsState,
            '/foot/contact',
            self.contact_callback,
            10
        )

        # Slip detection parameters
        self.friction_coefficient = 0.8
        self.slip_threshold = 0.9  # 90% of friction limit
        self.is_slipping = False

        self.get_logger().info('Slip detector initialized')

    def contact_callback(self, msg):
        """Detect slip from contact forces"""
        if len(msg.states) == 0:
            return

        # Compute total normal and tangential forces
        total_normal = 0.0
        total_tangential = 0.0

        for contact in msg.states:
            for wrench in contact.wrenches:
                # Normal force (z-direction for ground)
                normal = abs(wrench.force.z)
                total_normal += normal

                # Tangential force (x-y plane)
                tangential = np.sqrt(wrench.force.x**2 + wrench.force.y**2)
                total_tangential += tangential

        # Check slip condition
        if total_normal > 0.1:  # In contact
            friction_force_limit = self.friction_coefficient * total_normal
            friction_ratio = total_tangential / friction_force_limit

            if friction_ratio > self.slip_threshold:
                if not self.is_slipping:
                    self.get_logger().warn(
                        f'⚠️  SLIP DETECTED! '
                        f'Tangential={total_tangential:.2f}N, '
                        f'Limit={friction_force_limit:.2f}N, '
                        f'Ratio={friction_ratio:.2%}'
                    )
                    self.is_slipping = True
            else:
                if self.is_slipping:
                    self.get_logger().info('✓ Slip recovered')
                    self.is_slipping = False


def main(args=None):
    rclpy.init(args=args)
    node = SlipDetector()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Step 7: Friction Parameter Identification

**System Identification from Real-World Data**:

```python
#!/usr/bin/env python3
"""
Friction Parameter Identification
Estimate friction coefficients from experimental data
"""

import numpy as np
from scipy.optimize import minimize
import matplotlib.pyplot as plt

class FrictionIdentifier:
    def __init__(self):
        self.mu_est = None
        self.mu2_est = None

    def collect_data(self, applied_forces, measured_accelerations, mass, normal_force):
        """
        Collect experimental data

        Args:
            applied_forces: Nx2 array of applied forces [fx, fy] (N)
            measured_accelerations: Nx2 array of accelerations [ax, ay] (m/s²)
            mass: Object mass (kg)
            normal_force: Normal force (N)

        Returns:
            Identified friction coefficients
        """
        n_samples = len(applied_forces)

        def friction_model(params):
            """Predict accelerations given friction params"""
            mu, mu2 = params

            predicted_accel = []
            for i in range(n_samples):
                fx_applied, fy_applied = applied_forces[i]

                # Friction forces oppose motion
                # F_net = F_applied - F_friction
                # F_friction = mu * N (Coulomb model)

                # Direction-dependent friction
                fx_friction = -np.sign(fx_applied) * min(abs(fx_applied), mu * normal_force)
                fy_friction = -np.sign(fy_applied) * min(abs(fy_applied), mu2 * normal_force)

                # Net force
                fx_net = fx_applied + fx_friction
                fy_net = fy_applied + fy_friction

                # Acceleration
                ax = fx_net / mass
                ay = fy_net / mass

                predicted_accel.append([ax, ay])

            return np.array(predicted_accel)

        def objective(params):
            """Minimize prediction error"""
            predicted = friction_model(params)
            error = np.sum((predicted - measured_accelerations)**2)
            return error

        # Optimize
        initial_guess = [0.5, 0.5]
        bounds = [(0.0, 2.0), (0.0, 2.0)]
        result = minimize(objective, initial_guess, bounds=bounds, method='L-BFGS-B')

        self.mu_est, self.mu2_est = result.x

        print(f'Identified friction coefficients:')
        print(f'  mu  = {self.mu_est:.3f}')
        print(f'  mu2 = {self.mu2_est:.3f}')

        return self.mu_est, self.mu2_est

    def validate(self, test_forces, test_accelerations, mass, normal_force):
        """Validate identified parameters on test data"""
        predicted_accel = []

        for fx, fy in test_forces:
            fx_friction = -np.sign(fx) * min(abs(fx), self.mu_est * normal_force)
            fy_friction = -np.sign(fy) * min(abs(fy), self.mu2_est * normal_force)

            ax = (fx + fx_friction) / mass
            ay = (fy + fy_friction) / mass

            predicted_accel.append([ax, ay])

        predicted_accel = np.array(predicted_accel)

        # Compute error
        rmse = np.sqrt(np.mean((predicted_accel - test_accelerations)**2))
        print(f'Validation RMSE: {rmse:.4f} m/s²')

        return rmse


# Example usage
identifier = FrictionIdentifier()

# Simulated experimental data
n = 50
applied_forces = np.random.uniform(-20, 20, (n, 2))  # Random forces
true_mu = 0.7
true_mu2 = 0.6
mass = 2.0  # kg
normal_force = mass * 9.81  # N

# Simulate measured accelerations (with noise)
measured_accel = []
for fx, fy in applied_forces:
    fx_friction = -np.sign(fx) * min(abs(fx), true_mu * normal_force)
    fy_friction = -np.sign(fy) * min(abs(fy), true_mu2 * normal_force)

    ax = (fx + fx_friction) / mass + np.random.normal(0, 0.1)
    ay = (fy + fy_friction) / mass + np.random.normal(0, 0.1)

    measured_accel.append([ax, ay])

measured_accel = np.array(measured_accel)

# Identify friction
mu_est, mu2_est = identifier.collect_data(applied_forces, measured_accel, mass, normal_force)

# Validate
test_forces = np.random.uniform(-20, 20, (20, 2))
test_accel = []
for fx, fy in test_forces:
    fx_friction = -np.sign(fx) * min(abs(fx), true_mu * normal_force)
    fy_friction = -np.sign(fy) * min(abs(fy), true_mu2 * normal_force)

    ax = (fx + fx_friction) / mass + np.random.normal(0, 0.1)
    ay = (fy + fy_friction) / mass + np.random.normal(0, 0.1)

    test_accel.append([ax, ay])

test_accel = np.array(test_accel)
identifier.validate(test_forces, test_accel, mass, normal_force)
```

## Friction Tuning for Sim-to-Real Transfer

**Calibration Procedure**:

1. **Real-World Measurement**:
```bash
# Apply known force, measure slip distance
# F_friction = F_applied (at slip threshold)
# μ = F_friction / (m * g)
```

2. **Simulation Tuning**:
```xml
<!-- Start with reference values -->
<mu>0.8</mu>

<!-- Iterate: adjust μ until sim matches real slip behavior -->
```

3. **Validation**:
```python
# Compare sim vs real:
# - Slip distance under same applied force
# - Acceleration profile
# - Slip detection timing
```

**Domain Randomization for Friction**:
```python
# Randomize friction during RL training
friction_range = (0.6, 1.2)  # ±25% variation
randomized_mu = np.random.uniform(*friction_range)
```

---

## Agentic AI Integration

:::warning Agentic AI Consideration
**For autonomous locomotion and navigation systems:**

Friction is the interface between robot and world—AI agents must reason about friction for safe, effective movement:

**Friction-Aware Planning Loop:**
```
┌─────────────────────────────────────────────────────────┐
│                 AI Locomotion Agent                      │
├─────────────────────────────────────────────────────────┤
│  1. Perceive terrain → Estimate friction coefficient    │
│  2. Plan footstep/path considering friction limits      │
│  3. Execute with slip monitoring                        │
│  4. Detect slip → Trigger recovery behavior             │
│  5. Update friction estimate from experience            │
└─────────────────────────────────────────────────────────┘
```

**Key Agentic Patterns:**

1. **Online Friction Estimation**
   ```python
   class FrictionEstimator:
       """AI agent estimates friction from observed slip"""

       def estimate_friction(self, applied_force: float,
                            normal_force: float,
                            observed_acceleration: float,
                            mass: float) -> float:
           """Estimate μ from force-acceleration relationship"""
           net_force = mass * observed_acceleration
           friction_force = applied_force - net_force
           estimated_mu = friction_force / normal_force
           return max(0.1, min(2.0, estimated_mu))  # Clamp to valid range
   ```

2. **Friction-Constrained Path Planning**
   ```python
   def plan_path_with_friction(start, goal, terrain_map):
       """Plan path avoiding low-friction regions"""
       # Cost function includes friction risk
       def cost(node):
           distance_cost = node.distance_to_goal
           friction_cost = 10.0 / terrain_map.get_friction(node.position)
           slope_cost = abs(terrain_map.get_slope(node.position))
           return distance_cost + friction_cost + slope_cost

       return a_star(start, goal, cost_function=cost)
   ```

3. **Slip Recovery Behaviors**
4. **Terrain Classification for Friction Prediction**

**LLM/Agent Interface Pattern:**
```python
class FrictionInterface:
    """Interface for LLM agents to query friction state"""

    def get_terrain_status(self) -> str:
        """Natural language terrain assessment"""
        return f"""
        Current Terrain: {self.terrain_type}
        Estimated Friction: μ = {self.estimated_mu:.2f}
        Slip Risk: {'HIGH' if self.slip_margin < 0.2 else 'LOW'}
        Recommended Action: {'Reduce speed' if self.slip_risk_high else 'Normal operation'}
        """

    def is_safe_to_traverse(self, slope_deg: float) -> tuple[bool, str]:
        """Decision support for terrain traversal"""
        max_slope = math.degrees(math.atan(self.estimated_mu))
        if slope_deg > max_slope * 0.8:
            return False, f"Slope {slope_deg}° exceeds safe limit {max_slope*0.8:.0f}°"
        return True, "Terrain traversable"
```

**Safety Constraints for Autonomous Operation:**
- **Never** attempt slopes &gt; 80% of theoretical friction limit
- **Always** monitor slip during locomotion and navigation
- **Require** human approval for unknown terrain types
- **Log** all slip events for friction model improvement
:::

:::tip Elite Insight: Learning Friction from Experience
Modern locomotion systems use **learned friction models** that improve from real-world operation:

1. **Terrain embeddings**: CNN encodes terrain appearance → friction prediction
2. **Slip history**: Bayesian update of friction estimate from observed slip
3. **Transfer learning**: Pre-train on diverse terrains, fine-tune on deployment site

The trend is toward "self-calibrating" robots that automatically adjust friction models based on experience.
:::

---

## Practice Exercises

### Exercise 1: Foundation (Beginner)
**Objective:** Verify friction model with tilted plane experiment

**Time:** ~20 minutes

**Skills Practiced:** SDF friction configuration, slip angle calculation

**Instructions:**
1. Create world with tilted plane at 30°
2. Place box with μ = 0.6 on plane
3. Predict: Will it slip? (tan(30°) ≈ 0.577, which is &lt; 0.6)
4. Verify in simulation
5. Repeat with μ = 0.5 (should slip)

**Success Criteria:**
- [ ] Box stays stationary when μ &gt; tan(θ)
- [ ] Box slides when μ &lt; tan(θ)
- [ ] Measured critical angle matches theory within ±2°

---

### Exercise 2: Slip Detection (Intermediate)
**Objective:** Implement real-time slip detection for a mobile robot

**Time:** ~30 minutes

**Skills Practiced:** Contact sensor processing, slip threshold tuning

**Instructions:**
1. Add contact sensors to robot wheels
2. Implement SlipDetector node from Step 6
3. Test on surfaces with μ = 0.3, 0.6, 1.0
4. Tune slip threshold for &lt;100ms detection latency

**Success Criteria:**
- [ ] Slip detected within 100ms of occurrence
- [ ] False positive rate &lt;5%
- [ ] Works on all three friction surfaces

---

### Exercise 3: Friction Identification (Advanced)
**Objective:** Identify friction coefficient from experimental data

**Time:** ~60 minutes

**Skills Practiced:** System identification, optimization, validation

**Scenario:** Given force-acceleration data from a real robot, identify friction coefficients that minimize prediction error.

**Requirements:**
1. Implement FrictionIdentifier from Step 7
2. Run on provided dataset (or generate synthetic data)
3. Validate on held-out test set
4. Achieve RMSE &lt; 0.1 m/s²

---

### Exercise 4: Architect's Design Challenge (Expert)
**Objective:** Design friction modeling system for outdoor delivery robot

**Time:** ~2+ hours

**Scenario:** Design friction estimation and adaptation for a robot operating on:
- Sidewalks (concrete, varying conditions)
- Road crossings (asphalt, painted lines)
- Grass/gravel shortcuts
- Wet and icy conditions

**Design Requirements:**
1. Terrain classification from sensors (camera, IMU)
2. Online friction estimation algorithm
3. Path planning with friction constraints
4. Slip recovery behaviors

**Deliverables:**
- Architecture diagram
- Friction model selection rationale
- Validation plan for each terrain type
- Safety margin analysis

---

## Summary

### Key Commands Reference

```bash
# Test friction in Gazebo
gz sim friction_test.world

# Monitor contact forces
gz topic -e -t /world/default/contacts

# Check slip ratio
ros2 topic echo /slip_detector/slip_ratio
```

### Friction Parameter Quick Reference

| Surface Pair | μ (Static) | μ (Kinetic) | Use Case |
|--------------|------------|-------------|----------|
| Rubber on Concrete | 1.0 | 0.8 | Robot feet |
| Rubber on Wet Concrete | 0.7 | 0.5 | Rain conditions |
| Steel on Steel | 0.4 | 0.3 | Actuators |
| Tire on Asphalt | 0.9 | 0.7 | Vehicles |
| Ice | 0.05 | 0.03 | Slippery surfaces |

### Friction Configuration Checklist

Before deploying friction configuration:
- [ ] Friction coefficients match real materials
- [ ] Slip detection calibrated and tested
- [ ] Domain randomization range validated
- [ ] Sim-to-real transfer verified
- [ ] Edge cases tested (wet, debris)

## Next Steps

With friction models mastered, proceed to:
- **M2-C1-S6**: Joint Controllers and Actuation (PID, impedance, trajectory control)
- **M2-C1-S7**: ROS 2-Gazebo Bridge (complete integration, topic mapping)

**Troubleshooting**:
- **Objects slip unexpectedly**: Increase μ, reduce timestep, increase solver iterations
- **Objects stick (no slip when expected)**: Check slip1/slip2 &gt; 0, reduce μ
- **Anisotropic friction not working**: Verify fdir1 is perpendicular to contact normal
- **Rolling resistance too high**: Reduce joint damping, check wheel radius
- **Torsional friction causes instability**: Reduce coefficient, increase timestep

**Real-World Friction Applications**:
- **Boston Dynamics (Atlas)**: Foot friction tuning for varied terrains (concrete, gravel, mud)
- **Tesla (Optimus)**: Slip detection for bipedal balance recovery
- **NASA Mars Rovers**: Wheel-regolith friction models (μ ≈ 0.3-0.5)
- **Warehouse AMRs**: Omni-wheel torsional friction for smooth rotation

---

**Assessment Preparation**: This section prepares for **Assessment 3: Simulation and Sim-to-Real (Week 9)**. You must demonstrate friction parameter tuning, slip detection, and friction identification from experimental data.
