---
id: m2-c1-s6
title: Joint Controllers and Actuation
sidebar_position: 6
keywords: ['controllers', 'actuation', 'pid', 'impedance', 'trajectory', 'gazebo-ros2-control']
---

# Joint Controllers and Actuation

## Overview

**Joint controllers** translate high-level commands (target positions, velocities, efforts) into low-level actuation forces that move robot joints in simulation. Gazebo Ionic integrates with **ros2_control** to provide industry-standard controllers: **PID position control**, **velocity control**, **effort (torque) control**, **impedance control**, and **trajectory control**. Accurate joint control is essential for realistic manipulation, locomotion, and contact-rich tasks.

**What You'll Build**: A complete joint control system with PID-tuned position controllers, velocity controllers for wheels, effort controllers for force-sensitive tasks, impedance controllers for compliant manipulation, and trajectory execution for multi-joint motion planning.

## Prerequisites

Before starting this section, ensure you have:

- **Completed [M2-C1-S5](./S5.md)**: Friction models and ground interaction
- **ros2_control installed**: `sudo apt install ros-kilted-ros2-control ros-kilted-ros2-controllers`
- **URDF with joints defined**: From Module 1 Chapter 3
- **Understanding of PID control**: Proportional-Integral-Derivative basics

## Learning Objectives

By the end of this section, you will be able to:

- **[Beginner]** Explain different controller types (position, velocity, effort)
- **[Beginner]** Configure ros2_control hardware interfaces in URDF
- **[Intermediate]** Tune PID gains for stable joint control
- **[Intermediate]** Execute multi-waypoint trajectories via action clients
- **[Advanced]** Implement impedance control for compliant manipulation
- **[Advanced]** Design force/torque control for grippers
- **[Expert]** Architect control systems for complex manipulation tasks

## Key Concepts

| Term | Definition | Why It Matters |
|------|------------|----------------|
| **Position Control** | Move joint to target angle | Pick-and-place, reaching |
| **Velocity Control** | Maintain constant speed | Wheels, conveyors |
| **Effort Control** | Apply specific torque | Force control, balance |
| **Impedance Control** | Spring-damper behavior | Safe human interaction |
| **Trajectory Control** | Multi-point smooth motion | Planned paths |
| **PID Gains (Kp, Ki, Kd)** | Controller tuning parameters | Stability and response |

:::danger Latency Trap Warning
**Joint control loops must run at 100-1000 Hz locally.** PID control over network introduces delays that cause oscillation and instability:
- Run ros2_control on the same machine as Gazebo or directly on robot hardware
- Never send joint commands over WiFi during active control
- Use EtherCAT or similar real-time protocols for physical robots
:::

## Skill-Level Pathways

:::note For Beginners
Focus on:
1. Understanding controller types in the overview
2. Setting up basic position controller
3. Sending simple joint commands
4. Completing **Exercise 1**

**Skip on first read**: Impedance control, force control, advanced PID tuning
:::

:::tip Intermediate Path
If you have ROS 2 experience:
1. Configure and tune PID controllers
2. Implement trajectory execution
3. Complete **Exercises 1-2**
:::

:::caution Advanced Path
For production manipulation systems:
1. Master impedance control for compliant tasks
2. Implement force-controlled grasping
3. Complete **Exercise 3** and **Architect Challenge**
:::

---

## Industry Perspectives

:::info Industry Spotlight: Universal Robots (UR)
**How Universal Robots uses control:**
UR cobots use 500Hz joint trajectory control with force/torque feedback for safe human-robot collaboration. Their controllers support seamless switching between position and force modes.

**Key metrics:**
- **Control rate**: 500 Hz servo loop
- **Force accuracy**: ¬±2N in force mode
- **Safety response**: &lt;10ms to stop on collision
:::

:::info Industry Spotlight: Franka Emika (Panda)
**How Franka uses impedance control:**
Panda robots pioneered research-grade impedance control (K = 100-3000 N/m) for contact-rich tasks. Their Cartesian impedance mode enables compliant assembly and human guidance.

**Key metrics:**
- **Stiffness range**: 0-3000 N/m per axis
- **Damping range**: 0-100 Ns/m
- **Control bandwidth**: 1kHz internal, 1ms external
:::

:::info Industry Spotlight: Boston Dynamics
**How Boston Dynamics uses torque control:**
Atlas and Spot use 200Hz torque control for dynamic locomotion. Their hierarchical controllers blend position tracking with force limits for balance.

**Key metrics:**
- **Update rate**: 200 Hz whole-body control
- **Torque accuracy**: ¬±0.5 Nm
- **Balance recovery**: &lt;500ms from perturbation
:::

---

## Hardware Requirements

**Workstation** (from M1-C1-S1)
- Ubuntu 24.04 LTS
- NVIDIA RTX 5080/6080 (16GB+ VRAM) for 2025-standard GPU-accelerated control
- ROS 2 Kilted Kaiju + Gazebo Ionic (M2-C1-S1)
- 16-core CPU for high-frequency (1kHz) Whole-Body Control loops

## Connection to Capstone

The capstone uses joint controllers for:

1. **Manipulation**: Position control for pick-place, trajectory control for smooth motion
2. **Locomotion**: Velocity control for wheels, torque control for legs (balance)
3. **Compliant Tasks**: Impedance control for safe human-robot interaction, force-sensitive assembly
4. **Gripper Control**: Effort control to apply specific grasp forces without crushing objects
5. **Real-Time Control**: 100-1000 Hz control loops synchronized with physics simulation

**Controller Types**:
- **Position**: Move joint to target angle (pick-and-place, reaching)
- **Velocity**: Constant speed (wheels, conveyors)
- **Effort**: Apply specific torque (force control, balance)
- **Impedance**: Compliant behavior (spring-damper, safe contact)
- **Trajectory**: Multi-point smooth motion (planned paths)

## Implementation

### Step 1: ros2_control Integration with Gazebo

**Install ros2_control**:
```bash
sudo apt install ros-kilted-ros2-control ros-kilted-ros2-controllers -y
sudo apt install ros-kilted-gazebo-ros2-control -y
```

**URDF with ros2_control tags**:

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid_arm">

  <!-- Existing URDF from M1-C3-S1 -->
  <xacro:include filename="$(find humanoid_description)/urdf/humanoid_arm.urdf.xacro"/>

  <!-- ros2_control hardware interface -->
  <ros2_control name="GazeboSystem" type="system">
    <hardware>
      <plugin>gazebo_ros2_control/GazeboSystem</plugin>
    </hardware>

    <!-- Shoulder Joint -->
    <joint name="shoulder_joint">
      <command_interface name="position">
        <param name="min">-1.57</param>  <!-- -90¬∞ -->
        <param name="max">1.57</param>   <!-- +90¬∞ -->
      </command_interface>
      <command_interface name="velocity"/>
      <command_interface name="effort"/>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>

    <!-- Elbow Joint -->
    <joint name="elbow_joint">
      <command_interface name="position">
        <param name="min">0.0</param>
        <param name="max">2.35</param>  <!-- ~135¬∞ -->
      </command_interface>
      <command_interface name="velocity"/>
      <command_interface name="effort"/>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>

    <!-- Wrist Joint -->
    <joint name="wrist_joint">
      <command_interface name="position">
        <param name="min">-1.57</param>
        <param name="max">1.57</param>
      </command_interface>
      <command_interface name="velocity"/>
      <command_interface name="effort"/>
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>

    <!-- Gripper Joint -->
    <joint name="gripper_joint">
      <command_interface name="effort"/>  <!-- Force control -->
      <state_interface name="position"/>
      <state_interface name="velocity"/>
      <state_interface name="effort"/>
    </joint>

  </ros2_control>

  <!-- Gazebo plugin for ros2_control -->
  <gazebo>
    <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">
      <parameters>$(find humanoid_control)/config/controllers.yaml</parameters>
    </plugin>
  </gazebo>

</robot>
```

### Step 2: Controller Configuration

**File**: `~/ros2_ws/src/humanoid_control/config/controllers.yaml`

```yaml
controller_manager:
  ros__parameters:
    update_rate: 100  # Hz (controller loop frequency)

    # Joint State Broadcaster (publishes /joint_states)
    joint_state_broadcaster:
      type: joint_state_broadcaster/JointStateBroadcaster

    # Position Controller (for manipulation)
    arm_position_controller:
      type: position_controllers/JointGroupPositionController

    # Velocity Controller (for wheels)
    wheel_velocity_controller:
      type: velocity_controllers/JointGroupVelocityController

    # Effort Controller (for gripper)
    gripper_effort_controller:
      type: effort_controllers/JointGroupEffortController

    # Trajectory Controller (for planned motion)
    arm_trajectory_controller:
      type: joint_trajectory_controller/JointTrajectoryController

# Joint State Broadcaster
joint_state_broadcaster:
  ros__parameters:
    joints:
      - shoulder_joint
      - elbow_joint
      - wrist_joint
      - gripper_joint

# Position Controller
arm_position_controller:
  ros__parameters:
    joints:
      - shoulder_joint
      - elbow_joint
      - wrist_joint

    command_interfaces:
      - position

    state_interfaces:
      - position
      - velocity

    # PID gains (tune these!)
    gains:
      shoulder_joint:
        p: 100.0
        i: 0.1
        d: 10.0
        i_clamp: 1.0
        antiwindup: true
      elbow_joint:
        p: 100.0
        i: 0.1
        d: 10.0
        i_clamp: 1.0
      wrist_joint:
        p: 50.0
        i: 0.05
        d: 5.0
        i_clamp: 0.5

# Velocity Controller
wheel_velocity_controller:
  ros__parameters:
    joints:
      - left_wheel_joint
      - right_wheel_joint

    command_interfaces:
      - velocity

    state_interfaces:
      - velocity

# Effort Controller
gripper_effort_controller:
  ros__parameters:
    joints:
      - gripper_joint

    command_interfaces:
      - effort

    state_interfaces:
      - effort

# Trajectory Controller
arm_trajectory_controller:
  ros__parameters:
    joints:
      - shoulder_joint
      - elbow_joint
      - wrist_joint

    command_interfaces:
      - position

    state_interfaces:
      - position
      - velocity

    state_publish_rate: 50.0  # Hz
    action_monitor_rate: 20.0  # Hz

    allow_partial_joints_goal: false
    allow_integration_in_goal_trajectories: true

    constraints:
      stopped_velocity_tolerance: 0.01
      goal_time: 0.5  # Trajectory must complete within 0.5s of target time

    # PID gains
    gains:
      shoulder_joint:
        p: 100.0
        i: 0.1
        d: 10.0
      elbow_joint:
        p: 100.0
        i: 0.1
        d: 10.0
      wrist_joint:
        p: 50.0
        i: 0.05
        d: 5.0
```

### Step 3: PID Controller Tuning

**PID Tuning Methodology** (Ziegler-Nichols):

```python
#!/usr/bin/env python3
"""
PID Tuner
Interactive PID gain tuning
"""

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState
from std_msgs.msg import Float64MultiArray
import matplotlib.pyplot as plt
import numpy as np

class PIDTuner(Node):
    def __init__(self):
        super().__init__('pid_tuner')

        # Subscribe to joint states
        self.joint_sub = self.create_subscription(
            JointState,
            '/joint_states',
            self.joint_callback,
            10
        )

        # Publish position commands
        self.cmd_pub = self.create_publisher(
            Float64MultiArray,
            '/arm_position_controller/commands',
            10
        )

        # Data logging
        self.positions = []
        self.target_position = 1.0  # rad
        self.times = []
        self.start_time = self.get_clock().now()

        self.get_logger().info('PID tuner initialized')

    def joint_callback(self, msg):
        """Log joint position over time"""
        current_time = (self.get_clock().now() - self.start_time).nanoseconds / 1e9

        if 'shoulder_joint' in msg.name:
            idx = msg.name.index('shoulder_joint')
            position = msg.position[idx]

            self.positions.append(position)
            self.times.append(current_time)

    def send_step_command(self):
        """Send step input to system"""
        cmd = Float64MultiArray()
        cmd.data = [self.target_position, 0.0, 0.0]  # Shoulder only
        self.cmd_pub.publish(cmd)

        self.get_logger().info(f'Sent step command: {self.target_position} rad')

    def analyze_response(self):
        """Analyze step response and suggest PID gains"""
        positions = np.array(self.positions)
        times = np.array(self.times)

        # Compute metrics
        final_value = positions[-1]
        overshoot = (np.max(positions) - self.target_position) / self.target_position * 100
        rise_time = times[np.where(positions >= 0.9 * self.target_position)[0][0]]
        settling_time_idx = np.where(np.abs(positions - self.target_position) < 0.02 * self.target_position)[0]
        settling_time = times[settling_time_idx[0]] if len(settling_time_idx) > 0 else times[-1]

        print('='*60)
        print('STEP RESPONSE ANALYSIS')
        print('='*60)
        print(f'Target Position: {self.target_position:.3f} rad')
        print(f'Final Position:  {final_value:.3f} rad')
        print(f'Overshoot:       {overshoot:.1f}%')
        print(f'Rise Time:       {rise_time:.3f} s')
        print(f'Settling Time:   {settling_time:.3f} s')
        print('='*60)

        # Tuning suggestions
        if overshoot > 10:
            print('‚ö†Ô∏è  High overshoot ‚Üí Reduce Kp or increase Kd')
        if rise_time > 1.0:
            print('‚ö†Ô∏è  Slow rise ‚Üí Increase Kp')
        if settling_time > 2.0:
            print('‚ö†Ô∏è  Slow settling ‚Üí Increase Kd')
        if abs(final_value - self.target_position) > 0.05:
            print('‚ö†Ô∏è  Steady-state error ‚Üí Increase Ki')

        # Plot
        plt.figure(figsize=(10, 6))
        plt.plot(times, positions, label='Actual', linewidth=2)
        plt.axhline(y=self.target_position, color='r', linestyle='--', label='Target')
        plt.axhline(y=self.target_position * 1.1, color='g', linestyle=':', alpha=0.5, label='+10% overshoot')
        plt.xlabel('Time (s)')
        plt.ylabel('Position (rad)')
        plt.title('PID Step Response')
        plt.legend()
        plt.grid(True)
        plt.tight_layout()
        plt.savefig('/tmp/pid_step_response.png')
        print('üìä Plot saved to /tmp/pid_step_response.png')


def main(args=None):
    rclpy.init(args=args)
    node = PIDTuner()

    # Send step command
    node.send_step_command()

    # Collect data for 5 seconds
    import time
    time.sleep(5.0)

    # Analyze
    node.analyze_response()

    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

**PID Tuning Rules**:
- **Kp (Proportional)**: Controls response speed (higher = faster, but overshoot)
- **Ki (Integral)**: Eliminates steady-state error (too high = oscillation)
- **Kd (Derivative)**: Reduces overshoot (too high = noise amplification)

**Typical Values**:
- Light arm: Kp=100, Ki=0.1, Kd=10
- Heavy arm: Kp=500, Ki=1.0, Kd=50
- Gripper: Kp=20, Ki=0.0, Kd=2 (no integral to avoid force buildup)

### Step 4: Trajectory Controller

**Execute Trajectory with Action Client**:

```python
#!/usr/bin/env python3
"""
Trajectory Execution
Send joint trajectory via action client
"""

import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from control_msgs.action import FollowJointTrajectory
from trajectory_msgs.msg import JointTrajectoryPoint
from builtin_interfaces.msg import Duration

class TrajectoryExecutor(Node):
    def __init__(self):
        super().__init__('trajectory_executor')

        # Action client
        self.traj_client = ActionClient(
            self,
            FollowJointTrajectory,
            '/arm_trajectory_controller/follow_joint_trajectory'
        )

        self.get_logger().info('Trajectory executor initialized')

    def execute_trajectory(self, waypoints, durations):
        """
        Execute multi-waypoint trajectory

        Args:
            waypoints: List of joint angle lists [[q1, q2, q3], ...]
            durations: List of times to reach each waypoint (seconds)
        """
        # Wait for action server
        self.traj_client.wait_for_server()

        # Build trajectory
        goal = FollowJointTrajectory.Goal()
        goal.trajectory.joint_names = ['shoulder_joint', 'elbow_joint', 'wrist_joint']

        cumulative_time = 0.0
        for waypoint, duration in zip(waypoints, durations):
            point = JointTrajectoryPoint()
            point.positions = waypoint
            point.velocities = [0.0] * len(waypoint)

            cumulative_time += duration
            point.time_from_start = Duration(sec=int(cumulative_time),
                                              nanosec=int((cumulative_time % 1) * 1e9))

            goal.trajectory.points.append(point)

        # Send goal
        self.get_logger().info(f'Executing trajectory with {len(waypoints)} waypoints...')
        future = self.traj_client.send_goal_async(goal)
        rclpy.spin_until_future_complete(self, future)

        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().error('Trajectory rejected!')
            return False

        # Wait for result
        result_future = goal_handle.get_result_async()
        rclpy.spin_until_future_complete(self, result_future)

        result = result_future.result().result
        if result.error_code == FollowJointTrajectory.Result.SUCCESSFUL:
            self.get_logger().info('‚úì Trajectory executed successfully')
            return True
        else:
            self.get_logger().error(f'Trajectory failed with error code: {result.error_code}')
            return False


def main(args=None):
    rclpy.init(args=args)
    node = TrajectoryExecutor()

    # Define trajectory (joint angles in radians)
    waypoints = [
        [0.0, 0.0, 0.0],      # Home position
        [0.5, 0.8, 0.2],      # Intermediate
        [1.0, 1.5, 0.5],      # Final position
    ]

    durations = [2.0, 2.0, 2.0]  # 2 seconds per segment

    success = node.execute_trajectory(waypoints, durations)

    if success:
        print('Trajectory complete!')
    else:
        print('Trajectory failed!')

    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Step 5: Impedance Control

**Compliant controller** (spring-damper behavior):

```python
#!/usr/bin/env python3
"""
Impedance Controller
Implements spring-damper dynamics for compliant manipulation
"""

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState
from std_msgs.msg import Float64MultiArray
import numpy as np

class ImpedanceController(Node):
    def __init__(self):
        super().__init__('impedance_controller')

        # Impedance parameters
        self.K = np.array([100.0, 100.0, 50.0])  # Stiffness (N/m per joint)
        self.D = np.array([20.0, 20.0, 10.0])    # Damping (N¬∑s/m per joint)

        # Target position
        self.q_desired = np.array([0.5, 1.0, 0.3])

        # Current state
        self.q_current = None
        self.dq_current = None

        # Subscribe to joint states
        self.joint_sub = self.create_subscription(
            JointState,
            '/joint_states',
            self.joint_callback,
            10
        )

        # Publish effort commands
        self.effort_pub = self.create_publisher(
            Float64MultiArray,
            '/arm_effort_controller/commands',
            10
        )

        # Control loop timer (100 Hz)
        self.timer = self.create_timer(0.01, self.control_loop)

        self.get_logger().info('Impedance controller initialized')
        self.get_logger().info(f'Stiffness: {self.K}')
        self.get_logger().info(f'Damping: {self.D}')

    def joint_callback(self, msg):
        """Update current state"""
        # Extract arm joints (assume first 3)
        self.q_current = np.array(msg.position[:3])
        self.dq_current = np.array(msg.velocity[:3])

    def control_loop(self):
        """Compute and publish impedance control effort"""
        if self.q_current is None:
            return

        # Impedance control law
        # œÑ = K * (q_desired - q) - D * dq
        position_error = self.q_desired - self.q_current
        effort = self.K * position_error - self.D * self.dq_current

        # Publish
        cmd = Float64MultiArray()
        cmd.data = effort.tolist()
        self.effort_pub.publish(cmd)


def main(args=None):
    rclpy.init(args=args)
    node = ImpedanceController()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

**Impedance Use Cases**:
- **Low Stiffness** (K=10, D=5): Highly compliant (safe human interaction, soft assembly)
- **Medium Stiffness** (K=100, D=20): Moderate compliance (force-sensitive tasks)
- **High Stiffness** (K=1000, D=100): Near-rigid (position tracking, but with some give)

### Step 6: Force/Torque Control for Gripper

**Effort controller for grasp force**:

```python
#!/usr/bin/env python3
"""
Gripper Force Controller
Apply specific grasp force without crushing object
"""

import rclpy
from rclpy.node import Node
from std_msgs.msg import Float64
from sensor_msgs.msg import JointState

class GripperForceController(Node):
    def __init__(self):
        super().__init__('gripper_force_controller')

        # Desired grasp force (Newtons)
        self.target_force = 10.0

        # Publish effort command
        self.effort_pub = self.create_publisher(
            Float64,
            '/gripper_effort_controller/commands',
            10
        )

        # Subscribe to gripper state
        self.joint_sub = self.create_subscription(
            JointState,
            '/joint_states',
            self.joint_callback,
            10
        )

        self.gripper_closed = False

        self.get_logger().info(f'Gripper force controller: target={self.target_force}N')

    def joint_callback(self, msg):
        """Monitor gripper state"""
        if 'gripper_joint' in msg.name:
            idx = msg.name.index('gripper_joint')
            position = msg.position[idx]
            velocity = msg.velocity[idx]

            # Detect contact (velocity drops to zero)
            if abs(velocity) < 0.01 and not self.gripper_closed:
                self.get_logger().info('‚úì Contact detected, applying grasp force')
                self.gripper_closed = True

    def apply_grasp_force(self):
        """Publish constant grasp force"""
        cmd = Float64()
        cmd.data = self.target_force
        self.effort_pub.publish(cmd)


def main(args=None):
    rclpy.init(args=args)
    node = GripperForceController()

    # Continuously apply force
    rate = node.create_rate(100)  # 100 Hz
    try:
        while rclpy.ok():
            node.apply_grasp_force()
            rclpy.spin_once(node, timeout_sec=0.01)
            rate.sleep()
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Controller Launch File

**File**: `~/ros2_ws/src/humanoid_control/launch/controllers.launch.py`

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import ExecuteProcess
import os
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():
    # Get controller config
    controller_config = os.path.join(
        get_package_share_directory('humanoid_control'),
        'config',
        'controllers.yaml'
    )

    return LaunchDescription([
        # Controller manager
        Node(
            package='controller_manager',
            executable='ros2_control_node',
            parameters=[controller_config],
            output='screen'
        ),

        # Load joint state broadcaster
        ExecuteProcess(
            cmd=['ros2', 'control', 'load_controller', '--set-state', 'active',
                 'joint_state_broadcaster'],
            output='screen'
        ),

        # Load position controller
        ExecuteProcess(
            cmd=['ros2', 'control', 'load_controller', '--set-state', 'active',
                 'arm_position_controller'],
            output='screen'
        ),
    ])
```

---

## Agentic AI Integration

:::warning Agentic AI Consideration
**For autonomous manipulation systems:**

Controllers are the execution layer for AI-planned actions:

**AI-Controller Integration:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 AI Manipulation Agent                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Planner (High-level)  ‚Üí  Goal: "Pick up cup"          ‚îÇ
‚îÇ         ‚Üì                                               ‚îÇ
‚îÇ  Motion Planner        ‚Üí  Trajectory: [q0, q1, q2...]  ‚îÇ
‚îÇ         ‚Üì                                               ‚îÇ
‚îÇ  Controller (Low-level) ‚Üí  Execute with compliance     ‚îÇ
‚îÇ         ‚Üì                                               ‚îÇ
‚îÇ  Feedback              ‚Üí  Contact detected, adapt      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Key Agentic Patterns:**

1. **Adaptive Control Selection**
   ```python
   class AdaptiveController:
       def select_controller(self, task_phase: str) -> str:
           if task_phase == "approach":
               return "position"  # Fast, accurate positioning
           elif task_phase == "contact":
               return "impedance"  # Compliant for safe contact
           elif task_phase == "grasp":
               return "force"  # Apply specific grasp force
   ```

2. **Learning-Based Gain Scheduling**
   ```python
   def adaptive_gains(task_difficulty: float, payload: float):
       """AI adjusts PID gains based on task"""
       base_kp = 100.0
       # Reduce gains for delicate tasks
       kp = base_kp * (1.0 - 0.5 * task_difficulty)
       # Increase for heavy payloads
       kp = kp * (1.0 + 0.2 * payload / 5.0)
       return kp
   ```

**Safety Constraints:**
- **Never** exceed joint torque limits during force control
- **Always** enable collision detection during trajectory execution
- **Require** impedance mode for human-robot proximity
:::

---

## Practice Exercises

### Exercise 1: PID Tuning (Beginner)
**Objective:** Tune PID gains for a single joint

**Time:** ~20 minutes

**Instructions:**
1. Start with Kp=50, Ki=0, Kd=0
2. Send step command and observe response
3. Increase Kp until oscillation, then reduce by 20%
4. Add Kd to reduce overshoot
5. Add small Ki to eliminate steady-state error

**Success Criteria:**
- [ ] Overshoot &lt; 10%
- [ ] Rise time &lt; 0.5s
- [ ] Steady-state error &lt; 1¬∞

---

### Exercise 2: Trajectory Execution (Intermediate)
**Objective:** Execute multi-waypoint trajectory

**Time:** ~30 minutes

**Instructions:**
1. Define 5-waypoint trajectory
2. Implement TrajectoryExecutor from Step 4
3. Execute trajectory and verify smooth motion
4. Plot actual vs. commanded positions

---

### Exercise 3: Impedance Control (Advanced)
**Objective:** Implement compliant insertion task

**Time:** ~60 minutes

**Scenario:** Peg-in-hole insertion requiring compliance to handle misalignment.

**Requirements:**
1. Implement ImpedanceController from Step 5
2. Tune K and D for successful insertion
3. Handle 5mm misalignment
4. Log contact forces during insertion

---

## Summary

### Key Commands

```bash
# Load controllers
ros2 control load_controller --set-state active arm_position_controller

# List controllers
ros2 control list_controllers

# Send position command
ros2 topic pub /arm_position_controller/commands std_msgs/Float64MultiArray "data: [0.5, 1.0, 0.3]"
```

### Controller Selection Guide

| Task | Controller | Typical Gains |
|------|-----------|---------------|
| Pick-and-place | Position | Kp=100, Ki=0.1, Kd=10 |
| Wheel drive | Velocity | Kp=10, Ki=1.0, Kd=0.5 |
| Force-sensitive | Effort | Direct torque |
| Human interaction | Impedance | K=100-500, D=20-50 |

## Next Steps

With joint controllers complete, proceed to:
- **M2-C1-S7**: ROS 2-Gazebo Bridge (final integration, complete M2-C1)

**Troubleshooting**:
- **Controller not loading**: Check `controllers.yaml` syntax, verify joint names match URDF
- **Oscillation**: Reduce Kp or increase Kd
- **Slow response**: Increase Kp
- **Steady-state error**: Increase Ki
- **Effort control unstable**: Reduce update rate, add filtering

**Real-World Control Applications**:
- **Universal Robots (UR5e)**: 500 Hz joint trajectory control with force/torque feedback
- **Franka Emika (Panda)**: Impedance control for compliant manipulation (K=100-3000 N/m)
- **Boston Dynamics (Spot)**: 200 Hz leg torque control for dynamic balance

---

**Assessment Preparation**: This section prepares for **Assessment 3: Simulation and Sim-to-Real (Week 9)**. You must demonstrate PID tuning, trajectory execution, and impedance control configuration.
