---
id: m2-c1-s1
title: Gazebo Harmonic Installation and ROS 2 Integration
sidebar_position: 1
keywords: ['gazebo', 'harmonic', 'installation', 'ros2-gz', 'simulation', 'physics', 'digital-twin', 'sim-to-real']
---

# Gazebo Harmonic Installation and ROS 2 Integration

## Prerequisites

Before starting this section, ensure you have:

| Requirement | Description | Verification |
|-------------|-------------|--------------|
| **M1-C1-S1** | Ubuntu 22.04 + NVIDIA drivers | `nvidia-smi` shows GPU |
| **M1-C1-S4** | ROS 2 Humble installed | `ros2 --version` returns 0.x.x |
| **M1-C3-S1** | Humanoid URDF created | File exists in `~/ros2_ws/src/humanoid_description/urdf/` |
| **Hardware** | RTX 4070 Ti or equivalent (12GB+ VRAM) | Required for GPU rendering |
| **Disk Space** | 20GB free | `df -h` shows available space |

## Learning Objectives

By the end of this section, you will be able to:

| Level | Objective |
|-------|-----------|
| ğŸŒ± **Beginner** | Define what a physics simulator does and why we need digital twins |
| ğŸŒ± **Beginner** | Install Gazebo Harmonic and verify it runs correctly |
| ğŸ”§ **Intermediate** | Configure the ros_gz_bridge to connect Gazebo and ROS 2 topics |
| ğŸ”§ **Intermediate** | Spawn URDF robots into Gazebo simulation environments |
| âš¡ **Advanced** | Add sensor plugins (IMU, camera) to URDFs for simulation |
| ğŸ—ï¸ **Architect** | Design simulation architectures for multi-robot AI training systems |

## Key Concepts

| Term | Definition | Why It Matters |
|------|------------|----------------|
| **Digital Twin** | A virtual replica of a physical robot that mirrors its behavior | Enables testing dangerous scenarios without hardware risk |
| **Physics Simulator** | Software that computes forces, collisions, and motion using physics equations | Determines how realistic robot movements appear |
| **ros_gz_bridge** | Middleware that translates Gazebo topics to ROS 2 topics and vice versa | Allows existing ROS 2 code to work with simulated sensors |
| **SDF** | Simulation Description Format - XML schema for describing simulation worlds | More expressive than URDF, supports multiple robots and environments |
| **Real-Time Factor (RTF)** | Ratio of simulation time to wall-clock time (RTF=2 means 2x faster than real-time) | Determines how quickly you can train AI or test algorithms |
| **Gazebo Plugin** | Loadable module that adds functionality (sensors, actuators, physics) | Extends Gazebo without modifying core code |

---

## Skill-Level Pathways

:::note ğŸŒ± Beginner Path
**If this is your first simulator**, focus on:
1. Read "Why Digital Twins Matter" section carefully
2. Follow installation steps exactly
3. Get the `shapes.sdf` demo running
4. Complete Exercise 1 only

**Skip on first read**: Gazebo plugins, bridge configuration details
**Time estimate**: 45-60 minutes
:::

:::tip ğŸ”§ Intermediate Path
**If you've used ROS 2 but not Gazebo Harmonic**, focus on:
1. Skim installation (you may already have it)
2. Deep dive on ros_gz_bridge configuration
3. Spawn your URDF and verify topics
4. Complete Exercises 1-2

**Time estimate**: 60-90 minutes
:::

:::caution âš¡ Advanced Path
**For production simulation systems**, pay attention to:
1. Performance optimization notes
2. Plugin architecture for custom sensors
3. Multi-robot spawning patterns
4. Complete all exercises including Challenge

**Time estimate**: 2-3 hours with exercises
:::

---

## Introduction: Why Digital Twins Matter

Imagine you're developing a humanoid robot that costs $150,000. Every fall during testing risks thousands in repairs. Every failed grasp could damage sensors. Every collision could bend actuators.

Now imagine you could test 10,000 falls, 100,000 grasps, and 1 million collisionsâ€”all before the physical robot takes its first step.

**This is the power of simulation.**

:::tip Why This Matters
**Every major robotics company uses simulation as their primary development environment:**
- **Tesla Optimus**: Trained walking policies on 10,000+ simulated robots in parallel before hardware testing
- **Boston Dynamics**: Developed Atlas backflip in simulation, transferred to hardware in 2 attempts
- **Amazon Robotics**: Validates 99% of warehouse robot behaviors in simulation before deployment

You're learning the same workflow used to build billion-dollar robotics programs.
:::

### The Simulation-Reality Pipeline

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    THE SIM-TO-REAL DEVELOPMENT PIPELINE                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   DESIGN     â”‚   â”‚   SIMULATE   â”‚   â”‚   VALIDATE   â”‚   â”‚   DEPLOY     â”‚ â”‚
â”‚  â”‚              â”‚   â”‚              â”‚   â”‚              â”‚   â”‚              â”‚ â”‚
â”‚  â”‚  URDF/Xacro  â”‚â”€â”€â–¶â”‚   Gazebo     â”‚â”€â”€â–¶â”‚  Real Robot  â”‚â”€â”€â–¶â”‚  Production  â”‚ â”‚
â”‚  â”‚  CAD Models  â”‚   â”‚   Isaac Sim  â”‚   â”‚  (Limited)   â”‚   â”‚   Fleet      â”‚ â”‚
â”‚  â”‚  Specs       â”‚   â”‚   MuJoCo     â”‚   â”‚              â”‚   â”‚              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                             â”‚
â”‚        10%              80%              9%               1%                â”‚
â”‚    of dev time      of dev time      of dev time      of dev time          â”‚
â”‚                                                                             â”‚
â”‚  Key Insight: 80% of robotics development happens in simulation!           â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## What Is Gazebo Harmonic?

### Definition

**Gazebo Harmonic** is an open-source, physics-based robotics simulator that creates accurate digital twins of robots and environments. It computes:
- **Rigid body dynamics**: How objects move when forces are applied
- **Collision detection**: When and where objects touch
- **Sensor simulation**: What cameras, LiDARs, and IMUs would perceive
- **Actuator response**: How motors respond to commands

### Why Gazebo Over Other Simulators?

:::note For Beginners
Think of Gazebo like a "video game engine for robots." Just as Unity or Unreal creates virtual worlds for games, Gazebo creates virtual worlds for robotsâ€”but with *physically accurate* behavior.
:::

| Dimension | Gazebo Harmonic | Isaac Sim | MuJoCo | PyBullet |
|-----------|-----------------|-----------|--------|----------|
| **Best For** | ROS 2 integration | NVIDIA GPU training | Research/RL | Quick prototyping |
| **Physics Quality** | â­â­â­â­ Good | â­â­â­â­â­ Excellent | â­â­â­â­â­ Excellent | â­â­â­ Adequate |
| **ROS 2 Support** | â­â­â­â­â­ Native | â­â­â­â­ Via bridge | â­â­ Limited | â­â­ Limited |
| **Learning Curve** | â­â­â­â­ Easy | â­â­â­ Medium | â­â­â­ Medium | â­â­â­â­â­ Very Easy |
| **GPU Acceleration** | â­â­â­ Optional | â­â­â­â­â­ Required | â­â­â­â­ Good | â­â­ Limited |
| **Multi-Robot** | â­â­â­â­ Good | â­â­â­â­â­ Excellent | â­â­â­ Adequate | â­â­ Limited |
| **Cost** | Free | Free (GPU req) | Free | Free |
| **Community** | â­â­â­â­â­ Large | â­â­â­â­ Growing | â­â­â­ Medium | â­â­â­ Medium |

**Recommendation**: Start with Gazebo (this module) for ROS 2 integration. Graduate to Isaac Sim (Module 3) for large-scale GPU training.

---

## Industry Perspectives

:::info Industry Spotlight: Warehouse Robotics (Amazon, Locus, 6 River)
**How logistics companies use Gazebo:**
- Simulate entire warehouse floors with 100+ robots
- Test fleet coordination algorithms without disrupting operations
- Validate new pick strategies with synthetic objects

**Key metrics they care about:**
- **Throughput**: Picks per hour per robot (target: 300-600)
- **Collision rate**: Must be &lt;0.01% in simulation before deployment
- **Path planning efficiency**: 95%+ optimal path adherence

**Lesson learned**: "If it doesn't work in simulation, don't bother trying on hardware." â€” Amazon Robotics engineer
:::

:::info Industry Spotlight: Healthcare Robotics (Intuitive Surgical, Medtronic)
**How medical robotics uses simulation:**
- Validate surgical procedure safety with tissue models
- Train surgeons on simulated procedures before patients
- Test failure modes that would be unethical on real systems

**Key metrics they care about:**
- **Position accuracy**: &lt;1mm for surgical applications
- **Force limits**: Never exceed tissue damage thresholds
- **Latency**: &lt;10ms for teleoperation feedback

**Regulatory note**: FDA increasingly accepts simulation data for validation
:::

---

## Agentic AI Integration

:::warning ğŸ¤– Agentic AI Consideration
**For autonomous AI systems, simulation is the "imagination" capability:**

**Perception Training:**
- Gazebo generates synthetic sensor data with perfect ground truth
- AI agents learn object detection without manual labeling
- Domain randomization creates robust perception models

**Planning & Decision Making:**
```python
# Example: AI agent uses simulation for lookahead planning
class AgenticPlanner:
    def __init__(self, gazebo_client):
        self.sim = gazebo_client

    def evaluate_action(self, action: Action) -> float:
        """Run action in simulation to predict outcome."""
        # Save current state
        state = self.sim.get_state()

        # Execute action in simulation
        self.sim.step(action)
        reward = self.sim.evaluate_outcome()

        # Restore state (simulation as "imagination")
        self.sim.set_state(state)

        return reward

    def plan(self, goal: Goal) -> List[Action]:
        """Monte Carlo tree search using simulation."""
        # Use parallel simulations to evaluate action sequences
        pass
```

**Safety Constraints for Autonomous Operation:**
- Simulation validates that actions won't cause collisions
- Force limits tested in sim before real execution
- Edge cases discovered through randomized simulation

**LLM Integration Pattern:**
An LLM-based robot controller can use Gazebo to:
1. Generate candidate motion plans
2. Simulate each plan to check feasibility
3. Select the safest, most efficient option
4. Only then execute on real hardware
:::

---

## Hardware Requirements

**Workstation** (from M1-C1-S1):
- Ubuntu 22.04 LTS
- NVIDIA RTX 4070 Ti (12GB VRAM) for GPU-accelerated rendering
- ROS 2 Humble installed (M1-C1-S4)
- 20GB free disk space

:::tip Elite Insight: Hardware Scaling
**For production simulation farms:**
- Single robot testing: RTX 4070 Ti sufficient
- 10-robot parallel training: RTX 4090 or A100
- 100+ robot fleet simulation: Multi-GPU server or cloud (AWS RoboMaker)

**Cost-performance sweet spot**: 4x RTX 4090 server (~$15K) can simulate 50+ robots at 10x real-time
:::

---

## Connection to Capstone

The capstone uses Gazebo for:

| Capstone Stage | How Gazebo Helps |
|----------------|------------------|
| **Voice Command** | Test speech-to-action pipeline without noise |
| **Task Planning** | Validate LLM-generated plans in simulation first |
| **Navigation** | Train SLAM and path planning in virtual warehouse |
| **Object Detection** | Generate synthetic training data with labels |
| **Manipulation** | Test grasp success rates before hardware |

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         CAPSTONE PIPELINE                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚    Voice â”€â”€â”€â–¶ Plan â”€â”€â”€â–¶ Navigate â”€â”€â”€â–¶ Vision â”€â”€â”€â–¶ Manipulate           â”‚
â”‚      â”‚         â”‚          â”‚            â”‚            â”‚                   â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                           â”‚                                             â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚              â”‚   ALL DEVELOPED FIRST   â”‚                                â”‚
â”‚              â”‚      IN GAZEBO          â”‚                                â”‚
â”‚              â”‚    (This Section)       â”‚                                â”‚
â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚                                                                         â”‚
â”‚   ğŸ¯ Key Insight: 80% of capstone development happens in simulation    â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Latency Trap Warning**: Train/validate in Gazebo (workstation RTX 4070 Ti) â†’ Flash weights to Jetson (no cloud dependency).

---

## Implementation

### Step 1: Install Gazebo Harmonic

**Installation Script**: `~/install-gazebo-harmonic.sh`

```bash
#!/bin/bash
# Install Gazebo Harmonic on Ubuntu 22.04
# Requires ROS 2 Humble

set -e

echo "===== Gazebo Harmonic Installation ====="

# Add Gazebo repository
sudo wget https://packages.osrfoundation.org/gazebo.gpg -O /usr/share/keyrings/pkgs-osrf-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/pkgs-osrf-archive-keyring.gpg] http://packages.osrfoundation.org/gazebo/ubuntu-stable $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/gazebo-stable.list > /dev/null

# Install Gazebo Harmonic
sudo apt update
sudo apt install gz-harmonic -y

# Install ROS 2 - Gazebo bridge
sudo apt install ros-humble-ros-gz -y

# Verify installation
gz sim --version
# Expected: Gazebo Sim, version 8.x.x

echo "===== Gazebo Harmonic Installed Successfully ====="
```

**Execute Installation**:
```bash
chmod +x install-gazebo-harmonic.sh
./install-gazebo-harmonic.sh
```

**Test Gazebo**:
```bash
gz sim shapes.sdf
# Opens Gazebo GUI with basic shapes world
```

**Expected Output**:
```
[Msg] Loading SDF world file[/usr/share/gz/gz-sim8/worlds/shapes.sdf]
[Msg] Rendering engine loaded: ogre2
```

:::warning Common Mistake
**Problem**: "Gazebo crashes with black screen"
**Cause**: GPU driver incompatibility or missing OpenGL
**Solution**:
```bash
# Force software rendering to diagnose
LIBGL_ALWAYS_SOFTWARE=1 gz sim shapes.sdf

# If that works, update GPU drivers:
sudo apt install nvidia-driver-535
sudo reboot
```
:::

### Step 2: Gazebo-ROS 2 Bridge

**ros_gz_bridge** translates Gazebo topics â†” ROS 2 topics:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    GAZEBO â†” ROS 2 BRIDGE ARCHITECTURE                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚   GAZEBO SIMULATION                    ROS 2 ECOSYSTEM                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚   â”‚ /gz/camera      â”‚ â”€â”€â”€[Bridge]â”€â”€â”€â–¶  â”‚ /camera/image   â”‚              â”‚
â”‚   â”‚ /gz/imu         â”‚ â”€â”€â”€[Bridge]â”€â”€â”€â–¶  â”‚ /imu/data       â”‚              â”‚
â”‚   â”‚ /gz/joints      â”‚ â”€â”€â”€[Bridge]â”€â”€â”€â–¶  â”‚ /joint_states   â”‚              â”‚
â”‚   â”‚ /gz/cmd_vel     â”‚ â—€â”€â”€[Bridge]â”€â”€â”€â”€â”€ â”‚ /cmd_vel        â”‚              â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                                         â”‚
â”‚   Message Type Translation:                                             â”‚
â”‚   â€¢ gz.msgs.Image    â†”  sensor_msgs/msg/Image                          â”‚
â”‚   â€¢ gz.msgs.IMU      â†”  sensor_msgs/msg/Imu                            â”‚
â”‚   â€¢ gz.msgs.Twist    â†”  geometry_msgs/msg/Twist                        â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Bridge Configuration**: `~/ros2_ws/config/gz_bridge_config.yaml`

```yaml
# Gazebo â†” ROS 2 Topic Mappings
- ros_topic_name: "/joint_states"
  gz_topic_name: "/world/default/model/humanoid_arm/joint_state"
  ros_type_name: "sensor_msgs/msg/JointState"
  gz_type_name: "gz.msgs.Model"
  direction: GZ_TO_ROS

- ros_topic_name: "/camera/image_raw"
  gz_topic_name: "/camera"
  ros_type_name: "sensor_msgs/msg/Image"
  gz_type_name: "gz.msgs.Image"
  direction: GZ_TO_ROS

- ros_topic_name: "/imu/data"
  gz_topic_name: "/imu"
  ros_type_name: "sensor_msgs/msg/Imu"
  gz_type_name: "gz.msgs.IMU"
  direction: GZ_TO_ROS

- ros_topic_name: "/cmd_vel"
  gz_topic_name: "/model/humanoid_arm/cmd_vel"
  ros_type_name: "geometry_msgs/msg/Twist"
  gz_type_name: "gz.msgs.Twist"
  direction: ROS_TO_GZ
```

**Launch Bridge**:
```bash
ros2 run ros_gz_bridge parameter_bridge --ros-args -p config_file:=gz_bridge_config.yaml
```

:::info Architect's View: Bridge Design Patterns
**For multi-robot systems, consider these patterns:**

1. **Namespaced Bridges**: Each robot gets its own namespace
```yaml
- ros_topic_name: "/robot1/joint_states"
  gz_topic_name: "/world/default/model/robot1/joint_state"
```

2. **Lazy Subscription**: Only bridge topics when subscribers exist
```yaml
lazy: true  # Reduces CPU when topics unused
```

3. **QoS Matching**: Match Gazebo QoS to ROS 2 requirements
```yaml
qos:
  reliability: reliable
  durability: volatile
```

**Scaling consideration**: Each bridge topic adds ~1-5% CPU overhead. For 100+ topics, consider selective bridging.
:::

### Step 3: Spawn URDF in Gazebo

**SDF Conversion** (URDF â†’ SDF for Gazebo):

Gazebo Harmonic uses **SDF (Simulation Description Format)**, but can spawn URDFs directly.

**Launch File**: `~/ros2_ws/src/humanoid_description/launch/gazebo_spawn.launch.py`

```python
import os
from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription, ExecuteProcess
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch_ros.actions import Node
from launch.substitutions import Command

def generate_launch_description():
    # Get URDF
    xacro_file = os.path.join(
        get_package_share_directory('humanoid_description'),
        'urdf', 'humanoid_arm.urdf.xacro'
    )
    robot_description = Command(['xacro ', xacro_file])

    # Gazebo world file
    world_file = os.path.join(
        get_package_share_directory('humanoid_description'),
        'worlds', 'empty.world'
    )

    return LaunchDescription([
        # Launch Gazebo
        ExecuteProcess(
            cmd=['gz', 'sim', '-r', world_file],
            output='screen'
        ),

        # Spawn robot
        Node(
            package='ros_gz_sim',
            executable='create',
            arguments=[
                '-name', 'humanoid_arm',
                '-topic', '/robot_description',
                '-x', '0.0',
                '-y', '0.0',
                '-z', '0.5'
            ],
            output='screen'
        ),

        # Robot State Publisher
        Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            parameters=[{'robot_description': robot_description}]
        ),

        # Gazebo-ROS 2 Bridge
        Node(
            package='ros_gz_bridge',
            executable='parameter_bridge',
            arguments=[
                '/clock@rosgraph_msgs/msg/Clock[gz.msgs.Clock',
                '/joint_states@sensor_msgs/msg/JointState[gz.msgs.Model'
            ],
            output='screen'
        )
    ])
```

**Launch Gazebo with Robot**:
```bash
cd ~/ros2_ws
colcon build --packages-select humanoid_description
source install/setup.bash

ros2 launch humanoid_description gazebo_spawn.launch.py
```

**Expected Result**:
- Gazebo window opens with empty world
- Humanoid arm spawns at (0, 0, 0.5)
- Robot falls due to gravity (no controllers yet)

### Step 4: Add Gazebo Plugins to URDF

**Enhanced URDF with Gazebo Tags**:

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid_arm">

  <!-- Existing URDF from M1-C3-S1 -->
  <xacro:include filename="$(find humanoid_description)/urdf/humanoid_arm.urdf.xacro"/>

  <!-- Gazebo-specific properties -->
  <gazebo reference="base_link">
    <material>Gazebo/Gray</material>
    <mu1>0.5</mu1>  <!-- Friction coefficient -->
    <mu2>0.5</mu2>
    <selfCollide>true</selfCollide>
  </gazebo>

  <gazebo reference="gripper_link">
    <material>Gazebo/Red</material>
    <mu1>1.0</mu1>  <!-- High friction for grasping -->
    <mu2>1.0</mu2>
  </gazebo>

  <!-- IMU Sensor Plugin -->
  <gazebo reference="imu_link">
    <sensor name="imu_sensor" type="imu">
      <always_on>true</always_on>
      <update_rate>100</update_rate>
      <imu>
        <angular_velocity>
          <x>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>0.01</stddev>
            </noise>
          </x>
          <y>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>0.01</stddev>
            </noise>
          </y>
          <z>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>0.01</stddev>
            </noise>
          </z>
        </angular_velocity>
        <linear_acceleration>
          <x>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>0.1</stddev>
            </noise>
          </x>
          <y>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>0.1</stddev>
            </noise>
          </y>
          <z>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>0.1</stddev>
            </noise>
          </z>
        </linear_acceleration>
      </imu>
      <plugin name="imu_plugin" filename="libgazebo_ros_imu_sensor.so">
        <ros>
          <namespace>/</namespace>
          <remapping>~/out:=/imu/data</remapping>
        </ros>
      </plugin>
    </sensor>
  </gazebo>

  <!-- Camera Sensor Plugin (RealSense simulation) -->
  <gazebo reference="camera_link">
    <sensor name="camera" type="camera">
      <update_rate>30</update_rate>
      <camera>
        <horizontal_fov>1.047</horizontal_fov>  <!-- 60Â° -->
        <image>
          <width>640</width>
          <height>480</height>
          <format>R8G8B8</format>
        </image>
        <clip>
          <near>0.1</near>
          <far>10.0</far>
        </clip>
        <noise>
          <type>gaussian</type>
          <mean>0.0</mean>
          <stddev>0.007</stddev>
        </noise>
      </camera>
      <plugin name="camera_plugin" filename="libgazebo_ros_camera.so">
        <ros>
          <namespace>/camera</namespace>
          <remapping>~/image_raw:=color/image_raw</remapping>
          <remapping>~/camera_info:=color/camera_info</remapping>
        </ros>
      </plugin>
    </sensor>
  </gazebo>

  <!-- Joint State Publisher Plugin -->
  <gazebo>
    <plugin name="joint_state_publisher" filename="libgazebo_ros_joint_state_publisher.so">
      <ros>
        <namespace>/</namespace>
        <remapping>~/out:=joint_states</remapping>
      </ros>
      <update_rate>100</update_rate>
    </plugin>
  </gazebo>

</robot>
```

### Step 5: Test Simulation

**Launch Gazebo with Sensors**:
```bash
ros2 launch humanoid_description gazebo_spawn.launch.py
```

**Verify ROS 2 Topics**:
```bash
# Check joint states
ros2 topic echo /joint_states

# Check IMU data
ros2 topic echo /imu/data

# Check camera
ros2 topic echo /camera/color/image_raw
```

**Expected Topics**:
```
/joint_states          (sensor_msgs/JointState, 100 Hz)
/imu/data              (sensor_msgs/Imu, 100 Hz)
/camera/color/image_raw (sensor_msgs/Image, 30 Hz)
/camera/color/camera_info (sensor_msgs/CameraInfo, 30 Hz)
```

---

## Gazebo Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    GAZEBO HARMONIC ARCHITECTURE                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  Gazebo Simulation                                                      â”‚
â”‚  â”œâ”€â”€ Physics Server (1000 Hz)                                           â”‚
â”‚  â”‚   â”œâ”€â”€ ODE/Bullet/DART engine                                         â”‚
â”‚  â”‚   â”œâ”€â”€ Collision detection                                            â”‚
â”‚  â”‚   â””â”€â”€ Constraint solver                                              â”‚
â”‚  â”œâ”€â”€ Rendering Server (30-60 Hz)                                        â”‚
â”‚  â”‚   â”œâ”€â”€ Ogre 2.3 renderer                                              â”‚
â”‚  â”‚   â””â”€â”€ GPU ray tracing (sensors)                                      â”‚
â”‚  â””â”€â”€ Sensor Manager                                                     â”‚
â”‚      â”œâ”€â”€ Camera plugins                                                 â”‚
â”‚      â”œâ”€â”€ IMU plugins                                                    â”‚
â”‚      â””â”€â”€ Depth/Lidar plugins                                            â”‚
â”‚                                                                         â”‚
â”‚            â†• (ros_gz_bridge)                                            â”‚
â”‚                                                                         â”‚
â”‚  ROS 2 Topics                                                           â”‚
â”‚  â”œâ”€â”€ /joint_states                                                      â”‚
â”‚  â”œâ”€â”€ /imu/data                                                          â”‚
â”‚  â””â”€â”€ /camera/image_raw                                                  â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Simulation Frequency**:
- Physics: 1000 Hz (1ms timestep)
- Rendering: 30-60 Hz
- Sensor updates: 10-100 Hz (configurable)

:::tip Elite Insight: Performance Optimization
**For faster-than-real-time simulation:**

1. **Headless mode** (no GUI): `gz sim -s world.sdf` â€” 2-5x faster
2. **Disable shadows**: Add `<cast_shadows>false</cast_shadows>` â€” 30% faster
3. **Reduce sensor resolution**: 320x240 vs 640x480 â€” 4x less compute
4. **Increase physics step size**: 2ms vs 1ms â€” 2x faster (less accurate)

**Benchmark on RTX 4070 Ti**:
| Configuration | RTF (Real-Time Factor) |
|---------------|------------------------|
| Full GUI + shadows | 1.5x |
| GUI, no shadows | 2.5x |
| Headless | 8x |
| Headless + 2ms step | 15x |
:::

---

## Summary

In this section, you learned:

| Concept | Key Takeaway |
|---------|--------------|
| **Digital Twins** | Simulation enables 80% of robotics development safely |
| **Gazebo Harmonic** | Open-source simulator with native ROS 2 support |
| **ros_gz_bridge** | Connects Gazebo topics to ROS 2 ecosystem |
| **URDF Plugins** | Add sensors and physics properties for simulation |
| **Architecture** | Physics (1kHz) + Rendering (30Hz) + Sensors (configurable) |

**Key Commands to Remember**:
```bash
# Launch Gazebo with demo world
gz sim shapes.sdf

# Install ros_gz bridge
sudo apt install ros-humble-ros-gz

# Run bridge with config file
ros2 run ros_gz_bridge parameter_bridge --ros-args -p config_file:=config.yaml

# Check Gazebo version
gz sim --version
```

---

## Practice Exercises

### Exercise 1: First Simulation (Beginner)
**Objective:** Verify Gazebo installation and run demo world
**Time:** ~15 minutes
**Skills Practiced:** Installation verification, basic Gazebo UI

1. Open terminal and run: `gz sim shapes.sdf`
2. Use mouse to orbit camera (right-click drag)
3. Click "Play" button (bottom left) to start physics
4. Observe objects falling due to gravity
5. Press "Reset" to restore initial positions

**Success Criteria:**
- [ ] Gazebo window opens without errors
- [ ] Objects fall when physics starts
- [ ] Can orbit camera with mouse

<details>
<summary>ğŸ’¡ Hint</summary>
If Gazebo crashes, try running with software rendering:
`LIBGL_ALWAYS_SOFTWARE=1 gz sim shapes.sdf`
</details>

---

### Exercise 2: Spawn Custom Robot (Intermediate)
**Objective:** Spawn your M1 humanoid URDF in Gazebo
**Time:** ~30 minutes
**Skills Practiced:** Launch files, URDF spawning, topic verification

1. Create the launch file from Step 3
2. Build your workspace: `colcon build`
3. Launch: `ros2 launch humanoid_description gazebo_spawn.launch.py`
4. Verify robot appears in Gazebo
5. Check ROS 2 topics: `ros2 topic list`

**Success Criteria:**
- [ ] Robot spawns at position (0, 0, 0.5)
- [ ] `/joint_states` topic is publishing
- [ ] TF tree shows robot links (`ros2 run tf2_tools view_frames`)

---

### Exercise 3: Multi-Robot Spawning (Advanced)
**Objective:** Spawn 3 robots with unique namespaces
**Time:** ~45 minutes
**Skills Practiced:** Namespacing, multi-robot patterns, bridge configuration

1. Modify launch file to spawn 3 robots at different positions
2. Each robot must have unique namespace (/robot1, /robot2, /robot3)
3. Configure bridge to map all robot topics
4. Verify all 3 robots have separate `/robotN/joint_states` topics

**Success Criteria:**
- [ ] 3 robots visible in Gazebo
- [ ] Topics properly namespaced
- [ ] No topic conflicts

<details>
<summary>ğŸ’¡ Hint</summary>
Use a Python loop in the launch file:
```python
robots = [
    {'name': 'robot1', 'x': 0.0, 'y': 0.0},
    {'name': 'robot2', 'x': 2.0, 'y': 0.0},
    {'name': 'robot3', 'x': 0.0, 'y': 2.0},
]
for robot in robots:
    # Add spawn node with namespace
```
</details>

---

### Exercise 4: Agentic AI Integration (Expert/Architect)
**Objective:** Design simulation-based action validation for an AI agent
**Time:** ~2 hours

**Scenario:** You're building an AI agent that can plan manipulation tasks. Before executing on real hardware, the agent should validate each action in simulation.

**Design Requirements:**
1. Python class that interfaces with Gazebo
2. Method to save/restore simulation state
3. Method to execute action and measure outcome
4. Method to run parallel simulations for Monte Carlo planning

**Deliverable:** Architecture diagram + implementation outline

**Considerations:**
- How many parallel simulations can run on your GPU?
- What's the latency for state save/restore?
- How do you handle simulation failures?

---

## Troubleshooting Guide

### Quick Fixes

| Symptom | Likely Cause | Quick Fix |
|---------|--------------|-----------|
| Black screen | GPU driver issue | `LIBGL_ALWAYS_SOFTWARE=1 gz sim` |
| "World not found" | Wrong path | Check path in launch file |
| Robot doesn't spawn | URDF errors | Run `check_urdf robot.urdf` |
| No ROS 2 topics | Bridge not running | Check `ros2 node list` for bridge |
| Slow simulation | Too many objects | Reduce complexity, disable shadows |

### Diagnostic Decision Tree

```
Gazebo won't start?
â”œâ”€â”€ Error message about OpenGL
â”‚   â”œâ”€â”€ Yes â†’ Run with LIBGL_ALWAYS_SOFTWARE=1
â”‚   â””â”€â”€ No â†’ Check nvidia-smi for GPU status
â””â”€â”€ No error but freezes
    â”œâ”€â”€ During "Loading world" â†’ Check world file path
    â””â”€â”€ After loading â†’ Reduce world complexity

Robot doesn't appear?
â”œâ”€â”€ Launch file errors
â”‚   â”œâ”€â”€ Yes â†’ Check xacro paths
â”‚   â””â”€â”€ No â†’ Check gz topic list for spawn status
â””â”€â”€ Robot spawns but falls through floor
    â””â”€â”€ Add ground plane to world file
```

---

## What's Next?

In the next section, **M2-C1-S2: Physics Engines and Simulation Parameters**, you will learn:

- How ODE, Bullet, and DART physics engines differ
- Tuning timestep, iterations, and solver parameters
- Benchmarking simulation performance
- Choosing the right engine for your application

This will enable you to optimize simulation accuracy and speed for your specific robotics tasks.

---

## Further Reading

### Official Documentation
- [Gazebo Harmonic Docs](https://gazebosim.org/docs/harmonic)
- [ros_gz_bridge Tutorial](https://gazebosim.org/docs/harmonic/ros2_integration)
- [SDF Specification](http://sdformat.org/spec)

### Research Papers
- "Sim-to-Real Robot Learning from Pixels with Progressive Nets" (Rusu et al., 2017)
- "Domain Randomization for Transferring Deep Neural Networks" (Tobin et al., 2017)

### Industry Resources
- [AWS RoboMaker](https://aws.amazon.com/robomaker/) - Cloud simulation at scale
- [NVIDIA Isaac Sim](https://developer.nvidia.com/isaac-sim) - GPU-accelerated simulation

:::info Industry Insight
**The future of robotics development is simulation-first.** Companies like Tesla, Boston Dynamics, and Amazon run millions of simulation hours for every hour of real robot testing. Mastering Gazebo is your entry point to this workflow.
:::

---

**Assessment Preparation**: This section prepares for **Assessment 3: Simulation and Sim-to-Real (Week 9)**. You must demonstrate spawning robots in Gazebo and bridging sensor data to ROS 2.
