---
id: m2-c1-s4
title: Contact Forces and Collision Properties
sidebar_position: 4
keywords: ['contact', 'collision', 'forces', 'friction', 'ode', 'constraint-solver']
---

# Contact Forces and Collision Properties

## Overview

**Contact forces** are the foundation of physical interactionâ€”they determine whether a gripper successfully grasps an object, whether a bipedal robot slips on a surface, or whether stacked objects remain stable. Gazebo simulates contacts using **constraint solvers** that compute normal forces, friction forces, and penetration corrections at every physics timestep. Understanding contact parameters (stiffness, damping, friction coefficients, bounce) is critical for realistic sim-to-real transfer and stable manipulation.

**What You'll Build**: A comprehensive contact physics system with tuned collision properties for different materials (rubber, metal, wood), contact force visualization, grasp stability analysis, and debugging tools for contact-related instability.

## Prerequisites

Before starting this section, ensure you have:

- **Completed [M2-C1-S2](./S2.md)**: Physics engine configuration and solver tuning
- **Completed [M2-C1-S3](./S3.md)**: World file creation with objects
- **Understanding of force vectors**: Normal and tangential forces
- **ROS 2 Kilted Kaiju workspace**: With Gazebo Ionic integration
- **Python 3.11+**: With numpy and scipy for grasp analysis

**Hardware Requirements**:
- 16-core CPU for real-time contact simulation (2025 Baseline)
- NVIDIA RTX 5080/6080 (16GB+ VRAM) for 2025-standard contact-rich GPU physics

## Learning Objectives

By the end of this section, you will be able to:

- **[Beginner]** Explain friction coefficients and contact stiffness parameters
- **[Beginner]** Configure basic contact properties in SDF for different materials
- **[Intermediate]** Implement contact sensors and process contact force data
- **[Intermediate]** Visualize contact points and force vectors in RViz2
- **[Advanced]** Analyze grasp stability using force closure theory
- **[Advanced]** Debug contact instabilities (jitter, penetration, slip)
- **[Expert]** Design contact configurations for complex manipulation tasks

## Key Concepts

| Term | Definition | Why It Matters |
|------|------------|----------------|
| **Friction Coefficient (Î¼)** | Ratio of friction force to normal force | Determines slip resistance |
| **Contact Stiffness (kp)** | Spring constant for contact forces (N/m) | Controls surface hardness |
| **Contact Damping (kd)** | Damping coefficient (NÂ·s/m) | Prevents bouncing |
| **Normal Force** | Force perpendicular to contact surface | Primary grasping force |
| **Tangential Force** | Force parallel to contact surface | Causes slip if exceeds Î¼Ã—N |
| **Force Closure** | Condition where contacts can resist any external wrench | Grasp stability criterion |
| **Friction Cone** | Region of valid friction forces (angle = arctan(Î¼)) | Geometric grasp analysis |

:::danger Latency Trap Warning
**Contact force feedback must be processed locally.** Grasp control loops require sub-10ms latency. Network delays from cloud-based force processing cause grasp failures:
- Process force sensor data on Jetson/workstation directly connected to hardware
- Never stream raw force data over WiFi during active grasping
- Use local TensorRT models for grasp prediction
:::

## Skill-Level Pathways

:::note For Beginners
If you're new to contact physics, focus on:
1. Understanding the **Contact Parameter Reference** table
2. Configuring basic friction for gripper-object contacts
3. Observing contact forces in Gazebo GUI
4. Completing **Exercise 1** to verify contact setup

**Skip on first read**: Force closure analysis, grasp quality metrics, anisotropic friction
:::

:::tip Intermediate Path
If you have physics simulation experience:
1. Implement the **Contact Force Analyzer** node
2. Visualize contacts in RViz2 using markers
3. Tune contact parameters for stable grasping
4. Complete **Exercises 1-2**
:::

:::caution Advanced Path
For production manipulation systems:
1. Master force closure and grasp quality analysis
2. Implement task-specific contact configurations
3. Debug complex contact instabilities
4. Complete **Exercise 3** and attempt the **Architect Challenge**
:::

---

## Industry Perspectives

:::info Industry Spotlight: Shadow Robot (Dexterous Hands)
**How Shadow Robot uses contact simulation:**
Shadow's dexterous hands have 20+ contact points per grasp. They simulate tactile sensor arrays with 0.1mm resolution and force sensitivity down to 0.01N. Contact modeling is critical for in-hand manipulation training.

**Key metrics they care about:**
- **Contact accuracy**: &lt;1mm positional error
- **Force resolution**: 0.01N sensitivity
- **Slip detection**: &lt;10ms response time

**Lessons learned:**
For dexterous manipulation, contact *distribution* matters more than total contact force. Simulate many small contacts, not few large ones.
:::

:::info Industry Spotlight: FANUC Industrial Grippers
**How FANUC uses contact simulation:**
FANUC's parallel grippers use contact force feedback for adaptive grasping. They simulate gripper-object contact with calibrated friction coefficients matched to real rubber fingertips.

**Key metrics they care about:**
- **Cycle time**: Contact detection &lt;50ms
- **Grip force**: Â±5% accuracy vs. real
- **Reliability**: 99.99% grasp success in sim â†’ 99.9% in real

**Lessons learned:**
Industrial applications prioritize *repeatability* over complexity. Simple contact models with well-calibrated parameters outperform complex models with uncertain parameters.
:::

:::info Industry Spotlight: Intuitive Surgical (da Vinci)
**How Intuitive Surgical uses contact simulation:**
Surgical robots require sub-Newton force accuracy for tissue manipulation. They use custom contact models validated against tissue mechanics studies.

**Key metrics they care about:**
- **Force accuracy**: &lt;0.05N error
- **Tissue deformation**: Validated FEM models
- **Safety margins**: 3x safety factor on max forces

**Lessons learned:**
Medical robotics requires *physics accuracy* over simulation speed. They accept 0.1x real-time if it means accurate tissue contact modeling.
:::

---

## Hardware Requirements

**Workstation** (from M1-C1-S1)
- Ubuntu 24.04 LTS
- NVIDIA RTX 5080/6080 (16GB+ VRAM) for 2025-standard GPU physics
- ROS 2 Kilted Kaiju + Gazebo Ionic (M2-C1-S1)
- 16-core CPU minimum for multi-robot parallelism

## Connection to Capstone

The capstone uses contact forces for:

1. **Grasping**: Friction between gripper and object determines grasp success (force closure analysis)
2. **Manipulation**: Contact stability during object placement (stacking, insertion tasks)
3. **Locomotion**: Ground contact forces enable bipedal walking (prevent foot slip)
4. **Collision Avoidance**: Detect unintended contacts during motion execution
5. **Force-Controlled Tasks**: Assembly tasks requiring specific normal forces (press-fit, wiping)

**Critical Parameters**:
- **Friction (Î¼)**: Gripper rubber: 1.5, Steel: 0.4, Ice: 0.05
- **Stiffness (kp)**: Steel: 1e8 N/m, Rubber: 1e5 N/m
- **Damping (kd)**: Prevents bouncing, typical: 1.0-10.0 NÂ·s/m

## Implementation

### Step 1: Contact Properties in SDF

**Material-Specific Contacts**:

```xml
<!-- Gripper Finger (Rubber) -->
<link name="gripper_finger">
  <collision name="collision">
    <geometry>
      <box>
        <size>0.02 0.05 0.08</size>
      </box>
    </geometry>
    <surface>
      <friction>
        <ode>
          <mu>1.5</mu>    <!-- High friction for grasping -->
          <mu2>1.5</mu2>
        </ode>
      </friction>
      <contact>
        <ode>
          <kp>1e6</kp>    <!-- Compliant (rubber) -->
          <kd>10.0</kd>   <!-- High damping -->
          <max_vel>0.01</max_vel>
          <min_depth>0.0</min_depth>
        </ode>
      </contact>
      <bounce>
        <restitution_coefficient>0.0</restitution_coefficient>
        <threshold>0.01</threshold>
      </bounce>
    </surface>
  </collision>
</link>

<!-- Metal Table Surface -->
<link name="table_top">
  <collision name="collision">
    <geometry>
      <box>
        <size>1.5 0.8 0.05</size>
      </box>
    </geometry>
    <surface>
      <friction>
        <ode>
          <mu>0.4</mu>    <!-- Low friction (metal) -->
          <mu2>0.4</mu2>
        </ode>
      </friction>
      <contact>
        <ode>
          <kp>1e8</kp>    <!-- Stiff (steel) -->
          <kd>1.0</kd>
          <max_vel>0.01</max_vel>
          <min_depth>0.0</min_depth>
        </ode>
      </contact>
      <bounce>
        <restitution_coefficient>0.1</restitution_coefficient>
        <threshold>0.01</threshold>
      </bounce>
    </surface>
  </collision>
</link>

<!-- Wooden Block -->
<link name="block">
  <collision name="collision">
    <geometry>
      <box>
        <size>0.1 0.1 0.1</size>
      </box>
    </geometry>
    <surface>
      <friction>
        <ode>
          <mu>0.6</mu>    <!-- Medium friction (wood) -->
          <mu2>0.6</mu2>
          <slip1>0.0</slip1>
          <slip2>0.0</slip2>
        </ode>
      </friction>
      <contact>
        <ode>
          <kp>5e7</kp>    <!-- Medium stiffness (wood) -->
          <kd>5.0</kd>
          <max_vel>0.01</max_vel>
          <min_depth>0.001</min_depth>
        </ode>
      </contact>
      <bounce>
        <restitution_coefficient>0.2</restitution_coefficient>
        <threshold>0.01</threshold>
      </bounce>
    </surface>
  </collision>
</link>
```

**Contact Parameter Reference**:

| Parameter | Description | Typical Values |
|-----------|-------------|----------------|
| **mu** | Coefficient of friction (Coulomb) | Rubber: 1.0-2.0, Steel: 0.3-0.5, Ice: 0.02-0.1 |
| **mu2** | Secondary friction direction | Usually same as mu |
| **slip1/slip2** | Force-dependent slip (advanced) | 0.0 (no slip), 0.01 (slight slip) |
| **kp** | Contact stiffness (N/m) | Steel: 1e8, Plastic: 1e6, Foam: 1e4 |
| **kd** | Contact damping (NÂ·s/m) | 0.1-10.0 (higher = less bounce) |
| **max_vel** | Max penetration correction velocity | 0.01 m/s (prevents instability) |
| **min_depth** | Penetration threshold for contact | 0.0-0.001 m |
| **restitution_coefficient** | Bounce (0=no bounce, 1=perfect) | Wood: 0.2, Rubber: 0.5, Steel ball: 0.9 |

### Step 2: Contact Force Visualization

**Gazebo Contact Plugin**:

```xml
<plugin filename="gz-sim-contact-system" name="gz::sim::systems::Contact">
  <contact_sensor_name>gripper_contact</contact_sensor_name>
</plugin>
```

**Contact Sensor in URDF**:

```xml
<gazebo reference="gripper_link">
  <sensor name="gripper_contact" type="contact">
    <update_rate>100</update_rate>
    <contact>
      <collision>gripper_link_collision</collision>
    </contact>
    <plugin name="contact_plugin" filename="libgazebo_ros_bumper.so">
      <ros>
        <remapping>~/out:=/gripper/contact</remapping>
      </ros>
    </plugin>
  </sensor>
</gazebo>
```

**Contact Force Processing**:

```python
#!/usr/bin/env python3
"""
Contact Force Analyzer
Processes contact sensor data and computes forces
"""

import rclpy
from rclpy.node import Node
from gazebo_msgs.msg import ContactsState
import numpy as np

class ContactForceAnalyzer(Node):
    def __init__(self):
        super().__init__('contact_force_analyzer')

        # Subscribe to contact sensor
        self.contact_sub = self.create_subscription(
            ContactsState,
            '/gripper/contact',
            self.contact_callback,
            10
        )

        # Force threshold for grasp detection
        self.grasp_force_threshold = 5.0  # Newtons

        self.get_logger().info('Contact force analyzer started')

    def contact_callback(self, msg):
        """Process contact states"""
        if len(msg.states) == 0:
            # No contact
            return

        # Analyze each contact
        total_normal_force = 0.0
        total_tangential_force = 0.0

        for contact in msg.states:
            # Contact info
            collision1 = contact.collision1_name
            collision2 = contact.collision2_name

            # Compute total forces from all contact points
            for wrench in contact.wrenches:
                # Normal force (assume z-direction for simplicity)
                normal_force = abs(wrench.force.z)
                total_normal_force += normal_force

                # Tangential force (x-y plane)
                tangential_force = np.sqrt(wrench.force.x**2 + wrench.force.y**2)
                total_tangential_force += tangential_force

        # Check grasp conditions
        if total_normal_force > self.grasp_force_threshold:
            # Check force closure (normal > tangential/mu)
            mu = 1.5  # Gripper friction coefficient
            if total_normal_force * mu > total_tangential_force:
                self.get_logger().info(
                    f'âœ“ Stable grasp: Normal={total_normal_force:.2f}N, '
                    f'Tangential={total_tangential_force:.2f}N'
                )
            else:
                self.get_logger().warn(
                    f'âš  Unstable grasp: slip likely! '
                    f'Normal={total_normal_force:.2f}N, '
                    f'Tangential={total_tangential_force:.2f}N'
                )


def main(args=None):
    rclpy.init(args=args)
    node = ContactForceAnalyzer()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Step 3: Friction Cone and Force Closure

**Grasp Stability Analysis**:

```python
import numpy as np
from scipy.spatial import ConvexHull

class GraspStabilityChecker:
    def __init__(self, friction_coefficient=1.0):
        self.mu = friction_coefficient

    def check_force_closure(self, contact_points, contact_normals):
        """
        Check if contact points satisfy force closure condition

        Args:
            contact_points: Nx3 array of contact positions
            contact_normals: Nx3 array of contact normal vectors

        Returns:
            bool: True if force closure is satisfied
        """
        n_contacts = len(contact_points)
        if n_contacts < 3:
            return False  # Need at least 3 contacts

        # Compute friction cones
        # For each contact, friction cone allows forces within angle arctan(mu)
        friction_cones = []
        for i in range(n_contacts):
            normal = contact_normals[i]
            # Discretize friction cone with 8 rays
            angles = np.linspace(0, 2*np.pi, 8, endpoint=False)
            for angle in angles:
                # Rotate around normal
                tangent1 = np.array([-normal[1], normal[0], 0])
                tangent1 = tangent1 / (np.linalg.norm(tangent1) + 1e-6)
                tangent2 = np.cross(normal, tangent1)

                # Force direction within cone
                force = (normal +
                         self.mu * (np.cos(angle) * tangent1 + np.sin(angle) * tangent2))
                force = force / np.linalg.norm(force)
                friction_cones.append(force)

        friction_cones = np.array(friction_cones)

        # Check if origin is inside convex hull of friction cone
        try:
            hull = ConvexHull(friction_cones)
            # If origin is strictly inside, force closure is satisfied
            # Simplified check: if we can create zero net wrench
            return True
        except:
            return False

    def compute_grasp_quality(self, contact_points, contact_normals):
        """
        Compute grasp quality metric (0-1)

        Higher is better
        """
        if not self.check_force_closure(contact_points, contact_normals):
            return 0.0

        # Quality = minimum singular value of grasp matrix
        G = self.compute_grasp_matrix(contact_points, contact_normals)
        U, S, Vt = np.linalg.svd(G)
        quality = np.min(S)

        return quality

    def compute_grasp_matrix(self, contact_points, contact_normals):
        """
        Compute grasp matrix G where G*f = w (wrench)

        Args:
            contact_points: Nx3 array
            contact_normals: Nx3 array

        Returns:
            6xN grasp matrix
        """
        n_contacts = len(contact_points)
        G = np.zeros((6, n_contacts))

        for i in range(n_contacts):
            p = contact_points[i]
            n = contact_normals[i]

            # Force component
            G[0:3, i] = n

            # Torque component (r x f)
            G[3:6, i] = np.cross(p, n)

        return G


# Usage example
checker = GraspStabilityChecker(friction_coefficient=1.5)

contact_points = np.array([
    [0.05, 0.0, 0.0],   # Right finger
    [-0.05, 0.0, 0.0],  # Left finger
    [0.0, 0.05, 0.0],   # Bottom support
])

contact_normals = np.array([
    [-1, 0, 0],  # Point inward
    [1, 0, 0],
    [0, -1, 0],
])

is_stable = checker.check_force_closure(contact_points, contact_normals)
quality = checker.compute_grasp_quality(contact_points, contact_normals)

print(f'Force closure: {is_stable}')
print(f'Grasp quality: {quality:.4f}')
```

### Step 4: Contact Debugging Tools

**Visualize Contact Points in RViz2**:

```python
#!/usr/bin/env python3
"""
Contact Visualizer
Publish contact points as markers for RViz2
"""

import rclpy
from rclpy.node import Node
from gazebo_msgs.msg import ContactsState
from visualization_msgs.msg import Marker, MarkerArray
from geometry_msgs.msg import Point

class ContactVisualizer(Node):
    def __init__(self):
        super().__init__('contact_visualizer')

        # Subscribe to contacts
        self.contact_sub = self.create_subscription(
            ContactsState,
            '/gripper/contact',
            self.contact_callback,
            10
        )

        # Publish markers
        self.marker_pub = self.create_publisher(
            MarkerArray,
            '/contact_markers',
            10
        )

        self.get_logger().info('Contact visualizer started')

    def contact_callback(self, msg):
        """Visualize contact points and normal forces"""
        marker_array = MarkerArray()

        marker_id = 0
        for contact in msg.states:
            for i, wrench in enumerate(contact.wrenches):
                # Contact point marker (sphere)
                marker = Marker()
                marker.header.frame_id = 'world'
                marker.header.stamp = self.get_clock().now().to_msg()
                marker.ns = 'contact_points'
                marker.id = marker_id
                marker.type = Marker.SPHERE
                marker.action = Marker.ADD

                # Position
                marker.pose.position = contact.contact_positions[i]
                marker.pose.orientation.w = 1.0

                # Size
                marker.scale.x = 0.01
                marker.scale.y = 0.01
                marker.scale.z = 0.01

                # Color (red)
                marker.color.r = 1.0
                marker.color.a = 1.0

                # Lifetime
                marker.lifetime.sec = 0
                marker.lifetime.nanosec = int(0.1 * 1e9)  # 100ms

                marker_array.markers.append(marker)
                marker_id += 1

                # Normal force arrow
                arrow = Marker()
                arrow.header = marker.header
                arrow.ns = 'normal_forces'
                arrow.id = marker_id
                arrow.type = Marker.ARROW
                arrow.action = Marker.ADD

                # Arrow from contact point along normal
                start = Point()
                start.x = contact.contact_positions[i].x
                start.y = contact.contact_positions[i].y
                start.z = contact.contact_positions[i].z

                # Scale by force magnitude
                force_magnitude = (wrench.force.x**2 +
                                   wrench.force.y**2 +
                                   wrench.force.z**2)**0.5
                scale = 0.01 * force_magnitude

                end = Point()
                end.x = start.x + scale * contact.contact_normals[i].x
                end.y = start.y + scale * contact.contact_normals[i].y
                end.z = start.z + scale * contact.contact_normals[i].z

                arrow.points = [start, end]

                # Arrow style
                arrow.scale.x = 0.005  # Shaft diameter
                arrow.scale.y = 0.01   # Head diameter
                arrow.scale.z = 0.01   # Head length

                # Color (green)
                arrow.color.g = 1.0
                arrow.color.a = 1.0

                arrow.lifetime = marker.lifetime

                marker_array.markers.append(arrow)
                marker_id += 1

        # Publish
        self.marker_pub.publish(marker_array)


def main(args=None):
    rclpy.init(args=args)
    node = ContactVisualizer()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Step 5: Contact Tuning for Specific Tasks

**Task-Specific Contact Configurations**:

**1. Pick-and-Place (Rigid Grasping)**:
```xml
<surface>
  <friction>
    <ode>
      <mu>1.5</mu>      <!-- High friction -->
      <mu2>1.5</mu2>
    </ode>
  </friction>
  <contact>
    <ode>
      <kp>1e7</kp>      <!-- Medium stiffness -->
      <kd>100.0</kd>    <!-- High damping (no bounce) -->
      <max_vel>0.001</max_vel>
    </ode>
  </contact>
</surface>
```

**2. In-Hand Manipulation (Finger Rolling)**:
```xml
<surface>
  <friction>
    <ode>
      <mu>0.8</mu>      <!-- Lower friction for rolling -->
      <mu2>0.8</mu2>
      <slip1>0.01</slip1>  <!-- Allow controlled slip -->
    </ode>
  </friction>
  <contact>
    <ode>
      <kp>1e6</kp>      <!-- Compliant -->
      <kd>50.0</kd>
    </ode>
  </contact>
</surface>
```

**3. Bipedal Walking (Foot-Ground Contact)**:
```xml
<surface>
  <friction>
    <ode>
      <mu>0.9</mu>      <!-- Prevent slip -->
      <mu2>0.9</mu2>
    </ode>
  </friction>
  <contact>
    <ode>
      <kp>1e8</kp>      <!-- Very stiff (ground) -->
      <kd>10.0</kd>
      <max_vel>0.01</max_vel>
    </ode>
  </contact>
</surface>
```

### Step 6: Advanced Contact Features

**Anisotropic Friction** (different friction in two directions):

```xml
<surface>
  <friction>
    <ode>
      <mu>1.0</mu>     <!-- Friction in x-direction -->
      <mu2>0.5</mu2>   <!-- Friction in y-direction (sliding easier) -->
      <fdir1>1 0 0</fdir1>  <!-- Primary friction direction -->
    </ode>
  </friction>
</surface>
```

**Soft Contact Layer** (penetration tolerance):

```xml
<surface>
  <contact>
    <ode>
      <soft_cfm>0.01</soft_cfm>  <!-- Constraint Force Mixing -->
      <soft_erp>0.2</soft_erp>   <!-- Error Reduction Parameter -->
      <kp>1e5</kp>
      <kd>1.0</kd>
    </ode>
  </contact>
</surface>
```

## Contact Simulation Best Practices

**Stability Guidelines**:
1. **Timestep**: Use â‰¤1ms for contact-rich tasks (see M2-C1-S2)
2. **Solver Iterations**: 50-100 for stable contacts
3. **Stiffness**: Don't exceed 1e8 (causes jitter)
4. **Damping**: Start at 10.0, reduce if too sticky
5. **Max Velocity**: 0.01 m/s prevents penetration explosion

**Debugging Contacts**:
```bash
# Visualize contact points in Gazebo
gz topic -e -t /world/default/contacts

# Monitor contact forces
ros2 topic echo /gripper/contact

# Check for penetration
gz topic -e -t /world/default/penetration
```

**Common Issues**:

| Issue | Symptom | Solution |
|-------|---------|----------|
| **Objects vibrate** | High-frequency jitter | Increase damping (kd), reduce stiffness (kp) |
| **Objects sink through** | Penetration | Reduce timestep, increase solver iterations |
| **No friction** | Objects slide | Check mu>0, verify collision geometry overlap |
| **Excessive bounce** | Objects keep bouncing | Set restitution_coefficient=0, increase damping |
| **Simulation slow** | Low FPS | Reduce contact points, simplify collision geometry |

---

## Agentic AI Integration

:::warning Agentic AI Consideration
**For autonomous manipulation systems:**

Contact forces are the primary feedback for robotic grasping and manipulation:

**Contact-Aware Planning Loop:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 AI Manipulation Agent                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. Perceive object â†’ Estimate grasp candidates         â”‚
â”‚  2. For each candidate:                                  â”‚
â”‚     - Predict contact points                            â”‚
â”‚     - Compute expected forces                           â”‚
â”‚     - Check force closure                               â”‚
â”‚  3. Select best grasp â†’ Execute                         â”‚
â”‚  4. Monitor contact forces â†’ Detect slip/failure        â”‚
â”‚  5. Adapt grip force in real-time                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Agentic Patterns:**

1. **Grasp Planning with Contact Prediction**
   ```python
   class ContactAwareGraspPlanner:
       """AI agent that reasons about contact for grasp planning"""

       def predict_grasp_outcome(self, grasp: GraspCandidate) -> GraspPrediction:
           """Predict contact result before execution"""
           contacts = self.contact_model.predict_contacts(grasp)
           forces = self.force_model.predict_forces(contacts)
           stability = self.check_force_closure(contacts, forces)
           return GraspPrediction(
               success_prob=stability.quality,
               slip_risk=self.compute_slip_risk(forces),
               required_force=self.compute_min_force(contacts)
           )

       def adapt_grip_force(self, current_force: float, slip_detected: bool):
           """Real-time force adaptation based on contact feedback"""
           if slip_detected:
               return min(current_force * 1.2, self.max_force)
           return current_force
   ```

2. **Contact-Based Task Verification**
   ```python
   def verify_grasp_success(contact_state: ContactState) -> bool:
       """AI agent verifies grasp through contact feedback"""
       # Check minimum contact points
       if contact_state.num_contacts < 2:
           return False
       # Check force closure
       if not contact_state.force_closure:
           return False
       # Check for slip
       if contact_state.tangential_force > contact_state.friction_limit:
           return False
       return True
   ```

3. **Learning Contact Models from Experience**
4. **Tactile-Guided Manipulation for Occluded Objects**

**LLM/Agent Interface Pattern:**
```python
class ContactInterface:
    """Interface for LLM agents to query contact state"""

    def get_grasp_status(self) -> str:
        """Natural language grasp status for LLM reasoning"""
        return f"""
        Grasp Status: {'STABLE' if self.force_closure else 'UNSTABLE'}
        Contact Points: {self.num_contacts}
        Normal Force: {self.normal_force:.1f}N
        Slip Margin: {self.slip_margin:.0%}
        Recommendation: {'Maintain grip' if self.stable else 'Increase force by 20%'}
        """

    def should_increase_force(self) -> tuple[bool, str]:
        """Decision support for force adjustment"""
        if self.slip_margin < 0.2:
            return True, "Slip risk high, recommend force increase"
        return False, "Grasp stable"
```

**Safety Constraints for Autonomous Operation:**
- **Never** exceed object-specific max force (prevent crushing)
- **Always** monitor slip detection during manipulation
- **Require** human approval for forces &gt;50N on unknown objects
- **Log** all contact events for grasp failure analysis
:::

:::tip Elite Insight: Learning Contact Models
State-of-the-art manipulation uses **learned contact models** that predict contact outcomes from visual input:

1. **Contact prediction networks**: CNN predicts contact points from RGB-D
2. **Force estimation**: Predict grasp forces from visual features
3. **Tactile simulation**: Generate synthetic tactile images for training

The trend is toward "imagination-based grasping"â€”agents that simulate contacts mentally before physical execution.
:::

---

## Practice Exercises

### Exercise 1: Foundation (Beginner)
**Objective:** Configure contact properties and observe friction effects

**Time:** ~20 minutes

**Skills Practiced:** SDF contact configuration, friction coefficients

**Instructions:**
1. Create a simple world with a tilted plane and a box
2. Configure the box with different friction coefficients
3. Observe when the box starts sliding (critical angle)
4. Verify friction using: Î¼ = tan(Î¸) at slip angle

**Success Criteria:**
- [ ] Box stays stationary on plane at Î¸ &lt; arctan(Î¼)
- [ ] Box slides when Î¸ &gt; arctan(Î¼)
- [ ] Verified for Î¼ = 0.3, 0.6, 1.0

<details>
<summary>ðŸ’¡ Hint</summary>
For Î¼ = 0.6, the critical angle is arctan(0.6) â‰ˆ 31Â°. Tilt the plane to 30Â° (stable) and 35Â° (sliding).
</details>

---

### Exercise 2: Contact Visualization (Intermediate)
**Objective:** Implement contact force visualization in RViz2

**Time:** ~30 minutes

**Skills Practiced:** ROS 2 markers, contact sensor processing

**Instructions:**
1. Add contact sensor to a gripper model
2. Implement the ContactVisualizer node from Step 4
3. Display contact points as spheres and forces as arrows
4. Verify visualization updates at 10Hz

**Success Criteria:**
- [ ] Contact points appear as red spheres
- [ ] Force arrows scale with force magnitude
- [ ] Visualization updates in real-time
- [ ] Markers disappear when contact breaks

---

### Exercise 3: Grasp Stability Analysis (Advanced)
**Objective:** Implement force closure analysis for grasp evaluation

**Time:** ~60 minutes

**Skills Practiced:** Grasp mechanics, linear algebra, optimization

**Scenario:** Implement a grasp quality evaluator that:
- Computes force closure for arbitrary contact configurations
- Calculates grasp quality metric (min singular value)
- Identifies unstable grasp directions

**Requirements:**
1. Implement GraspStabilityChecker from Step 3
2. Test with 2-finger, 3-finger, and 5-finger grasps
3. Visualize friction cones in 3D
4. Identify the weakest grasp direction

**Constraints:**
- Must handle arbitrary contact configurations
- Must work with different friction coefficients
- Must run in &lt;10ms for real-time use

---

### Exercise 4: Architect's Design Challenge (Expert)
**Objective:** Design a contact-rich manipulation pipeline for bin picking

**Time:** ~2+ hours (can be ongoing)

**Scenario:** Design the contact modeling system for a bin picking robot that:
- Picks 100+ unique objects from a cluttered bin
- Handles objects with unknown friction (must adapt)
- Achieves 99.5% grasp success rate
- Operates at 10 picks per minute

**Design Requirements:**
1. Contact model architecture (learned vs. analytical)
2. Force sensing and feedback loop design
3. Slip detection and recovery strategy
4. Object-specific contact parameter database

**Deliverables:**
- Architecture diagram for contact pipeline
- Contact model selection rationale
- Performance analysis (latency, accuracy)
- Failure mode analysis and recovery strategies

---

## Enhanced Troubleshooting Guide

### Quick Fixes

| Symptom | Likely Cause | Quick Fix |
|---------|--------------|-----------|
| Objects vibrate at contact | kp too high | Reduce kp by 10x |
| Objects sink through surface | Timestep too large | Reduce to 0.001s |
| No friction (sliding) | Î¼ = 0 | Set mu and mu2 &gt; 0 |
| Excessive bouncing | Low damping | Increase kd to 10+ |
| Contact sensor no data | Collision mismatch | Verify collision name |

### Diagnostic Decision Tree

```
Grasp failing?
â”œâ”€â”€ Object slipping?
â”‚   â”œâ”€â”€ Check friction: Is Î¼ > 0.5?
â”‚   â”‚   â”œâ”€â”€ Yes â†’ Check normal force (increase grip force)
â”‚   â”‚   â””â”€â”€ No â†’ Increase friction coefficient
â”‚   â””â”€â”€ Check tangential force / (Î¼ Ã— normal)
â”‚       â”œâ”€â”€ Ratio > 1 â†’ Unstable, reposition gripper
â”‚       â””â”€â”€ Ratio < 0.8 â†’ Stable, other issue
â”œâ”€â”€ Object vibrating?
â”‚   â”œâ”€â”€ Reduce contact stiffness (kp)
â”‚   â””â”€â”€ Increase damping (kd)
â””â”€â”€ No contact detected?
    â”œâ”€â”€ Check collision geometry overlap
    â””â”€â”€ Verify sensor configuration
```

### Deep Dive: Contact Jitter

**Symptoms:**
- High-frequency vibration at contact points
- Audible buzzing in real robot
- Unstable force readings

**Root Causes:**
1. **Contact stiffness too high** - Probability: High
2. **Damping too low** - Probability: High
3. **Timestep too large** - Probability: Medium
4. **Solver iterations too low** - Probability: Medium

**Diagnosis Steps:**
```bash
# Step 1: Check contact parameters
gz model -m <model_name> -p
# Look for: kp > 1e8 (too high)

# Step 2: Monitor contact forces
ros2 topic hz /gripper/contact
# Look for: high-frequency updates with varying forces

# Step 3: Check physics stats
gz topic -e -t /stats
# Look for: solver warnings, penetration errors
```

**Solutions:**
- **If Cause 1:** Reduce kp by 10x (try 1e6 instead of 1e7)
- **If Cause 2:** Increase kd to 10.0 or higher
- **If Cause 3:** Reduce timestep to 0.001s
- **If Cause 4:** Increase solver iterations to 50+

---

## Summary

### Key Commands Reference

```bash
# Monitor contact forces
gz topic -e -t /world/default/contacts

# Echo contact sensor data
ros2 topic echo /gripper/contact

# Visualize in RViz2
ros2 run rviz2 rviz2 -d contact_viz.rviz

# Check contact parameters
gz model -m <model_name> -p | grep -A20 surface
```

### Contact Parameter Quick Reference

| Material | Î¼ | kp (N/m) | kd (NÂ·s/m) | Restitution |
|----------|---|----------|------------|-------------|
| Rubber gripper | 1.5 | 1e6 | 10.0 | 0.0 |
| Metal surface | 0.4 | 1e8 | 1.0 | 0.1 |
| Wood | 0.6 | 5e7 | 5.0 | 0.2 |
| Plastic | 0.3 | 1e6 | 2.0 | 0.3 |
| Glass | 0.2 | 1e8 | 1.0 | 0.1 |

### Contact Configuration Checklist

Before deploying contact configuration:
- [ ] Friction coefficients calibrated to real materials
- [ ] Stiffness/damping tuned for stability
- [ ] Contact sensors publishing at expected rate
- [ ] Force closure verified for target grasps
- [ ] Jitter/vibration eliminated
- [ ] Slip detection tested and working

## Next Steps

With contact forces mastered, proceed to:
- **M2-C1-S5**: Friction Models (advanced friction, torsional friction, rolling resistance)
- **M2-C1-S6**: Joint Controllers (PID, impedance, force control in simulation)
- **M2-C1-S7**: ROS 2-Gazebo Bridge (complete integration)

**Troubleshooting**:
- **Contact sensor no data**: Check collision name matches, ensure update_rate&gt;0
- **Force closure fails**: Check normal directions point inward, verify mu value
- **Grasp unstable in sim but stable in real**: Increase sim friction, reduce stiffness
- **RViz markers not showing**: Verify frame_id matches TF tree

**Real-World Contact Applications**:
- **Amazon Robotics**: Suction gripper contact detection (50N threshold)
- **Boston Dynamics (Spot)**: Foot contact sensors for terrain adaptation
- **Tesla (Optimus)**: Force-torque sensors in wrists (contact-rich assembly)

---

**Assessment Preparation**: This section prepares for **Assessment 3: Simulation and Sim-to-Real (Week 9)**. You must demonstrate contact force analysis, grasp stability checking, and contact parameter tuning for different materials.
