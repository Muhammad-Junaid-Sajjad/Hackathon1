---
id: m2-c1-s7
title: ROS 2-Gazebo Bridge
sidebar_position: 7
keywords: ['gazebo-ros', 'bridge', 'integration', 'middleware', 'topic-mapping', 'ros_gz']
---

# ROS 2-Gazebo Bridge

## Overview

**ros_gz_bridge** connects Gazebo Ionic to the ROS 2 ecosystem, translating Gazebo topics to and from ROS 2 topics and enabling seamless integration between simulation and ROS 2 nodes. The bridge handles message type conversion (e.g., `gz.msgs.Image` to `sensor_msgs/msg/Image`), topic remapping, and bidirectional communication. This section completes Module 2 Chapter 1 by integrating all previous concepts (physics, worlds, contacts, friction, controllers) into a unified ROS 2-Gazebo system.

**What You'll Build**: A complete ROS 2-Gazebo integration with topic bridges for sensors (camera, IMU, lidar), actuators (joint commands), TF transformations, and a full launch system that brings up Gazebo + ROS 2 control + navigation stack.

## Prerequisites

Before starting this section, ensure you have:

- **Completed [M2-C1-S6](./S6.md)**: Joint controllers configured
- **ros_gz installed**: `sudo apt install ros-kilted-ros-gz`
- **Gazebo Ionic running**: World with sensors and robot
- **Understanding of ROS 2 topics**: Publishers, subscribers, message types

## Learning Objectives

By the end of this section, you will be able to:

- **[Beginner]** Explain ros_gz_bridge architecture and message conversion
- **[Beginner]** Configure basic topic bridges using YAML
- **[Intermediate]** Create complete launch files for simulation integration
- **[Intermediate]** Debug bridge connectivity issues
- **[Advanced]** Optimize bridge performance for high-bandwidth sensors
- **[Advanced]** Implement custom message bridging
- **[Expert]** Design production-ready simulation architectures

## Key Concepts

| Term | Definition | Why It Matters |
|------|------------|----------------|
| **ros_gz_bridge** | Node that converts Gazebo ‚Üî ROS 2 messages | Core integration component |
| **Topic Mapping** | Association between Gazebo and ROS 2 topics | Defines data flow |
| **Direction** | GZ_TO_ROS, ROS_TO_GZ, or BIDIRECTIONAL | Controls message flow |
| **Message Conversion** | Type translation (gz.msgs ‚Üí sensor_msgs) | Enables interoperability |
| **use_sim_time** | ROS 2 uses Gazebo clock | Time synchronization |

:::danger Latency Trap Warning
**ros_gz_bridge must run locally with Gazebo.** Remote bridging adds network latency to every sensor reading and command:
- Run bridge, Gazebo, and ROS 2 controllers on the same machine
- For distributed systems, minimize cross-network traffic
- During deployment, bridge only to the Jetson running locally
:::

## Skill-Level Pathways

:::note For Beginners
Focus on:
1. Installing ros_gz packages
2. Bridging a single topic (camera)
3. Verifying data flow with `ros2 topic echo`
4. Completing **Exercise 1**
:::

:::tip Intermediate Path
If you have ROS 2 experience:
1. Configure multi-topic bridges via YAML
2. Create integrated launch files
3. Complete **Exercises 1-2**
:::

:::caution Advanced Path
For production simulation systems:
1. Optimize bridge performance
2. Implement custom message types
3. Complete **Exercise 3** and **Architect Challenge**
:::

---

## Industry Perspectives

:::info Industry Spotlight: Open Robotics
**How Open Robotics uses ros_gz_bridge:**
The official bridge was developed for DARPA SubT Challenge, supporting 100+ robots with cameras, lidars, and IMUs. They optimized for low-latency, high-bandwidth sensor streaming.

**Key metrics:**
- **Camera latency**: &lt;10ms at 30Hz
- **Lidar throughput**: 1M points/sec
- **Multi-robot**: 20+ simultaneous bridges
:::

:::info Industry Spotlight: Clearpath Robotics
**How Clearpath uses simulation integration:**
Clearpath's simulation packages for Husky, Jackal use ros_gz_bridge for Nav2 testing. They prioritize 1:1 topic compatibility with real hardware.

**Key metrics:**
- **Topic compatibility**: 100% with real robot
- **Sim-to-real gap**: &lt;5% navigation accuracy
- **CI/CD**: 1000+ simulation tests/day
:::

---

## Hardware Requirements

**Workstation** (from M1-C1-S1)
- Ubuntu 24.04 LTS
- NVIDIA RTX 5080/6080 (16GB+ VRAM) for 2025 high-bandwidth sensor bridging
- ROS 2 Kilted Kaiju + Gazebo Ionic (M2-C1-S1)
- 16-core CPU for multi-node Zenoh/DDS communication processing

## Connection to Capstone

The capstone uses ros_gz_bridge for:

1. **Sensor Integration**: Bridge camera, IMU, lidar data from Gazebo to ROS 2 perception nodes
2. **Control Commands**: Send velocity commands from Nav2 to simulated robot
3. **TF Tree**: Synchronize Gazebo model transforms with ROS 2 TF
4. **Debugging**: Visualize Gazebo sensor data in RViz2
5. **Testing**: Validate ROS 2 algorithms in simulation before hardware deployment

**Bridge Architecture**:
```
Gazebo Topics              ros_gz_bridge              ROS 2 Topics
/world/default/model/     ‚Üê‚Üí Message Translation ‚Üê‚Üí  /joint_states
  /joint_state                                        /cmd_vel
/camera                                               /camera/image_raw
/imu                                                  /imu/data
```

## Implementation

### Step 1: Install ros_gz Bridge

**Install Packages**:
```bash
sudo apt install ros-kilted-ros-gz -y
```

**Verify Installation**:
```bash
ros2 pkg list | grep ros_gz
# Should show:
# ros_gz
# ros_gz_bridge
# ros_gz_sim
# ros_gz_image
```

### Step 2: Bridge Configuration

**Method 1: Parameter File** (Recommended for complex mappings):

**File**: `~/ros2_ws/src/humanoid_description/config/bridge_config.yaml`

```yaml
# Gazebo ‚Üî ROS 2 Topic Mappings

# 1. Joint States (Gazebo ‚Üí ROS 2)
- ros_topic_name: "/joint_states"
  gz_topic_name: "/world/default/model/humanoid_arm/joint_state"
  ros_type_name: "sensor_msgs/msg/JointState"
  gz_type_name: "gz.msgs.Model"
  direction: GZ_TO_ROS

# 2. Camera Image (Gazebo ‚Üí ROS 2)
- ros_topic_name: "/camera/image_raw"
  gz_topic_name: "/camera"
  ros_type_name: "sensor_msgs/msg/Image"
  gz_type_name: "gz.msgs.Image"
  direction: GZ_TO_ROS

# 3. Camera Info (Gazebo ‚Üí ROS 2)
- ros_topic_name: "/camera/camera_info"
  gz_topic_name: "/camera_info"
  ros_type_name: "sensor_msgs/msg/CameraInfo"
  gz_type_name: "gz.msgs.CameraInfo"
  direction: GZ_TO_ROS

# 4. IMU Data (Gazebo ‚Üí ROS 2)
- ros_topic_name: "/imu/data"
  gz_topic_name: "/imu"
  ros_type_name: "sensor_msgs/msg/Imu"
  gz_type_name: "gz.msgs.IMU"
  direction: GZ_TO_ROS

# 5. Lidar Scan (Gazebo ‚Üí ROS 2)
- ros_topic_name: "/scan"
  gz_topic_name: "/lidar"
  ros_type_name: "sensor_msgs/msg/LaserScan"
  gz_type_name: "gz.msgs.LaserScan"
  direction: GZ_TO_ROS

# 6. Depth Camera (Gazebo ‚Üí ROS 2)
- ros_topic_name: "/camera/depth/image_raw"
  gz_topic_name: "/depth_camera"
  ros_type_name: "sensor_msgs/msg/Image"
  gz_type_name: "gz.msgs.Image"
  direction: GZ_TO_ROS

# 7. Velocity Commands (ROS 2 ‚Üí Gazebo)
- ros_topic_name: "/cmd_vel"
  gz_topic_name: "/model/humanoid_arm/cmd_vel"
  ros_type_name: "geometry_msgs/msg/Twist"
  gz_type_name: "gz.msgs.Twist"
  direction: ROS_TO_GZ

# 8. Clock (Gazebo ‚Üí ROS 2)
- ros_topic_name: "/clock"
  gz_topic_name: "/clock"
  ros_type_name: "rosgraph_msgs/msg/Clock"
  gz_type_name: "gz.msgs.Clock"
  direction: GZ_TO_ROS

# 9. TF Transforms (Gazebo ‚Üí ROS 2)
- ros_topic_name: "/tf"
  gz_topic_name: "/model/humanoid_arm/pose"
  ros_type_name: "tf2_msgs/msg/TFMessage"
  gz_type_name: "gz.msgs.Pose_V"
  direction: GZ_TO_ROS

# 10. Odometry (Gazebo ‚Üí ROS 2)
- ros_topic_name: "/odom"
  gz_topic_name: "/model/humanoid_arm/odometry"
  ros_type_name: "nav_msgs/msg/Odometry"
  gz_type_name: "gz.msgs.Odometry"
  direction: GZ_TO_ROS
```

**Launch Bridge with Config**:
```bash
ros2 run ros_gz_bridge parameter_bridge --ros-args -p config_file:=/path/to/bridge_config.yaml
```

**Method 2: Command-Line Arguments** (Quick testing):

```bash
# Bridge single topic
ros2 run ros_gz_bridge parameter_bridge /camera@sensor_msgs/msg/Image[gz.msgs.Image

# Bridge multiple topics
ros2 run ros_gz_bridge parameter_bridge \
  /camera@sensor_msgs/msg/Image[gz.msgs.Image \
  /imu@sensor_msgs/msg/Imu[gz.msgs.IMU \
  /cmd_vel@geometry_msgs/msg/Twist]gz.msgs.Twist
```

**Direction Syntax**:
- `[` = Gazebo ‚Üí ROS 2 (GZ_TO_ROS)
- `]` = ROS 2 ‚Üí Gazebo (ROS_TO_GZ)
- `@` = Bidirectional

### Step 3: Complete Integration Launch File

**File**: `~/ros2_ws/src/humanoid_description/launch/sim_integration.launch.py`

```python
#!/usr/bin/env python3
"""
Complete ROS 2-Gazebo Integration
Launches Gazebo, controllers, bridge, and RViz2
"""

import os
from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription, ExecuteProcess, TimerAction
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch_ros.actions import Node

def generate_launch_description():
    # Package paths
    humanoid_desc_dir = get_package_share_directory('humanoid_description')
    humanoid_control_dir = get_package_share_directory('humanoid_control')

    # URDF
    urdf_file = os.path.join(humanoid_desc_dir, 'urdf', 'humanoid_arm.urdf.xacro')

    # World file
    world_file = os.path.join(humanoid_desc_dir, 'worlds', 'indoor_lab.world')

    # Bridge config
    bridge_config = os.path.join(humanoid_desc_dir, 'config', 'bridge_config.yaml')

    # Controller config
    controller_config = os.path.join(humanoid_control_dir, 'config', 'controllers.yaml')

    # RViz config
    rviz_config = os.path.join(humanoid_desc_dir, 'rviz', 'sim_integration.rviz')

    return LaunchDescription([
        # 1. Launch Gazebo
        ExecuteProcess(
            cmd=['gz', 'sim', '-r', world_file],
            output='screen',
            name='gazebo'
        ),

        # 2. Spawn robot (wait 2s for Gazebo to start)
        TimerAction(
            period=2.0,
            actions=[
                ExecuteProcess(
                    cmd=[
                        'ros2', 'run', 'ros_gz_sim', 'create',
                        '-name', 'humanoid_arm',
                        '-file', urdf_file,
                        '-x', '0.0',
                        '-y', '0.0',
                        '-z', '0.5'
                    ],
                    output='screen'
                )
            ]
        ),

        # 3. ros_gz_bridge
        Node(
            package='ros_gz_bridge',
            executable='parameter_bridge',
            parameters=[{'config_file': bridge_config}],
            output='screen',
            name='ros_gz_bridge'
        ),

        # 4. Robot State Publisher
        Node(
            package='robot_state_publisher',
            executable='robot_state_publisher',
            parameters=[{'robot_description': urdf_file}],
            output='screen'
        ),

        # 5. Controller Manager
        Node(
            package='controller_manager',
            executable='ros2_control_node',
            parameters=[controller_config],
            output='screen'
        ),

        # 6. Load Controllers (wait 3s for controller manager)
        TimerAction(
            period=3.0,
            actions=[
                ExecuteProcess(
                    cmd=['ros2', 'control', 'load_controller', '--set-state', 'active',
                         'joint_state_broadcaster'],
                    output='screen'
                ),
                ExecuteProcess(
                    cmd=['ros2', 'control', 'load_controller', '--set-state', 'active',
                         'arm_trajectory_controller'],
                    output='screen'
                ),
            ]
        ),

        # 7. RViz2
        Node(
            package='rviz2',
            executable='rviz2',
            arguments=['-d', rviz_config],
            output='screen'
        ),
    ])
```

**Launch System**:
```bash
ros2 launch humanoid_description sim_integration.launch.py
```

### Step 4: Verify Bridge Connectivity

**Diagnostic Commands**:

```bash
# 1. Check Gazebo topics
gz topic -l

# 2. Check ROS 2 topics
ros2 topic list

# 3. Verify bridge is running
ros2 node list | grep ros_gz_bridge

# 4. Check topic mappings
ros2 topic info /camera/image_raw
# Should show: Publishers: 1, Subscribers: 0 (if no subscribers yet)

# 5. Echo bridged topic
ros2 topic echo /imu/data

# 6. Monitor topic rates
ros2 topic hz /camera/image_raw
ros2 topic hz /joint_states

# 7. Check TF tree
ros2 run tf2_tools view_frames
evince frames.pdf
```

### Step 5: Image Transport Bridge

**For efficient image transfer** (compressed, theora):

```bash
# Install image transport
sudo apt install ros-kilted-image-transport-plugins -y
```

**Launch image transport bridge**:

```python
# In launch file
Node(
    package='ros_gz_image',
    executable='image_bridge',
    arguments=['/camera'],  # Gazebo topic
    remappings=[
        ('/camera', '/camera/image_raw')  # ROS 2 topic
    ],
    output='screen'
)
```

**Compressed image topics**:
```bash
# Subscribe to compressed image
ros2 topic echo /camera/image_raw/compressed
```

### Step 6: Simulation Time Synchronization

**Use Gazebo clock in ROS 2**:

```bash
# Set ROS 2 to use simulation time
export ROS_USE_SIM_TIME=true

# Or in launch file:
SetParameter('use_sim_time', True)
```

**Verify clock synchronization**:
```bash
# Check ROS 2 clock
ros2 topic echo /clock

# Compare with Gazebo clock
gz topic -e -t /clock
```

### Step 7: Custom Message Bridging

**For custom Gazebo messages**:

```cpp
// Custom bridge plugin example
// File: custom_bridge.cpp

#include <ros_gz_bridge/convert.hpp>
#include <rclcpp/rclcpp.hpp>

// Register custom message conversion
namespace ros_gz_bridge
{

template<>
void convert_ros_to_gz(
  const my_msgs::msg::CustomMessage & ros_msg,
  gz::msgs::CustomMessage & gz_msg)
{
  gz_msg.set_data(ros_msg.data);
  // ... convert fields
}

template<>
void convert_gz_to_ros(
  const gz::msgs::CustomMessage & gz_msg,
  my_msgs::msg::CustomMessage & ros_msg)
{
  ros_msg.data = gz_msg.data();
  // ... convert fields
}

}  // namespace ros_gz_bridge
```

## Bridge Performance Tuning

**Optimize Bridge Performance**:

```yaml
# In bridge_config.yaml

# 1. Reduce update rates for high-bandwidth topics
- ros_topic_name: "/camera/image_raw"
  gz_topic_name: "/camera"
  ros_type_name: "sensor_msgs/msg/Image"
  gz_type_name: "gz.msgs.Image"
  direction: GZ_TO_ROS
  throttle_rate: 10.0  # Limit to 10 Hz

# 2. Use lazy subscription (only bridge when subscribers exist)
lazy_subscription: true

# 3. Queue size tuning
queue_size: 10  # Default is 1000 (may cause lag)
```

**Monitor Bridge Performance**:
```bash
# Check CPU usage
top -p $(pgrep -f ros_gz_bridge)

# Check topic bandwidth
ros2 topic bw /camera/image_raw

# Check latency
ros2 topic delay /imu/data
```

## Common Bridge Issues

**Troubleshooting Table**:

| Issue | Symptom | Solution |
|-------|---------|----------|
| **Topic not bridged** | `ros2 topic list` doesn't show topic | Check topic names in config, verify Gazebo topic exists with `gz topic -l` |
| **Wrong message type** | Type mismatch error | Verify `ros_type_name` and `gz_type_name` match exactly |
| **High latency** | Delayed sensor data | Reduce bridge queue size, increase Gazebo real-time factor |
| **Bridge crashes** | Node terminates | Check for missing message type plugins, verify Gazebo version compatibility |
| **TF not synchronized** | Robot jumps in RViz | Enable `/clock` bridging, set `use_sim_time=true` |
| **No image display** | Black image in RViz | Check camera sensor is publishing in Gazebo, verify image encoding |

## Complete System Test

**System Integration Test Script**:

```python
#!/usr/bin/env python3
"""
ROS 2-Gazebo Integration Test
Verify all bridges and systems are operational
"""

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image, Imu, JointState
from geometry_msgs.msg import Twist
import time

class IntegrationTest(Node):
    def __init__(self):
        super().__init__('integration_test')

        # Track received messages
        self.received = {
            'camera': False,
            'imu': False,
            'joint_states': False,
        }

        # Subscribers
        self.create_subscription(Image, '/camera/image_raw', self.camera_cb, 10)
        self.create_subscription(Imu, '/imu/data', self.imu_cb, 10)
        self.create_subscription(JointState, '/joint_states', self.joint_cb, 10)

        # Publisher (test ROS 2 ‚Üí Gazebo)
        self.cmd_pub = self.create_publisher(Twist, '/cmd_vel', 10)

        self.get_logger().info('Integration test initialized')

    def camera_cb(self, msg):
        self.received['camera'] = True

    def imu_cb(self, msg):
        self.received['imu'] = True

    def joint_cb(self, msg):
        self.received['joint_states'] = True

    def test_bridge(self):
        """Test all bridge topics"""
        self.get_logger().info('Testing bridge connections...')

        # Wait for messages
        timeout = 10.0
        start = time.time()

        while time.time() - start < timeout:
            rclpy.spin_once(self, timeout_sec=0.1)

            if all(self.received.values()):
                break

        # Report results
        print('\n' + '='*60)
        print('BRIDGE TEST RESULTS')
        print('='*60)
        for topic, received in self.received.items():
            status = '‚úì' if received else '‚úó'
            print(f'{status} {topic}: {"OK" if received else "FAILED"}')
        print('='*60)

        # Test ROS 2 ‚Üí Gazebo
        print('\nTesting ROS 2 ‚Üí Gazebo...')
        cmd = Twist()
        cmd.linear.x = 0.1
        self.cmd_pub.publish(cmd)
        print('‚úì Sent velocity command to Gazebo')

        return all(self.received.values())


def main(args=None):
    rclpy.init(args=args)
    node = IntegrationTest()

    success = node.test_bridge()

    if success:
        print('\n‚úÖ All tests passed!')
    else:
        print('\n‚ùå Some tests failed!')

    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

---

## Agentic AI Integration

:::warning Agentic AI Consideration
**For autonomous robotics systems:**

The bridge is the communication backbone connecting AI agents to simulated robots:

**AI-Simulation Architecture:**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    AI Agent (ROS 2)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Perception  ‚Üê‚îÄ ros_gz_bridge ‚Üê‚îÄ  Gazebo Sensors        ‚îÇ
‚îÇ  Planning    ‚îÄ‚Üí ros_gz_bridge ‚îÄ‚Üí  Gazebo Actuators      ‚îÇ
‚îÇ  Feedback    ‚Üê‚îÄ ros_gz_bridge ‚Üê‚îÄ  Gazebo State          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Key Agentic Patterns:**

1. **Sensor Fusion from Simulation**
   ```python
   class SimulatedPerception:
       """AI perception using bridged sensors"""
       def __init__(self):
           self.camera_sub = self.create_subscription(
               Image, '/camera/image_raw', self.camera_cb, 10)
           self.imu_sub = self.create_subscription(
               Imu, '/imu/data', self.imu_cb, 10)

       def get_world_state(self) -> WorldState:
           """Fuse sensor data for AI planning"""
           return WorldState(
               rgb_image=self.latest_image,
               orientation=self.latest_imu.orientation,
               acceleration=self.latest_imu.linear_acceleration
           )
   ```

2. **Sim-to-Real Transfer Validation**
   ```python
   def validate_sim_real_parity(sim_topic: str, real_topic: str):
       """Compare simulated vs real sensor data"""
       sim_data = record_topic(sim_topic, duration=10.0)
       real_data = record_topic(real_topic, duration=10.0)

       # Statistical comparison
       mean_error = np.mean(np.abs(sim_data - real_data))
       if mean_error > threshold:
           logging.warning(f"Sim-real gap: {mean_error}")
   ```

**Safety Constraints:**
- **Always** verify bridge connectivity before executing AI actions
- **Never** send commands if sensor data is stale (&gt;100ms)
- **Log** all bridged data for debugging and replay
:::

---

## Practice Exercises

### Exercise 1: Basic Bridge (Beginner)
**Objective:** Bridge camera topic from Gazebo to ROS 2

**Time:** ~15 minutes

**Instructions:**
1. Launch Gazebo with camera sensor
2. Run single-topic bridge command
3. Verify with `ros2 topic echo /camera/image_raw`
4. View in rqt_image_view

**Success Criteria:**
- [ ] Image visible in rqt_image_view
- [ ] Topic publishing at expected rate (30Hz)

---

### Exercise 2: Complete Integration (Intermediate)
**Objective:** Create launch file with all sensor bridges

**Time:** ~30 minutes

**Instructions:**
1. Write bridge_config.yaml with camera, IMU, lidar
2. Create integrated launch file
3. Verify all topics in RViz2
4. Check simulation time sync

---

### Exercise 3: Integration Test (Advanced)
**Objective:** Implement automated bridge verification

**Time:** ~45 minutes

**Instructions:**
1. Implement IntegrationTest from Step 7
2. Test all bridged topics
3. Measure latency and bandwidth
4. Generate test report

---

## Summary

### Key Commands

```bash
# Install ros_gz
sudo apt install ros-kilted-ros-gz

# Single topic bridge
ros2 run ros_gz_bridge parameter_bridge /camera@sensor_msgs/msg/Image[gz.msgs.Image

# Config file bridge
ros2 run ros_gz_bridge parameter_bridge --ros-args -p config_file:=bridge.yaml

# Check topics
ros2 topic list
gz topic -l
```

### Bridge Direction Syntax

| Direction | Symbol | Example |
|-----------|--------|---------|
| Gazebo ‚Üí ROS 2 | `[` | `/camera@Image[gz.msgs.Image` |
| ROS 2 ‚Üí Gazebo | `]` | `/cmd_vel@Twist]gz.msgs.Twist` |
| Bidirectional | `@` | `/joint_states@JointState@gz.msgs.Model` |

### Integration Checklist

- [ ] ros_gz packages installed
- [ ] Bridge config file created
- [ ] All sensor topics bridged
- [ ] Command topics bridged
- [ ] Clock synchronized (use_sim_time)
- [ ] TF tree complete
- [ ] Integration test passing

## Next Steps

**Module 2 Chapter 1 Complete!** ‚úÖ

You have mastered:
- Gazebo Ionic installation and ROS 2 integration (S1)
- Physics engines and simulation parameters (S2)
- World creation and environmental design (S3)
- Contact forces and collision properties (S4)
- Friction models and ground interaction (S5)
- Joint controllers and actuation (S6)
- ROS 2-Gazebo bridge integration (S7)

**Proceed to Module 2 Chapter 2**: URDF in Simulation
- **M2-C2-S1**: Importing Complex URDFs into Gazebo
- **M2-C2-S2**: ros2_control Hardware Interfaces
- **M2-C2-S3**: Gazebo Plugin Development
- **M2-C2-S4**: Multi-Robot Simulation

**Troubleshooting**:
- **Bridge not starting**: Check `ros_gz_bridge` installation, verify config file syntax
- **Topics don't appear**: Wait 2-3 seconds after Gazebo starts, check Gazebo is publishing
- **Image not displaying**: Install `ros-kilted-rqt-image-view`, check encoding (RGB8 vs BGR8)
- **TF not updating**: Verify robot_state_publisher is running, check URDF has correct frames

---

**Assessment Preparation**: This section completes preparation for **Assessment 3: Simulation and Sim-to-Real (Week 9)**. You must demonstrate complete ROS 2-Gazebo integration with sensors, actuators, and controllers.

**üéì MODULE 2 CHAPTER 1: COMPLETE** ‚úÖ

**Congratulations!** You have built a complete digital twin simulation system with:
- Physics-accurate simulation (ODE/Bullet/DART)
- Realistic environments (worlds, lighting, objects)
- Contact and friction models
- Joint control (PID, impedance, trajectory)
- Full ROS 2 integration

**Total Content**: 7 sections, ~4,600 lines of technical material, 50+ code artifacts

Ready for Module 2 Chapter 2: Advanced URDF in Simulation!
