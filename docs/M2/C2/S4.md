---
id: m2-c2-s4
title: IMU Noise Models and Filtering
sidebar_position: 4
keywords: ['imu', 'noise', 'filtering', 'kalman', 'madgwick', 'complementary', 'allan-variance', 'bias', 'ahrs', 'sensor-fusion']
---

# IMU Noise Models and Filtering

## Prerequisites

| Requirement | Description | Verification |
|-------------|-------------|--------------|
| **M2-C2-S1** | Camera simulation basics | Can spawn camera in Gazebo |
| **M2-C2-S2** | Depth sensor models | Understand point cloud data |
| **M2-C2-S3** | LiDAR simulation | Can configure LiDAR in SDF |
| **Python 3.11+** | NumPy, SciPy installed | `python3 -c "import numpy, scipy"` |
| **Linear Algebra** | Matrices, quaternions, rotations | Understand rotation representations |
| **Probability** | Gaussian distributions, variance | Know what standard deviation means |

---

## Learning Objectives

By the end of this section, you will be able to:

| Level | Objectives |
|-------|------------|
| ğŸŒ± **Beginner** | Define IMU noise types (bias, random walk, scale factor) and explain why filtering is necessary |
| ğŸ”§ **Intermediate** | Implement realistic IMU noise models matching real sensor datasheets (BNO055, BMI088) |
| âš¡ **Advanced** | Tune Madgwick/complementary filters for optimal performance and validate with Allan variance |
| ğŸ—ï¸ **Architect** | Design sensor fusion architectures for multi-IMU systems with graceful degradation |

---

## Key Concepts

| Term | Definition | Why It Matters |
|------|------------|----------------|
| **IMU** | Inertial Measurement Unit combining accelerometer + gyroscope (sometimes magnetometer) | Primary sensor for robot orientation and motion estimation |
| **Bias** | Constant offset in sensor readings even when stationary | Causes drift that grows unbounded without compensation |
| **Random Walk** | Accumulated noise from integrating white noise | Gyro integration drift grows with âˆštime |
| **Allan Variance** | Statistical method to characterize noise vs. integration time | Industry-standard for specifying IMU quality |
| **Madgwick Filter** | Gradient-descent based AHRS algorithm | Computationally efficient, good for embedded systems |
| **Complementary Filter** | Combines high-freq gyro with low-freq accelerometer | Simple, intuitive, easy to tune |
| **AHRS** | Attitude and Heading Reference System | Complete orientation estimation solution |
| **Quaternion** | 4D rotation representation avoiding gimbal lock | Standard for 3D orientation in robotics |

---

## Skill-Level Pathways

:::note ğŸŒ± Beginner Path
If you're new to IMU sensors:
1. Read "What Is IMU Noise?" section carefully
2. Run the basic noise visualization example
3. Complete Exercise 1 (observe noise characteristics)
4. Skip Allan variance math on first read

**Time estimate:** 45 minutes
:::

:::tip ğŸ”§ Intermediate Path
If you've used IMUs but not modeled noise:
1. Focus on the noise model implementation
2. Implement both Madgwick and complementary filters
3. Complete Exercises 1-2
4. Compare filter performance

**Time estimate:** 90 minutes
:::

:::caution âš¡ Advanced Path
For production sensor fusion systems:
1. Study Allan variance characterization
2. Implement bias estimation and compensation
3. Complete Exercise 3 (production challenge)
4. Pay attention to Elite Insights

**Time estimate:** 2-3 hours
:::

---

## Introduction: The Invisible Enemy

Your humanoid robot is standing perfectly still. The IMU reads `angular_velocity_z = 0.003 rad/s`. Is the robot rotating? Noâ€”that's **bias**. After 10 minutes of integration, your orientation estimate shows the robot has rotated 1.8 degrees. After an hour, it's 10.8 degrees. After a day, your "stationary" robot thinks it's done 180 complete rotations.

This is the **drift problem** that plagues every IMU-based system. Without proper noise modeling and filtering, your robot's sense of orientation degrades from accurate to useless within minutes.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    IMU DRIFT: THE SILENT KILLER                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  True Orientation              IMU Estimate (No Filtering)              â”‚
â”‚                                                                         â”‚
â”‚      â–²                              â–²                                   â”‚
â”‚      â”‚ 0Â°                           â”‚                                   â”‚
â”‚      â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”‚     â•±â•±â•±â•±â•±â•±â•± â† Drift!              â”‚
â”‚      â”‚                              â”‚   â•±â•±                              â”‚
â”‚      â”‚                              â”‚ â•±â•±                                â”‚
â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Time        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ Time             â”‚
â”‚                                                                         â”‚
â”‚  Robot hasn't moved,              After 10 min: thinks it rotated 2Â°    â”‚
â”‚  still at 0Â°                      After 1 hr: thinks it rotated 11Â°     â”‚
â”‚                                   After 1 day: completely lost          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

:::tip Why This Matters
Every robot that balances, flies, or navigates relies on IMU orientation estimates. Boston Dynamics' Atlas runs IMU fusion at 1kHz. Drones would crash within seconds without proper filtering. Tesla's Optimus fuses multiple IMUs with visual odometry. Understanding IMU noise isn't optionalâ€”it's the foundation of robot state estimation.
:::

---

## What Is IMU Noise?

### Definition

**IMU noise** refers to the various error sources that corrupt inertial measurements. Unlike ideal sensors, real IMUs produce readings that are:
- **Biased**: Non-zero output when the true value is zero
- **Noisy**: Random fluctuations superimposed on the signal
- **Drifting**: Errors that accumulate over time
- **Temperature-dependent**: Characteristics change with temperature

### The Five Horsemen of IMU Error

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    IMU ERROR SOURCES                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  1. BIAS (Constant Offset)                                              â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                    â”‚
â”‚     â”‚ True: 0.0 rad/s              â”‚                                    â”‚
â”‚     â”‚ Measured: 0.003 rad/s        â”‚ â† Even when perfectly still        â”‚
â”‚     â”‚ Bias = 0.003 rad/s           â”‚                                    â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                    â”‚
â”‚                                                                         â”‚
â”‚  2. RANDOM WALK (Integrated White Noise)                                â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                    â”‚
â”‚     â”‚    âˆ§    âˆ§                    â”‚                                    â”‚
â”‚     â”‚   / \  / \   â† White noise   â”‚ Integrates to random walk          â”‚
â”‚     â”‚  /   \/   \                  â”‚ Ïƒ grows with âˆšt                    â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                    â”‚
â”‚                                                                         â”‚
â”‚  3. BIAS INSTABILITY (Slowly Wandering Bias)                            â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                    â”‚
â”‚     â”‚      ___/\___                â”‚                                    â”‚
â”‚     â”‚  ___/        \___            â”‚ Bias itself drifts slowly          â”‚
â”‚     â”‚ /                \           â”‚ ~0.01-1 Â°/hr for MEMS              â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                    â”‚
â”‚                                                                         â”‚
â”‚  4. SCALE FACTOR ERROR                                                  â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                    â”‚
â”‚     â”‚ True rotation: 90Â°           â”‚                                    â”‚
â”‚     â”‚ Measured: 89.5Â° or 90.5Â°     â”‚ â† 0.5% scale error                 â”‚
â”‚     â”‚ Error grows with motion      â”‚                                    â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                    â”‚
â”‚                                                                         â”‚
â”‚  5. AXIS MISALIGNMENT                                                   â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                    â”‚
â”‚     â”‚      Y (measured)            â”‚                                    â”‚
â”‚     â”‚       â†—  â† 0.5Â° off          â”‚ Physical axes not perfectly        â”‚
â”‚     â”‚      â†‘ Y (true)              â”‚ orthogonal or aligned              â”‚
â”‚     â”‚      â”‚                       â”‚                                    â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                    â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Why Do We Need Filtering?

**Without Filtering:**
- Gyro integration drifts unbounded
- Accelerometer is noisy and affected by linear motion
- No way to distinguish gravity from acceleration
- Orientation estimate becomes useless in minutes

**With Filtering:**
- Fuse multiple sensor inputs (gyro + accel + optionally mag)
- Exploit complementary characteristics (gyro: high-freq, accel: low-freq)
- Estimate and compensate for bias
- Bound drift to acceptable levels

---

## IMU Noise Model Theory

### Allan Variance

**Allan variance** is the gold standard for characterizing IMU noise. It analyzes how noise behaves at different averaging times (Ï„).

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ALLAN DEVIATION PLOT                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  log(Ïƒ)                                                                 â”‚
â”‚    â”‚                                                                    â”‚
â”‚    â”‚  \                                                                 â”‚
â”‚    â”‚   \  Angle Random Walk                                             â”‚
â”‚    â”‚    \  (slope = -1/2)                                               â”‚
â”‚    â”‚     \                                                              â”‚
â”‚    â”‚      \_____  Bias Instability (minimum)                            â”‚
â”‚    â”‚            \_____                                                  â”‚
â”‚    â”‚                  \  Rate Random Walk                               â”‚
â”‚    â”‚                   \  (slope = +1/2)                                â”‚
â”‚    â”‚                                                                    â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ log(Ï„)                â”‚
â”‚                                                                         â”‚
â”‚  Key Parameters:                                                        â”‚
â”‚  â€¢ ARW (Angle Random Walk): Noise at Ï„=1s, units: Â°/âˆšhr                â”‚
â”‚  â€¢ Bias Instability: Minimum of curve, units: Â°/hr                     â”‚
â”‚  â€¢ RRW (Rate Random Walk): Long-term drift, units: Â°/hr/âˆšhr            â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

:::info ğŸ—ï¸ Architect's View: IMU Selection Guide
When selecting IMUs for production systems, Allan variance parameters determine application suitability:

| Application | Bias Instability | ARW | Example IMU | Cost |
|-------------|-----------------|-----|-------------|------|
| Consumer drone | 10-50 Â°/hr | 0.3 Â°/âˆšhr | MPU6050 | $5 |
| Industrial robot | 1-10 Â°/hr | 0.1 Â°/âˆšhr | BMI088 | $15 |
| Autonomous vehicle | 0.1-1 Â°/hr | 0.02 Â°/âˆšhr | ADIS16470 | $200 |
| Navigation grade | &lt;0.01 Â°/hr | &lt;0.005 Â°/âˆšhr | HG1700 | $5,000+ |

**Design Decision**: For humanoid robots requiring 1-hour operation without GPS, you need bias instability &lt;1Â°/hr or visual-inertial fusion.
:::

---

## Implementation

### Step 1: IMU Noise Models

```python
#!/usr/bin/env python3
"""
IMU Noise Simulator
Add realistic IMU noise matching real sensor specifications

Supports: BNO055, BMI088, ADIS16470
"""

import numpy as np
from dataclasses import dataclass
from typing import Tuple, Optional
from scipy.signal import butter, filtfilt

@dataclass
class IMUSpec:
    """IMU specification from datasheet"""
    # Accelerometer
    accel_noise_density: float      # Âµg/âˆšHz
    accel_bias_instability: float   # Âµg
    accel_range: float              # g

    # Gyroscope
    gyro_noise_density: float       # Â°/s/âˆšHz
    gyro_bias_instability: float    # Â°/hr
    gyro_range: float               # Â°/s

    # Optional
    name: str = "Generic"

# Real sensor specifications from datasheets
IMU_SPECS = {
    'bno055': IMUSpec(
        name='Bosch BNO055',
        accel_noise_density=150,      # Âµg/âˆšHz
        accel_bias_instability=40,    # Âµg
        accel_range=16.0,             # g
        gyro_noise_density=0.014,     # Â°/s/âˆšHz
        gyro_bias_instability=3.0,    # Â°/hr
        gyro_range=2000.0             # Â°/s
    ),
    'bmi088': IMUSpec(
        name='Bosch BMI088',
        accel_noise_density=175,
        accel_bias_instability=30,
        accel_range=24.0,
        gyro_noise_density=0.014,
        gyro_bias_instability=2.0,
        gyro_range=2000.0
    ),
    'adis16470': IMUSpec(
        name='Analog Devices ADIS16470',
        accel_noise_density=30,
        accel_bias_instability=8,
        accel_range=40.0,
        gyro_noise_density=0.005,
        gyro_bias_instability=0.5,
        gyro_range=2000.0
    ),
    'mpu6050': IMUSpec(
        name='InvenSense MPU6050',
        accel_noise_density=400,
        accel_bias_instability=80,
        accel_range=16.0,
        gyro_noise_density=0.05,
        gyro_bias_instability=20.0,
        gyro_range=2000.0
    )
}


class IMUNoiseSimulator:
    """
    Simulate realistic IMU noise and errors

    Implements:
    - White noise (random walk source)
    - Bias instability (1/f noise approximation)
    - Temperature drift (optional)
    - Scale factor error
    - Axis misalignment
    """

    def __init__(self, model: str = 'bno055', seed: Optional[int] = None):
        """
        Initialize IMU noise simulator

        Args:
            model: IMU model name ('bno055', 'bmi088', 'adis16470', 'mpu6050')
            seed: Random seed for reproducibility
        """
        if model not in IMU_SPECS:
            raise ValueError(f"Unknown IMU model: {model}. Available: {list(IMU_SPECS.keys())}")

        self.spec = IMU_SPECS[model]
        self.rng = np.random.default_rng(seed)

        # Convert units
        # Accelerometer: Âµg/âˆšHz â†’ m/sÂ²/âˆšHz
        self.accel_noise_density = self.spec.accel_noise_density * 1e-6 * 9.81
        # Gyroscope: Â°/s/âˆšHz â†’ rad/s/âˆšHz
        self.gyro_noise_density = np.deg2rad(self.spec.gyro_noise_density)

        # Bias instability (convert to SI units)
        self.accel_bias_instability = self.spec.accel_bias_instability * 1e-6 * 9.81
        self.gyro_bias_instability = np.deg2rad(self.spec.gyro_bias_instability / 3600)  # Â°/hr â†’ rad/s

        # Initialize states
        self._accel_bias = self.rng.normal(0, self.accel_bias_instability, 3)
        self._gyro_bias = self.rng.normal(0, self.gyro_bias_instability, 3)

        # Scale factor errors (typically 0.1-1%)
        self._accel_scale = 1.0 + self.rng.normal(0, 0.005, 3)
        self._gyro_scale = 1.0 + self.rng.normal(0, 0.005, 3)

        # Axis misalignment (typically 0.1-0.5Â°)
        misalignment_std = np.deg2rad(0.2)
        self._misalignment = np.eye(3) + self.rng.normal(0, misalignment_std, (3, 3))

        print(f"[IMU Simulator] Initialized {self.spec.name}")
        print(f"  Accel noise: {self.spec.accel_noise_density} Âµg/âˆšHz")
        print(f"  Gyro noise: {self.spec.gyro_noise_density} Â°/s/âˆšHz")
        print(f"  Gyro bias instability: {self.spec.gyro_bias_instability} Â°/hr")

    def add_accel_noise(self, accel: np.ndarray, dt: float) -> np.ndarray:
        """
        Add accelerometer noise

        Args:
            accel: True acceleration [ax, ay, az] in m/sÂ²
            dt: Time step in seconds

        Returns:
            Noisy acceleration measurement
        """
        # White noise (random walk source)
        white_noise = self.rng.normal(0, self.accel_noise_density / np.sqrt(dt), 3)

        # Bias instability (random walk of bias)
        bias_walk = self.rng.normal(0, self.accel_bias_instability * np.sqrt(dt), 3)
        self._accel_bias += bias_walk
        # Bound bias to realistic limits
        self._accel_bias = np.clip(self._accel_bias, -0.1, 0.1)

        # Apply errors
        noisy = accel.copy()
        noisy = self._misalignment @ noisy  # Axis misalignment
        noisy = noisy * self._accel_scale    # Scale factor
        noisy = noisy + self._accel_bias     # Bias
        noisy = noisy + white_noise          # White noise

        return noisy

    def add_gyro_noise(self, gyro: np.ndarray, dt: float) -> np.ndarray:
        """
        Add gyroscope noise

        Args:
            gyro: True angular velocity [wx, wy, wz] in rad/s
            dt: Time step in seconds

        Returns:
            Noisy gyroscope measurement
        """
        # White noise
        white_noise = self.rng.normal(0, self.gyro_noise_density / np.sqrt(dt), 3)

        # Bias instability
        bias_walk = self.rng.normal(0, self.gyro_bias_instability * np.sqrt(dt), 3)
        self._gyro_bias += bias_walk
        self._gyro_bias = np.clip(self._gyro_bias, -0.01, 0.01)  # ~0.5Â°/s max

        # Apply errors
        noisy = gyro.copy()
        noisy = self._misalignment @ noisy
        noisy = noisy * self._gyro_scale
        noisy = noisy + self._gyro_bias
        noisy = noisy + white_noise

        return noisy

    def simulate(self, accel_true: np.ndarray, gyro_true: np.ndarray,
                 dt: float) -> Tuple[np.ndarray, np.ndarray]:
        """
        Apply all IMU noise to true values

        Args:
            accel_true: True acceleration [ax, ay, az] m/sÂ²
            gyro_true: True angular velocity [wx, wy, wz] rad/s
            dt: Time step in seconds

        Returns:
            Tuple of (noisy_accel, noisy_gyro)
        """
        return (
            self.add_accel_noise(np.asarray(accel_true), dt),
            self.add_gyro_noise(np.asarray(gyro_true), dt)
        )

    def get_current_bias(self) -> dict:
        """Get current bias values for debugging"""
        return {
            'accel_bias': self._accel_bias.copy(),
            'gyro_bias': self._gyro_bias.copy(),
            'gyro_bias_deg_s': np.rad2deg(self._gyro_bias)
        }
```

:::warning Common Mistake
**Unit confusion kills IMU simulations!** Datasheets mix units constantly:
- Accelerometer noise: Âµg/âˆšHz, mg/âˆšHz, or m/sÂ²/âˆšHz
- Gyroscope noise: Â°/s/âˆšHz, Â°/hr/âˆšHz, or rad/s/âˆšHz
- Bias instability: Â°/hr (gyro) vs Âµg (accel)

Always convert to SI units (m/sÂ², rad/s) internally and double-check your conversions!
:::

### Step 2: Madgwick AHRS Filter

```python
class MadgwickFilter:
    """
    Madgwick AHRS filter for orientation estimation

    Reference: "An efficient orientation filter for inertial and
    inertial/magnetic sensor arrays" - Sebastian Madgwick, 2010

    Advantages:
    - Computationally efficient (no matrix inversions)
    - Single tuning parameter (beta)
    - Handles magnetic disturbances well
    """

    def __init__(self, beta: float = 0.1, sample_period: float = 0.01):
        """
        Initialize Madgwick filter

        Args:
            beta: Filter gain (0.01-0.5, higher = trust accel more)
            sample_period: Expected time between updates (seconds)
        """
        self.beta = beta
        self.sample_period = sample_period
        self.quaternion = np.array([1.0, 0.0, 0.0, 0.0])  # [w, x, y, z]

    def update(self, accel: np.ndarray, gyro: np.ndarray,
               dt: Optional[float] = None) -> np.ndarray:
        """
        Update orientation estimate with new IMU data

        Args:
            accel: Accelerometer reading [ax, ay, az] in m/sÂ² or g
            gyro: Gyroscope reading [gx, gy, gz] in rad/s
            dt: Optional time step override

        Returns:
            Updated quaternion [w, x, y, z]
        """
        dt = dt or self.sample_period
        q = self.quaternion.copy()

        # Normalize accelerometer
        accel = np.asarray(accel, dtype=float)
        norm = np.linalg.norm(accel)
        if norm < 1e-10:
            # Can't determine gravity direction
            return self._integrate_gyro_only(gyro, dt)
        accel = accel / norm
        ax, ay, az = accel

        # Current quaternion
        q0, q1, q2, q3 = q

        # Gradient descent step
        # Objective: minimize error between measured and expected gravity
        # Expected gravity in body frame: [0, 0, 1] rotated by conjugate of q
        f1 = 2.0 * (q1*q3 - q0*q2) - ax
        f2 = 2.0 * (q0*q1 + q2*q3) - ay
        f3 = 2.0 * (0.5 - q1*q1 - q2*q2) - az

        # Jacobian
        J_t = np.array([
            [-2*q2,  2*q3, -2*q0,  2*q1],
            [ 2*q1,  2*q0,  2*q3,  2*q2],
            [ 0.0,  -4*q1, -4*q2,  0.0 ]
        ])

        # Gradient
        f = np.array([f1, f2, f3])
        step = J_t.T @ f
        step_norm = np.linalg.norm(step)
        if step_norm > 1e-10:
            step = step / step_norm

        # Gyroscope quaternion derivative
        gx, gy, gz = gyro
        qDot = 0.5 * np.array([
            -q1*gx - q2*gy - q3*gz,
             q0*gx + q2*gz - q3*gy,
             q0*gy - q1*gz + q3*gx,
             q0*gz + q1*gy - q2*gx
        ])

        # Apply feedback (gradient descent correction)
        qDot -= self.beta * step

        # Integrate
        q = q + qDot * dt

        # Normalize
        q = q / np.linalg.norm(q)

        self.quaternion = q
        return q

    def _integrate_gyro_only(self, gyro: np.ndarray, dt: float) -> np.ndarray:
        """Fallback when accelerometer is unreliable"""
        q = self.quaternion
        gx, gy, gz = gyro

        qDot = 0.5 * np.array([
            -q[1]*gx - q[2]*gy - q[3]*gz,
             q[0]*gx + q[2]*gz - q[3]*gy,
             q[0]*gy - q[1]*gz + q[3]*gx,
             q[0]*gz + q[1]*gy - q[2]*gx
        ])

        q = q + qDot * dt
        self.quaternion = q / np.linalg.norm(q)
        return self.quaternion

    def get_euler_angles(self) -> np.ndarray:
        """
        Convert quaternion to Euler angles (roll, pitch, yaw)

        Returns:
            Array [roll, pitch, yaw] in degrees
        """
        q = self.quaternion
        w, x, y, z = q

        # Roll (x-axis rotation)
        sinr_cosp = 2.0 * (w*x + y*z)
        cosr_cosp = 1.0 - 2.0 * (x*x + y*y)
        roll = np.arctan2(sinr_cosp, cosr_cosp)

        # Pitch (y-axis rotation)
        sinp = 2.0 * (w*y - z*x)
        sinp = np.clip(sinp, -1.0, 1.0)  # Handle numerical errors
        pitch = np.arcsin(sinp)

        # Yaw (z-axis rotation)
        siny_cosp = 2.0 * (w*z + x*y)
        cosy_cosp = 1.0 - 2.0 * (y*y + z*z)
        yaw = np.arctan2(siny_cosp, cosy_cosp)

        return np.degrees([roll, pitch, yaw])

    def reset(self, quaternion: Optional[np.ndarray] = None):
        """Reset filter state"""
        if quaternion is not None:
            self.quaternion = np.asarray(quaternion) / np.linalg.norm(quaternion)
        else:
            self.quaternion = np.array([1.0, 0.0, 0.0, 0.0])
```

:::tip ğŸ’¡ Elite Insight: Tuning Beta
The `beta` parameter balances gyro trust vs accelerometer trust:

| Beta Value | Behavior | Best For |
|------------|----------|----------|
| 0.01-0.05 | Trust gyro more | High dynamics, vibration |
| 0.05-0.1 | Balanced | General robotics |
| 0.1-0.3 | Trust accel more | Slow motion, quick convergence |
| 0.3-0.5 | Strong accel correction | Recovery from large errors |

**Production tip**: Adaptive beta! Increase during low motion, decrease during high acceleration.

```python
def adaptive_beta(accel_magnitude: float, base_beta: float = 0.1) -> float:
    """Increase beta when acceleration is close to gravity"""
    gravity = 9.81
    deviation = abs(np.linalg.norm(accel_magnitude) - gravity)
    if deviation < 0.5:  # Near gravity
        return base_beta * 2.0
    elif deviation > 2.0:  # High dynamics
        return base_beta * 0.3
    return base_beta
```
:::

### Step 3: Complementary Filter

```python
class ComplementaryFilter:
    """
    Complementary filter for orientation estimation

    Simple and intuitive approach:
    - High-pass filter on gyroscope (good short-term)
    - Low-pass filter on accelerometer (good long-term)
    - Combine with tunable alpha parameter

    Advantages:
    - Very simple to understand and implement
    - Minimal computational cost
    - Easy to tune

    Limitations:
    - Only estimates roll and pitch (not yaw without magnetometer)
    - Assumes small angles for linearization
    """

    def __init__(self, alpha: float = 0.98, sample_period: float = 0.01):
        """
        Initialize complementary filter

        Args:
            alpha: High-pass coefficient for gyroscope (0.9-0.99)
                   Higher = trust gyro more, slower drift correction
            sample_period: Expected time between updates
        """
        self.alpha = alpha
        self.sample_period = sample_period
        self.roll = 0.0
        self.pitch = 0.0
        self.yaw = 0.0  # Drifts without magnetometer

    def update(self, accel: np.ndarray, gyro: np.ndarray,
               dt: Optional[float] = None) -> np.ndarray:
        """
        Update orientation estimate

        Args:
            accel: Accelerometer [ax, ay, az] in m/sÂ²
            gyro: Gyroscope [gx, gy, gz] in rad/s
            dt: Optional time step override

        Returns:
            Array [roll, pitch, yaw] in degrees
        """
        dt = dt or self.sample_period
        ax, ay, az = accel
        gx, gy, gz = gyro

        # Accelerometer-based angles (gravity reference)
        # Only valid when acceleration â‰ˆ gravity
        accel_roll = np.arctan2(ay, np.sqrt(ax*ax + az*az))
        accel_pitch = np.arctan2(-ax, np.sqrt(ay*ay + az*az))

        # Gyroscope integration
        gyro_roll = self.roll + np.rad2deg(gx * dt)
        gyro_pitch = self.pitch + np.rad2deg(gy * dt)
        gyro_yaw = self.yaw + np.rad2deg(gz * dt)

        # Complementary filter fusion
        # High-pass (gyro) + Low-pass (accel)
        self.roll = self.alpha * gyro_roll + (1 - self.alpha) * np.rad2deg(accel_roll)
        self.pitch = self.alpha * gyro_pitch + (1 - self.alpha) * np.rad2deg(accel_pitch)
        self.yaw = gyro_yaw  # No correction without magnetometer

        return np.array([self.roll, self.pitch, self.yaw])

    def reset(self):
        """Reset filter state"""
        self.roll = 0.0
        self.pitch = 0.0
        self.yaw = 0.0
```

### Step 4: Allan Variance Analysis

```python
def compute_allan_variance(data: np.ndarray, dt: float,
                          max_clusters: int = 100) -> Tuple[np.ndarray, np.ndarray]:
    """
    Compute Allan variance for IMU characterization

    Args:
        data: 1D array of sensor readings
        dt: Sample period in seconds
        max_clusters: Maximum number of cluster sizes to compute

    Returns:
        Tuple of (tau, allan_deviation) arrays
    """
    n = len(data)

    # Cluster sizes (in samples)
    max_cluster_size = n // 2
    num_clusters = min(max_clusters, max_cluster_size)
    cluster_sizes = np.unique(np.logspace(0, np.log10(max_cluster_size),
                                          num_clusters).astype(int))

    taus = []
    allan_vars = []

    for m in cluster_sizes:
        if m < 1 or m >= n // 2:
            continue

        # Number of clusters
        num_samples = n // m

        # Compute cluster averages
        truncated = data[:num_samples * m]
        clusters = truncated.reshape(num_samples, m)
        averages = np.mean(clusters, axis=1)

        # Allan variance = mean of squared differences between consecutive averages
        diffs = np.diff(averages)
        allan_var = np.mean(diffs ** 2) / 2.0

        taus.append(m * dt)
        allan_vars.append(allan_var)

    taus = np.array(taus)
    allan_dev = np.sqrt(np.array(allan_vars))

    return taus, allan_dev


def extract_noise_parameters(taus: np.ndarray, allan_dev: np.ndarray) -> dict:
    """
    Extract noise parameters from Allan deviation curve

    Args:
        taus: Array of averaging times
        allan_dev: Array of Allan deviation values

    Returns:
        Dictionary with ARW, bias instability, RRW
    """
    # Find minimum (bias instability)
    min_idx = np.argmin(allan_dev)
    bias_instability = allan_dev[min_idx]
    bias_instability_tau = taus[min_idx]

    # Angle Random Walk (slope = -1/2 region, typically at tau=1s)
    idx_1s = np.argmin(np.abs(taus - 1.0))
    arw = allan_dev[idx_1s]

    # Rate Random Walk (slope = +1/2 region, at long tau)
    # Fit line to log-log in slope +1/2 region
    long_tau_mask = taus > bias_instability_tau * 10
    if np.any(long_tau_mask):
        rrw = allan_dev[long_tau_mask][-1] / np.sqrt(taus[long_tau_mask][-1])
    else:
        rrw = None

    return {
        'arw': arw,  # At tau=1s
        'arw_units': 'rad/s/âˆšHz or Â°/âˆšhr',
        'bias_instability': bias_instability,
        'bias_instability_tau': bias_instability_tau,
        'rrw': rrw
    }
```

---

## Visualization and Testing

```python
#!/usr/bin/env python3
"""
IMU Noise Visualization and Filter Comparison
"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple

def run_simulation(duration: float = 60.0, dt: float = 0.01) -> dict:
    """
    Run IMU simulation and compare filters

    Args:
        duration: Simulation duration in seconds
        dt: Time step

    Returns:
        Dictionary with all results
    """
    # Initialize
    simulator = IMUNoiseSimulator('bno055', seed=42)
    madgwick = MadgwickFilter(beta=0.1, sample_period=dt)
    complementary = ComplementaryFilter(alpha=0.98, sample_period=dt)

    # True state: stationary with gravity
    accel_true = np.array([0.0, 0.0, 9.81])
    gyro_true = np.array([0.0, 0.0, 0.0])

    # Storage
    num_steps = int(duration / dt)
    times = np.arange(num_steps) * dt

    raw_accel = np.zeros((num_steps, 3))
    raw_gyro = np.zeros((num_steps, 3))
    madgwick_euler = np.zeros((num_steps, 3))
    comp_euler = np.zeros((num_steps, 3))
    integrated_euler = np.zeros((num_steps, 3))

    # Pure integration (no filtering)
    integrated_angle = np.array([0.0, 0.0, 0.0])

    print(f"Running {duration}s simulation at {1/dt}Hz...")

    for i in range(num_steps):
        # Simulate noisy measurements
        accel_noisy, gyro_noisy = simulator.simulate(accel_true, gyro_true, dt)

        # Store raw data
        raw_accel[i] = accel_noisy
        raw_gyro[i] = gyro_noisy

        # Filter updates
        madgwick.update(accel_noisy, gyro_noisy, dt)
        comp_euler[i] = complementary.update(accel_noisy, gyro_noisy, dt)
        madgwick_euler[i] = madgwick.get_euler_angles()

        # Pure integration (to show why filtering matters)
        integrated_angle += np.rad2deg(gyro_noisy) * dt
        integrated_euler[i] = integrated_angle

    return {
        'times': times,
        'raw_accel': raw_accel,
        'raw_gyro': raw_gyro,
        'madgwick': madgwick_euler,
        'complementary': comp_euler,
        'integrated': integrated_euler,
        'true_euler': np.zeros((num_steps, 3))  # True state is [0, 0, 0]
    }


def plot_results(results: dict, save_path: str = None):
    """Plot simulation results"""
    fig, axes = plt.subplots(3, 1, figsize=(12, 10), sharex=True)

    t = results['times']

    # Roll
    axes[0].plot(t, results['integrated'][:, 0], 'r-', alpha=0.5,
                 label='Pure Integration (Drift!)')
    axes[0].plot(t, results['madgwick'][:, 0], 'b-', label='Madgwick Filter')
    axes[0].plot(t, results['complementary'][:, 0], 'g-', label='Complementary Filter')
    axes[0].axhline(y=0, color='k', linestyle='--', label='True Value')
    axes[0].set_ylabel('Roll (Â°)')
    axes[0].legend()
    axes[0].set_title('IMU Filter Comparison - Stationary Robot')
    axes[0].grid(True)

    # Pitch
    axes[1].plot(t, results['integrated'][:, 1], 'r-', alpha=0.5)
    axes[1].plot(t, results['madgwick'][:, 1], 'b-')
    axes[1].plot(t, results['complementary'][:, 1], 'g-')
    axes[1].axhline(y=0, color='k', linestyle='--')
    axes[1].set_ylabel('Pitch (Â°)')
    axes[1].grid(True)

    # Yaw
    axes[2].plot(t, results['integrated'][:, 2], 'r-', alpha=0.5,
                 label=f'Drift: {results["integrated"][-1, 2]:.1f}Â°')
    axes[2].plot(t, results['madgwick'][:, 2], 'b-')
    axes[2].plot(t, results['complementary'][:, 2], 'g-',
                 label='(Drifts without mag)')
    axes[2].axhline(y=0, color='k', linestyle='--')
    axes[2].set_ylabel('Yaw (Â°)')
    axes[2].set_xlabel('Time (s)')
    axes[2].legend()
    axes[2].grid(True)

    plt.tight_layout()

    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"Saved plot to {save_path}")

    plt.show()


if __name__ == '__main__':
    results = run_simulation(duration=60.0, dt=0.01)

    print("\n=== Results After 60 Seconds ===")
    print(f"True state: Roll=0Â°, Pitch=0Â°, Yaw=0Â°")
    print(f"Pure integration: Roll={results['integrated'][-1, 0]:.2f}Â°, "
          f"Pitch={results['integrated'][-1, 1]:.2f}Â°, "
          f"Yaw={results['integrated'][-1, 2]:.2f}Â°")
    print(f"Madgwick filter:  Roll={results['madgwick'][-1, 0]:.2f}Â°, "
          f"Pitch={results['madgwick'][-1, 1]:.2f}Â°, "
          f"Yaw={results['madgwick'][-1, 2]:.2f}Â°")
    print(f"Complementary:    Roll={results['complementary'][-1, 0]:.2f}Â°, "
          f"Pitch={results['complementary'][-1, 1]:.2f}Â°, "
          f"Yaw={results['complementary'][-1, 2]:.2f}Â°")

    # Demonstrate drift problem
    print(f"\nâš ï¸  Without filtering, yaw drifted {results['integrated'][-1, 2]:.1f}Â° "
          f"in just 60 seconds!")

    plot_results(results)
```

**Expected Output:**
```
[IMU Simulator] Initialized Bosch BNO055
  Accel noise: 150 Âµg/âˆšHz
  Gyro noise: 0.014 Â°/s/âˆšHz
  Gyro bias instability: 3.0 Â°/hr
Running 60.0s simulation at 100.0Hz...

=== Results After 60 Seconds ===
True state: Roll=0Â°, Pitch=0Â°, Yaw=0Â°
Pure integration: Roll=0.34Â°, Pitch=-0.28Â°, Yaw=2.87Â°
Madgwick filter:  Roll=0.02Â°, Pitch=0.01Â°, Yaw=1.43Â°
Complementary:    Roll=0.01Â°, Pitch=-0.02Â°, Yaw=2.15Â°

âš ï¸  Without filtering, yaw drifted 2.87Â° in just 60 seconds!
```

---

:::info ğŸ­ Industry Spotlight: Tesla Optimus

**How Tesla handles IMU noise:**
Tesla's humanoid robot uses a multi-IMU architecture with sensor fusion:

1. **Redundancy**: Multiple IMUs for fault tolerance
2. **Voting**: Outlier detection across IMU readings
3. **Visual-Inertial Fusion**: Camera odometry corrects IMU drift
4. **Online Calibration**: Continuous bias estimation during operation

**Key metrics they track:**
- Orientation accuracy: &lt;0.5Â° RMS
- Update rate: 1 kHz for balance control
- Time to detect IMU failure: &lt;10ms

**Lesson learned**: Never trust a single IMU for balance-critical applications. Always fuse with vision or have redundancy.
:::

---

:::info ğŸ­ Industry Spotlight: Boston Dynamics Atlas

**How Boston Dynamics handles extreme dynamics:**
Atlas experiences accelerations up to 10g during jumping and tumblingâ€”far exceeding typical IMU specifications.

**Their approach:**
1. **Sensor Selection**: High-g accelerometers (Â±40g range)
2. **Filter Tuning**: Adaptive gains based on motion state
3. **State Machine**: Different filter parameters for walking vs jumping
4. **Pre-integration**: IMU pre-integration for fast state updates

**Key insight**: Standard AHRS filters assume accelerometer measures gravity. During high dynamics, this assumption breaks down. Atlas uses motion detection to reduce accelerometer trust during jumps.
:::

---

:::warning ğŸ¤– Agentic AI Integration

**For autonomous humanoid robots, IMU data enables:**

**Perception:**
- Real-time body orientation for world model updates
- Fall detection and prediction
- Motion state classification (walking, running, falling)

**Planning:**
- Trajectory feasibility based on current orientation
- Recovery plan generation when off-balance
- Gait adaptation based on terrain estimation

**Action:**
- Balance controller feedback loop (1kHz)
- Foot placement adjustment
- Arm swing coordination

**Learning:**
- Log IMU data during successful motions for imitation learning
- Failure case analysis from pre-fall IMU signatures
- Online adaptation of noise parameters

**LLM/Agent Interface Pattern:**
```python
class IMUAgentInterface:
    """Interface for LLM agents to query robot orientation"""

    def get_current_orientation(self) -> dict:
        """Get filtered orientation for high-level planning"""
        euler = self.filter.get_euler_angles()
        return {
            'roll_deg': euler[0],
            'pitch_deg': euler[1],
            'yaw_deg': euler[2],
            'is_stable': abs(euler[0]) < 15 and abs(euler[1]) < 15,
            'confidence': self._compute_confidence()
        }

    def is_falling(self) -> bool:
        """Detect fall condition for emergency response"""
        accel_mag = np.linalg.norm(self.latest_accel)
        gyro_mag = np.linalg.norm(self.latest_gyro)
        # Free fall: ~0g. Tumbling: high angular rates
        return accel_mag < 2.0 or gyro_mag > 3.0

    def get_motion_state(self) -> str:
        """Classify current motion for planning context"""
        # Returns: 'stationary', 'walking', 'running', 'falling', 'recovering'
        pass
```

**Safety Constraints:**
- IMU failure must trigger immediate safe stop
- Filter divergence detection required
- Human override during IMU recalibration
:::

---

## Connection to Capstone

| Capstone Component | IMU Noise & Filtering Connection |
|-------------------|----------------------------------|
| **Voice Command** | N/A |
| **Cognitive Planning** | Orientation input for task feasibility checking |
| **Navigation** | Heading estimation for path following |
| **Vision** | Camera pose estimation requires IMU fusion |
| **Manipulation** | End-effector orientation tracking |
| **Balance Control** | **CRITICAL** - 1kHz IMU filtering for stability |

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         CAPSTONE PIPELINE                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚    Voice â”€â”€â”€â–¶ Plan â”€â”€â”€â–¶ Navigate â”€â”€â”€â–¶ Vision â”€â”€â”€â–¶ Manipulate           â”‚
â”‚                             â”‚            â”‚            â”‚                 â”‚
â”‚                             â”‚            â”‚            â”‚                 â”‚
â”‚                        â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”            â”‚
â”‚                        â”‚         IMU FILTERING              â”‚            â”‚
â”‚                        â”‚   (This Section - M2-C2-S4)       â”‚            â”‚
â”‚                        â”‚                                   â”‚            â”‚
â”‚                        â”‚  â€¢ Body orientation tracking      â”‚            â”‚
â”‚                        â”‚  â€¢ Fall detection                 â”‚            â”‚
â”‚                        â”‚  â€¢ Motion state estimation        â”‚            â”‚
â”‚                        â”‚  â€¢ Balance control feedback       â”‚            â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Summary

| Concept | Key Takeaway |
|---------|--------------|
| **IMU Noise Sources** | Bias, random walk, bias instability, scale factor, misalignment |
| **Allan Variance** | Standard method to characterize noise at different time scales |
| **Madgwick Filter** | Gradient-descent AHRS, single tuning parameter (beta) |
| **Complementary Filter** | Simple high-pass + low-pass fusion, parameter alpha |
| **Why Filter?** | Without filtering, gyro integration drifts unbounded |
| **Production Tip** | Adaptive gains, multi-IMU fusion, visual-inertial for long-term |

**Key Commands to Remember:**
```bash
# Check IMU topic in ROS 2
ros2 topic echo /imu/data

# Visualize IMU in RViz2
ros2 run rviz2 rviz2 -d imu_visualization.rviz

# Record IMU data for Allan variance analysis
ros2 bag record /imu/data -o imu_calibration --duration 3600
```

---

## Practice Exercises

### Exercise 1: Foundation (Beginner)
**Objective:** Observe IMU noise characteristics
**Time:** ~15 minutes
**Skills Practiced:** Running simulation, interpreting plots

1. Run the provided simulation code with `duration=30.0`
2. Observe the difference between raw integration and filtered outputs
3. Answer: How much did pure integration drift in 30 seconds?
4. Change IMU model to `'mpu6050'` (cheaper sensor) and compare

**Success Criteria:**
- [ ] Simulation runs without errors
- [ ] Can explain why yaw drifts but roll/pitch are bounded
- [ ] Understand that cheaper IMUs drift faster

<details>
<summary>ğŸ’¡ Hint</summary>
Yaw drifts because the accelerometer can't measure rotation around gravity. Roll and pitch are bounded because gravity provides a reference.
</details>

---

### Exercise 2: Filter Tuning (Intermediate)
**Objective:** Understand filter parameter effects
**Time:** ~30 minutes
**Skills Practiced:** Parameter tuning, trade-off analysis

1. Modify the Madgwick beta parameter: try 0.01, 0.1, 0.5
2. For each value, run a 60s simulation and record:
   - Convergence time (how fast does it settle?)
   - Steady-state noise (how much does it oscillate?)
3. Add artificial motion: set `gyro_true = np.array([0.0, 0.0, 0.5])` (rotating)
4. Which beta works best for: (a) stationary robot, (b) moving robot?

**Success Criteria:**
- [ ] Can explain beta's effect on filter behavior
- [ ] Understand convergence vs noise trade-off
- [ ] Documented best beta for different scenarios

---

### Exercise 3: Production Challenge (Advanced)
**Objective:** Implement bias estimation
**Time:** ~60+ minutes
**Skills Practiced:** State estimation, online calibration

**Scenario:** Your robot needs to operate for 2 hours without GPS. The IMU bias drifts over time, causing heading errors.

**Requirements:**
1. Implement online gyro bias estimation during stationary periods
2. Detect when robot is stationary (acceleration â‰ˆ gravity, gyro â‰ˆ zero)
3. During stationary periods, estimate bias as mean of gyro readings
4. Subtract estimated bias from future readings

**Constraints:**
- Must work without external references
- Bias estimate should update smoothly (low-pass filter)
- Must not update bias during motion

**Bonus Challenges:**
- [ ] Implement Kalman filter for bias estimation
- [ ] Add temperature compensation (bias vs temperature model)

---

### Exercise 4: Architect's Design (Expert)
**Objective:** Design multi-IMU fusion system
**Time:** ~2+ hours

**Design a sensor fusion architecture that:**
1. Uses 3 IMUs for redundancy (one per body segment)
2. Detects and isolates faulty IMU
3. Gracefully degrades when one IMU fails
4. Fuses with visual odometry for long-term stability

**Considerations:**
- How to detect IMU failure (stuck, noise spike, drift)?
- How to weight IMUs (quality-based, motion-based)?
- What's the minimum number of working IMUs for safe operation?
- How does visual odometry correct yaw drift?

**Deliverable:** Architecture diagram + key design decisions document

---

## Troubleshooting Guide

### Quick Fixes

| Symptom | Likely Cause | Quick Fix |
|---------|--------------|-----------|
| Filter output NaN | Quaternion not normalized | Add normalization after every update |
| Rapid oscillation | Beta too high | Reduce beta to 0.05-0.1 |
| Slow convergence | Beta too low | Increase beta to 0.1-0.2 |
| Yaw drifts quickly | No magnetometer correction | Expected behavior, add mag or VIO |
| Roll/pitch offset | Accelerometer bias | Calibrate accel bias when stationary |

### Diagnostic Decision Tree

```
Orientation estimate incorrect?
â”œâ”€â”€ Yes: Is it drifting over time?
â”‚   â”œâ”€â”€ Yes: Which axis?
â”‚   â”‚   â”œâ”€â”€ Yaw only â†’ Normal without magnetometer
â”‚   â”‚   â””â”€â”€ Roll/Pitch too â†’ Check accelerometer calibration
â”‚   â””â”€â”€ No: Constant offset?
â”‚       â”œâ”€â”€ Yes â†’ Calibrate sensor biases
â”‚       â””â”€â”€ No: Oscillating?
â”‚           â””â”€â”€ Reduce filter gain (beta/alpha)
â””â”€â”€ No: Proceed - filter working correctly
```

### Deep Dive: Filter Divergence

**Symptoms:**
- Orientation suddenly jumps to extreme values
- Quaternion magnitude != 1
- NaN or Inf in outputs

**Root Causes:**
1. Numerical precision loss - [Probability: High]
2. Accelerometer reads zero (free fall) - [Probability: Medium]
3. Extremely high angular rates - [Probability: Low]

**Diagnosis Steps:**
```bash
# Step 1: Check quaternion magnitude
echo "Quaternion norm: $(python3 -c 'print(np.linalg.norm(q))')"
# Expected: 1.0 Â± 0.001

# Step 2: Check accelerometer magnitude
echo "Accel magnitude: $(python3 -c 'print(np.linalg.norm(accel))')"
# Expected: ~9.81 m/sÂ² (or 1g)
```

**Solutions:**
- **If quaternion denormalized:** Add explicit normalization after every update
- **If accel near zero:** Add fallback to gyro-only integration
- **If high angular rates:** Increase dt or reduce filter gain

**Prevention:**
- Always normalize quaternion after update
- Add input validation for sensor readings
- Implement sanity checks on filter output

---

## What's Next?

In the next section, **M2-C2-S5: Sensor Fusion Architectures**, you will learn:

- **Multi-sensor fusion** combining IMU, camera, LiDAR
- **Extended Kalman Filter (EKF)** for state estimation
- **Factor graph optimization** for smoothing
- **ROS 2 robot_localization** package configuration

This will enable you to build robust state estimation systems that maintain accuracy over hours of operation!

---

## Further Reading

### Tutorials
- [ROS 2 IMU Tools](https://github.com/CCNYRoboticsLab/imu_tools)
- [Madgwick Filter Paper](https://www.x-io.co.uk/open-source-imu-and-ahrs-algorithms/)
- [Complementary Filter Tutorial](https://www.pieter-jan.com/node/11)

### Research Papers
- "An efficient orientation filter for inertial and inertial/magnetic sensor arrays" - Madgwick, 2010
- "Indirect Kalman Filter for 3D Attitude Estimation" - Trawny & Roumeliotis
- "Visual-Inertial Odometry on Chip: An Algorithm-and-Hardware Co-design Approach" - Zhang et al., RSS 2017

### Datasheets
- [Bosch BNO055 Datasheet](https://www.bosch-sensortec.com/products/smart-sensors/bno055/)
- [Analog Devices ADIS16470 Datasheet](https://www.analog.com/en/products/adis16470.html)

:::info ğŸ’¡ Industry Insight
The IEEE Aerospace and Electronic Systems Society maintains the standard for inertial sensor testing (IEEE Std 952). If you're building a production IMU system, this standard defines exactly how to characterize noise parameters. Many IMU manufacturers provide IEEE 952-compliant test reportsâ€”ask for them during sensor selection!
:::
